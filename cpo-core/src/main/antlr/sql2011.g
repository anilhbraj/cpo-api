/* 
	filename   : sql2011.antlr
	created on : Jul 24, 2012
	description: sql2011 antlr grammar file
*/

grammar Sql2011;

tokens {

  UNDERSCORE = '_';
  MINUS_SIGN = '-';
  SPACE = ' ';
  DOUBLE_QUOTE = '"';
  PERCENT = '%';
  AMPERSAND = '&';
  QUOTE = '\'';
  LEFT_PAREN = '(';
  RIGHT_PAREN = ')';
  ASTERISK = '*';
  PLUS_SIGN = '+';
  COMMA = ',';
  PERIOD = '.';
  SOLIDUS = '/';
  REVERSE_SOLIDUS = '\\';
  COLON = ':';
  SEMICOLON = ';';
  LESS_THAN_OPERATOR = '<';
  EQUALS_OPERATOR = '=';
  GREATER_THAN_OPERATOR = '>';
  QUESTION_MARK = '?';
  LEFT_BRACKET = '[';
  LEFT_BRACKET_TRIGRAPH = '??(';
  RIGHT_BRACKET = ']';
  RIGHT_BRACKET_TRIGRAPH = '??)';
  CIRCUMFLEX = '^';
  VERTICAL_BAR = '|';
  LEFT_BRACE = '{';
  RIGHT_BRACE = '}';
  NOT_EQUALS_OPERATOR = '<>';
  GREATER_THAN_OR_EQUALS_OPERATOR = '>=';
  LESS_THAN_OR_EQUALS_OPERATOR = '<=';
  CONCATENATION_OPERATOR = '||';
  RIGHT_ARROW = '->';
  DOUBLE_COLON = '::';
  DOUBLE_PERIOD = '..';
  NAMED_ARGUMENT_ASSIGNMENT_TOKEN = '=>';
  BRACKETED_COMMENT_INTRODUCER = '/*';
  BRACKETED_COMMENT_TERMINATOR = '*/';
  DOUBLEQUOTE_SYMBOL = '""';
  KILO = 'K';
  MEGA = 'M';
  GIGA = 'G';
  TERA = 'T';
  PETA = 'P';

  //  <simple comment introducer> ::= <minus sign><minus sign>
  SIMPLE_COMMENT_INTRODUCER = '--';

}

/* helpers to make the language case-insensitive */
fragment a : ('a' | 'A');
fragment b : ('b' | 'B');
fragment c : ('c' | 'C');
fragment d : ('d' | 'D');
fragment e : ('e' | 'E');
fragment f : ('f' | 'F');
fragment g : ('g' | 'G');
fragment h : ('h' | 'H');
fragment i : ('i' | 'I');
fragment j : ('j' | 'J');
fragment k : ('k' | 'K');
fragment l : ('l' | 'L');
fragment m : ('m' | 'M');
fragment n : ('n' | 'N');
fragment o : ('o' | 'O');
fragment p : ('p' | 'P');
fragment q : ('q' | 'Q');
fragment r : ('r' | 'R');
fragment s : ('s' | 'S');
fragment t : ('t' | 'T');
fragment u : ('u' | 'U');
fragment v : ('v' | 'V');
fragment w : ('w' | 'W');
fragment x : ('x' | 'X');
fragment y : ('y' | 'Y');
fragment z : ('z' | 'Z');

/* unicode characters by category */
fragment unicode_cc : '\u0000..\u001F';
fragment unicode_cf : '\u00AD' | '\u0600..\u0604' | '\u06DD' | '\u070F' | '\u200B..\u200F' | '\u202A..\u202E' | '\u2060..\u2064' | '\u206A..\u206F' | '\uFEFF' | '\uFFF9..\uFFFB' | '\u110BD' | '\u1D173..\u1D17A' | '\uE0001';
fragment unicode_co : '\uE000' | '\uF8FF' | '\uF0000' | '\uFFFFD' | '\u100000';
fragment unicode_cs : '\uD800' | '\uDB7F..\uDB80' | '\uDBFF..\uDC00';
fragment unicode_ll : '\u0061..\u007A' | '\u00B5' | '\u00DF..\u00F6' | '\u00F8..\u00FF' | '\u0101' | '\u0103' | '\u0105' | '\u0107' | '\u0109' | '\u010B' | '\u010D' | '\u010F' | '\u0111' | '\u0113' | '\u0115' | '\u0117' | '\u0119' | '\u011B' | '\u011D' | '\u011F' | '\u0121' | '\u0123' | '\u0125' | '\u0127' | '\u0129' | '\u012B' | '\u012D' | '\u012F' | '\u0131' | '\u0133' | '\u0135' | '\u0137..\u0138' | '\u013A' | '\u013C' | '\u013E' | '\u0140' | '\u0142' | '\u0144' | '\u0146' | '\u0148..\u0149' | '\u014B' | '\u014D' | '\u014F' | '\u0151' | '\u0153' | '\u0155' | '\u0157' | '\u0159' | '\u015B' | '\u015D' | '\u015F' | '\u0161' | '\u0163' | '\u0165' | '\u0167' | '\u0169' | '\u016B' | '\u016D' | '\u016F' | '\u0171' | '\u0173' | '\u0175' | '\u0177' | '\u017A' | '\u017C' | '\u017E..\u0180' | '\u0183' | '\u0185' | '\u0188' | '\u018C..\u018D' | '\u0192' | '\u0195' | '\u0199..\u019B' | '\u019E' | '\u01A1' | '\u01A3' | '\u01A5' | '\u01A8' | '\u01AA..\u01AB' | '\u01AD' | '\u01B0' | '\u01B4' | '\u01B6' | '\u01B9..\u01BA' | '\u01BD..\u01BF' | '\u01C6' | '\u01C9' | '\u01CC' | '\u01CE' | '\u01D0' | '\u01D2' | '\u01D4' | '\u01D6' | '\u01D8' | '\u01DA' | '\u01DC..\u01DD' | '\u01DF' | '\u01E1' | '\u01E3' | '\u01E5' | '\u01E7' | '\u01E9' | '\u01EB' | '\u01ED' | '\u01EF..\u01F0' | '\u01F3' | '\u01F5' | '\u01F9' | '\u01FB' | '\u01FD' | '\u01FF' | '\u0201' | '\u0203' | '\u0205' | '\u0207' | '\u0209' | '\u020B' | '\u020D' | '\u020F' | '\u0211' | '\u0213' | '\u0215' | '\u0217' | '\u0219' | '\u021B' | '\u021D' | '\u021F' | '\u0221' | '\u0223' | '\u0225' | '\u0227' | '\u0229' | '\u022B' | '\u022D' | '\u022F' | '\u0231' | '\u0233..\u0239' | '\u023C' | '\u023F..\u0240' | '\u0242' | '\u0247' | '\u0249' | '\u024B' | '\u024D' | '\u024F..\u0293' | '\u0295..\u02AF' | '\u0371' | '\u0373' | '\u0377' | '\u037B..\u037D' | '\u0390' | '\u03AC..\u03CE' | '\u03D0..\u03D1' | '\u03D5..\u03D7' | '\u03D9' | '\u03DB' | '\u03DD' | '\u03DF' | '\u03E1' | '\u03E3' | '\u03E5' | '\u03E7' | '\u03E9' | '\u03EB' | '\u03ED' | '\u03EF..\u03F3' | '\u03F5' | '\u03F8' | '\u03FB..\u03FC' | '\u0430..\u045F' | '\u0461' | '\u0463' | '\u0465' | '\u0467' | '\u0469' | '\u046B' | '\u046D' | '\u046F' | '\u0471' | '\u0473' | '\u0475' | '\u0477' | '\u0479' | '\u047B' | '\u047D' | '\u047F' | '\u0481' | '\u048B' | '\u048D' | '\u048F' | '\u0491' | '\u0493' | '\u0495' | '\u0497' | '\u0499' | '\u049B' | '\u049D' | '\u049F' | '\u04A1' | '\u04A3' | '\u04A5' | '\u04A7' | '\u04A9' | '\u04AB' | '\u04AD' | '\u04AF' | '\u04B1' | '\u04B3' | '\u04B5' | '\u04B7' | '\u04B9' | '\u04BB' | '\u04BD' | '\u04BF' | '\u04C2' | '\u04C4' | '\u04C6' | '\u04C8' | '\u04CA' | '\u04CC' | '\u04CE..\u04CF' | '\u04D1' | '\u04D3' | '\u04D5' | '\u04D7' | '\u04D9' | '\u04DB' | '\u04DD' | '\u04DF' | '\u04E1' | '\u04E3' | '\u04E5' | '\u04E7' | '\u04E9' | '\u04EB' | '\u04ED' | '\u04EF' | '\u04F1' | '\u04F3' | '\u04F5' | '\u04F7' | '\u04F9' | '\u04FB' | '\u04FD' | '\u04FF' | '\u0501' | '\u0503' | '\u0505' | '\u0507' | '\u0509' | '\u050B' | '\u050D' | '\u050F' | '\u0511' | '\u0513' | '\u0515' | '\u0517' | '\u0519' | '\u051B' | '\u051D' | '\u051F' | '\u0521' | '\u0523' | '\u0525' | '\u0527' | '\u0561..\u0587' | '\u1D00..\u1D2B' | '\u1D6B..\u1D77' | '\u1D79..\u1D9A' | '\u1E01' | '\u1E03' | '\u1E05' | '\u1E07' | '\u1E09' | '\u1E0B' | '\u1E0D' | '\u1E0F' | '\u1E11' | '\u1E13' | '\u1E15' | '\u1E17' | '\u1E19' | '\u1E1B' | '\u1E1D' | '\u1E1F' | '\u1E21' | '\u1E23' | '\u1E25' | '\u1E27' | '\u1E29' | '\u1E2B' | '\u1E2D' | '\u1E2F' | '\u1E31' | '\u1E33' | '\u1E35' | '\u1E37' | '\u1E39' | '\u1E3B' | '\u1E3D' | '\u1E3F' | '\u1E41' | '\u1E43' | '\u1E45' | '\u1E47' | '\u1E49' | '\u1E4B' | '\u1E4D' | '\u1E4F' | '\u1E51' | '\u1E53' | '\u1E55' | '\u1E57' | '\u1E59' | '\u1E5B' | '\u1E5D' | '\u1E5F' | '\u1E61' | '\u1E63' | '\u1E65' | '\u1E67' | '\u1E69' | '\u1E6B' | '\u1E6D' | '\u1E6F' | '\u1E71' | '\u1E73' | '\u1E75' | '\u1E77' | '\u1E79' | '\u1E7B' | '\u1E7D' | '\u1E7F' | '\u1E81' | '\u1E83' | '\u1E85' | '\u1E87' | '\u1E89' | '\u1E8B' | '\u1E8D' | '\u1E8F' | '\u1E91' | '\u1E93' | '\u1E95..\u1E9D' | '\u1E9F' | '\u1EA1' | '\u1EA3' | '\u1EA5' | '\u1EA7' | '\u1EA9' | '\u1EAB' | '\u1EAD' | '\u1EAF' | '\u1EB1' | '\u1EB3' | '\u1EB5' | '\u1EB7' | '\u1EB9' | '\u1EBB' | '\u1EBD' | '\u1EBF' | '\u1EC1' | '\u1EC3' | '\u1EC5' | '\u1EC7' | '\u1EC9' | '\u1ECB' | '\u1ECD' | '\u1ECF' | '\u1ED1' | '\u1ED3' | '\u1ED5' | '\u1ED7' | '\u1ED9' | '\u1EDB' | '\u1EDD' | '\u1EDF' | '\u1EE1' | '\u1EE3' | '\u1EE5' | '\u1EE7' | '\u1EE9' | '\u1EEB' | '\u1EED' | '\u1EEF' | '\u1EF1' | '\u1EF3' | '\u1EF5' | '\u1EF7' | '\u1EF9' | '\u1EFB' | '\u1EFD' | '\u1EFF..\u1F07' | '\u1F10..\u1F15' | '\u1F20..\u1F27' | '\u1F30..\u1F37' | '\u1F40..\u1F45' | '\u1F50..\u1F57' | '\u1F60..\u1F67' | '\u1F70..\u1F7D' | '\u1F80..\u1F87' | '\u1F90..\u1F97' | '\u1FA0..\u1FA7' | '\u1FB0..\u1FB4' | '\u1FB6..\u1FB7' | '\u1FBE' | '\u1FC2..\u1FC4' | '\u1FC6..\u1FC7' | '\u1FD0..\u1FD3' | '\u1FD6..\u1FD7' | '\u1FE0..\u1FE7' | '\u1FF2..\u1FF4' | '\u1FF6..\u1FF7' | '\u210A' | '\u210E..\u210F' | '\u2113' | '\u212F' | '\u2134' | '\u2139' | '\u213C..\u213D' | '\u2146..\u2149' | '\u214E' | '\u2184' | '\u2C30..\u2C5E' | '\u2C61' | '\u2C65..\u2C66' | '\u2C68' | '\u2C6A' | '\u2C6C' | '\u2C71' | '\u2C73..\u2C74' | '\u2C76..\u2C7B' | '\u2C81' | '\u2C83' | '\u2C85' | '\u2C87' | '\u2C89' | '\u2C8B' | '\u2C8D' | '\u2C8F' | '\u2C91' | '\u2C93' | '\u2C95' | '\u2C97' | '\u2C99' | '\u2C9B' | '\u2C9D' | '\u2C9F' | '\u2CA1' | '\u2CA3' | '\u2CA5' | '\u2CA7' | '\u2CA9' | '\u2CAB' | '\u2CAD' | '\u2CAF' | '\u2CB1' | '\u2CB3' | '\u2CB5' | '\u2CB7' | '\u2CB9' | '\u2CBB' | '\u2CBD' | '\u2CBF' | '\u2CC1' | '\u2CC3' | '\u2CC5' | '\u2CC7' | '\u2CC9' | '\u2CCB' | '\u2CCD' | '\u2CCF' | '\u2CD1' | '\u2CD3' | '\u2CD5' | '\u2CD7' | '\u2CD9' | '\u2CDB' | '\u2CDD' | '\u2CDF' | '\u2CE1' | '\u2CE3..\u2CE4' | '\u2CEC' | '\u2CEE' | '\u2CF3' | '\u2D00..\u2D25' | '\u2D27' | '\u2D2D' | '\uA641' | '\uA643' | '\uA645' | '\uA647' | '\uA649' | '\uA64B' | '\uA64D' | '\uA64F' | '\uA651' | '\uA653' | '\uA655' | '\uA657' | '\uA659' | '\uA65B' | '\uA65D' | '\uA65F' | '\uA661' | '\uA663' | '\uA665' | '\uA667' | '\uA669' | '\uA66B' | '\uA66D' | '\uA681' | '\uA683' | '\uA685' | '\uA687' | '\uA689' | '\uA68B' | '\uA68D' | '\uA68F' | '\uA691' | '\uA693' | '\uA695' | '\uA697' | '\uA723' | '\uA725' | '\uA727' | '\uA729' | '\uA72B' | '\uA72D' | '\uA72F..\uA731' | '\uA733' | '\uA735' | '\uA737' | '\uA739' | '\uA73B' | '\uA73D' | '\uA73F' | '\uA741' | '\uA743' | '\uA745' | '\uA747' | '\uA749' | '\uA74B' | '\uA74D' | '\uA74F' | '\uA751' | '\uA753' | '\uA755' | '\uA757' | '\uA759' | '\uA75B' | '\uA75D' | '\uA75F' | '\uA761' | '\uA763' | '\uA765' | '\uA767' | '\uA769' | '\uA76B' | '\uA76D' | '\uA76F' | '\uA771..\uA778' | '\uA77A' | '\uA77C' | '\uA77F' | '\uA781' | '\uA783' | '\uA785' | '\uA787' | '\uA78C' | '\uA78E' | '\uA791' | '\uA793' | '\uA7A1' | '\uA7A3' | '\uA7A5' | '\uA7A7' | '\uA7A9' | '\uA7FA' | '\uFB00..\uFB06' | '\uFB13..\uFB17' | '\uFF41..\uFF5A' | '\u10428..\u1044F' | '\u1D41A..\u1D433' | '\u1D44E..\u1D454' | '\u1D456..\u1D467' | '\u1D482..\u1D49B' | '\u1D4B6..\u1D4B9' | '\u1D4BB' | '\u1D4BD..\u1D4C3' | '\u1D4C5..\u1D4CF' | '\u1D4EA..\u1D503' | '\u1D51E..\u1D537' | '\u1D552..\u1D56B' | '\u1D586..\u1D59F' | '\u1D5BA..\u1D5D3' | '\u1D5EE..\u1D607' | '\u1D622..\u1D63B' | '\u1D656..\u1D66F' | '\u1D68A..\u1D6A5' | '\u1D6C2..\u1D6DA' | '\u1D6DC..\u1D6E1' | '\u1D6FC..\u1D714' | '\u1D716..\u1D71B' | '\u1D736..\u1D74E' | '\u1D750..\u1D755' | '\u1D770..\u1D788' | '\u1D78A..\u1D78F' | '\u1D7AA..\u1D7C2' | '\u1D7C4..\u1D7C9';
fragment unicode_lm : '\u02B0..\u02C1' | '\u02C6..\u02D1' | '\u02E0..\u02E4' | '\u02EC' | '\u02EE' | '\u0374' | '\u037A' | '\u0559' | '\u0640' | '\u06E5..\u06E6' | '\u07F4..\u07F5' | '\u07FA' | '\u081A' | '\u0824' | '\u0828' | '\u0971' | '\u0E46' | '\u0EC6' | '\u10FC' | '\u17D7' | '\u1843' | '\u1AA7' | '\u1C78..\u1C7D' | '\u1D2C..\u1D6A' | '\u1D78' | '\u1D9B..\u1DBF' | '\u2071' | '\u207F' | '\u2090..\u209C' | '\u2C7C..\u2C7D' | '\u2D6F' | '\u2E2F' | '\u3005' | '\u3031..\u3035' | '\u303B' | '\u309D..\u309E' | '\u30FC..\u30FE' | '\uA015' | '\uA4F8..\uA4FD' | '\uA60C' | '\uA67F' | '\uA717..\uA71F' | '\uA770' | '\uA788' | '\uA7F8..\uA7F9' | '\uA9CF' | '\uAA70' | '\uAADD' | '\uAAF3..\uAAF4' | '\uFF70' | '\uFF9E..\uFF9F';
fragment unicode_lo : '\u00AA' | '\u00BA' | '\u01BB' | '\u01C0..\u01C3' | '\u0294' | '\u05D0..\u05EA' | '\u05F0..\u05F2' | '\u0620..\u063F' | '\u0641..\u064A' | '\u066E..\u066F' | '\u0671..\u06D3' | '\u06D5' | '\u06EE..\u06EF' | '\u06FA..\u06FC' | '\u06FF' | '\u0710' | '\u0712..\u072F' | '\u074D..\u07A5' | '\u07B1' | '\u07CA..\u07EA' | '\u0800..\u0815' | '\u0840..\u0858' | '\u08A0' | '\u08A2..\u08AC' | '\u0904..\u0939' | '\u093D' | '\u0950' | '\u0958..\u0961' | '\u0972..\u0977' | '\u0979..\u097F' | '\u0985..\u098C' | '\u098F..\u0990' | '\u0993..\u09A8' | '\u09AA..\u09B0' | '\u09B2' | '\u09B6..\u09B9' | '\u09BD' | '\u09CE' | '\u09DC..\u09DD' | '\u09DF..\u09E1' | '\u09F0..\u09F1' | '\u0A05..\u0A0A' | '\u0A0F..\u0A10' | '\u0A13..\u0A28' | '\u0A2A..\u0A30' | '\u0A32..\u0A33' | '\u0A35..\u0A36' | '\u0A38..\u0A39' | '\u0A59..\u0A5C' | '\u0A5E' | '\u0A72..\u0A74' | '\u0A85..\u0A8D' | '\u0A8F..\u0A91' | '\u0A93..\u0AA8' | '\u0AAA..\u0AB0' | '\u0AB2..\u0AB3' | '\u0AB5..\u0AB9' | '\u0ABD' | '\u0AD0' | '\u0AE0..\u0AE1' | '\u0B05..\u0B0C' | '\u0B0F..\u0B10' | '\u0B13..\u0B28' | '\u0B2A..\u0B30' | '\u0B32..\u0B33' | '\u0B35..\u0B39' | '\u0B3D' | '\u0B5C..\u0B5D' | '\u0B5F..\u0B61' | '\u0B71' | '\u0B83' | '\u0B85..\u0B8A' | '\u0B8E..\u0B90' | '\u0B92..\u0B95' | '\u0B99..\u0B9A' | '\u0B9C' | '\u0B9E..\u0B9F' | '\u0BA3..\u0BA4' | '\u0BA8..\u0BAA' | '\u0BAE..\u0BB9' | '\u0BD0' | '\u0C05..\u0C0C' | '\u0C0E..\u0C10' | '\u0C12..\u0C28' | '\u0C2A..\u0C33' | '\u0C35..\u0C39' | '\u0C3D' | '\u0C58..\u0C59' | '\u0C60..\u0C61' | '\u0C85..\u0C8C' | '\u0C8E..\u0C90' | '\u0C92..\u0CA8' | '\u0CAA..\u0CB3' | '\u0CB5..\u0CB9' | '\u0CBD' | '\u0CDE' | '\u0CE0..\u0CE1' | '\u0CF1..\u0CF2' | '\u0D05..\u0D0C' | '\u0D0E..\u0D10' | '\u0D12..\u0D3A' | '\u0D3D' | '\u0D4E' | '\u0D60..\u0D61' | '\u0D7A..\u0D7F' | '\u0D85..\u0D96' | '\u0D9A..\u0DB1' | '\u0DB3..\u0DBB' | '\u0DBD' | '\u0DC0..\u0DC6' | '\u0E01..\u0E30' | '\u0E32..\u0E33' | '\u0E40..\u0E45' | '\u0E81..\u0E82' | '\u0E84' | '\u0E87..\u0E88' | '\u0E8A' | '\u0E8D' | '\u0E94..\u0E97' | '\u0E99..\u0E9F' | '\u0EA1..\u0EA3' | '\u0EA5' | '\u0EA7' | '\u0EAA..\u0EAB' | '\u0EAD..\u0EB0' | '\u0EB2..\u0EB3' | '\u0EBD' | '\u0EC0..\u0EC4' | '\u0EDC..\u0EDF' | '\u0F00' | '\u0F40..\u0F47' | '\u0F49..\u0F6C' | '\u0F88..\u0F8C' | '\u1000..\u102A' | '\u103F' | '\u1050..\u1055' | '\u105A..\u105D' | '\u1061' | '\u1065..\u1066' | '\u106E..\u1070' | '\u1075..\u1081' | '\u108E' | '\u10D0..\u10FA' | '\u10FD..\u1248' | '\u124A..\u124D' | '\u1250..\u1256' | '\u1258' | '\u125A..\u125D' | '\u1260..\u1288' | '\u128A..\u128D' | '\u1290..\u12B0' | '\u12B2..\u12B5' | '\u12B8..\u12BE' | '\u12C0' | '\u12C2..\u12C5' | '\u12C8..\u12D6' | '\u12D8..\u1310' | '\u1312..\u1315' | '\u1318..\u135A' | '\u1380..\u138F' | '\u13A0..\u13F4' | '\u1401..\u166C' | '\u166F..\u167F' | '\u1681..\u169A' | '\u16A0..\u16EA' | '\u1700..\u170C' | '\u170E..\u1711' | '\u1720..\u1731' | '\u1740..\u1751' | '\u1760..\u176C' | '\u176E..\u1770' | '\u1780..\u17B3' | '\u17DC' | '\u1820..\u1842' | '\u1844..\u1877' | '\u1880..\u18A8' | '\u18AA' | '\u18B0..\u18F5' | '\u1900..\u191C' | '\u1950..\u196D' | '\u1970..\u1974' | '\u1980..\u19AB' | '\u19C1..\u19C7' | '\u1A00..\u1A16' | '\u1A20..\u1A54' | '\u1B05..\u1B33' | '\u1B45..\u1B4B' | '\u1B83..\u1BA0' | '\u1BAE..\u1BAF' | '\u1BBA..\u1BE5' | '\u1C00..\u1C23' | '\u1C4D..\u1C4F' | '\u1C5A..\u1C77' | '\u1CE9..\u1CEC' | '\u1CEE..\u1CF1' | '\u1CF5..\u1CF6' | '\u2135..\u2138' | '\u2D30..\u2D67' | '\u2D80..\u2D96' | '\u2DA0..\u2DA6' | '\u2DA8..\u2DAE' | '\u2DB0..\u2DB6' | '\u2DB8..\u2DBE' | '\u2DC0..\u2DC6' | '\u2DC8..\u2DCE' | '\u2DD0..\u2DD6' | '\u2DD8..\u2DDE' | '\u3006' | '\u303C' | '\u3041..\u3096' | '\u309F' | '\u30A1..\u30FA' | '\u30FF' | '\u3105..\u312D' | '\u3131..\u318E' | '\u31A0..\u31BA' | '\u31F0..\u31FF' | '\u3400' | '\u4DB5' | '\u4E00' | '\u9FCC' | '\uA000..\uA014' | '\uA016..\uA48C' | '\uA4D0..\uA4F7' | '\uA500..\uA60B' | '\uA610..\uA61F' | '\uA62A..\uA62B' | '\uA66E' | '\uA6A0..\uA6E5' | '\uA7FB..\uA801' | '\uA803..\uA805' | '\uA807..\uA80A' | '\uA80C..\uA822' | '\uA840..\uA873' | '\uA882..\uA8B3' | '\uA8F2..\uA8F7' | '\uA8FB' | '\uA90A..\uA925' | '\uA930..\uA946' | '\uA960..\uA97C' | '\uA984..\uA9B2' | '\uAA00..\uAA28' | '\uAA40..\uAA42' | '\uAA44..\uAA4B' | '\uAA60..\uAA6F' | '\uAA71..\uAA76' | '\uAA7A' | '\uAA80..\uAAAF' | '\uAAB1' | '\uAAB5..\uAAB6' | '\uAAB9..\uAABD' | '\uAAC0' | '\uAAC2' | '\uAADB..\uAADC' | '\uAAE0..\uAAEA' | '\uAAF2' | '\uAB01..\uAB06' | '\uAB09..\uAB0E' | '\uAB11..\uAB16' | '\uAB20..\uAB26' | '\uAB28..\uAB2E' | '\uABC0..\uABE2' | '\uAC00' | '\uD7A3' | '\uD7B0..\uD7C6' | '\uD7CB..\uD7FB' | '\uF900..\uFA6D' | '\uFA70..\uFAD9' | '\uFB1D' | '\uFB1F..\uFB28' | '\uFB2A..\uFB36' | '\uFB38..\uFB3C' | '\uFB3E' | '\uFB40..\uFB41' | '\uFB43..\uFB44' | '\uFB46..\uFBB1' | '\uFBD3..\uFD3D' | '\uFD50..\uFD8F' | '\uFD92..\uFDC7' | '\uFDF0..\uFDFB' | '\uFE70..\uFE74' | '\uFE76..\uFEFC' | '\uFF66..\uFF6F' | '\uFF71..\uFF9D' | '\uFFA0..\uFFBE' | '\uFFC2..\uFFC7' | '\uFFCA..\uFFCF' | '\uFFD2..\uFFD7' | '\uFFDA..\uFFDC' | '\u10000..\u1000B' | '\u1000D..\u10026' | '\u10028..\u1003A' | '\u1003C..\u1003D' | '\u1003F..\u1004D' | '\u10050..\u1005D' | '\u10080..\u100FA' | '\u10280..\u1029C' | '\u102A0..\u102D0' | '\u10300..\u1031E' | '\u10330..\u10340' | '\u10342..\u10349' | '\u10380..\u1039D' | '\u103A0..\u103C3' | '\u103C8..\u103CF' | '\u10450..\u1049D' | '\u10800..\u10805' | '\u10808' | '\u1080A..\u10835' | '\u10837..\u10838' | '\u1083C' | '\u1083F..\u10855' | '\u10900..\u10915' | '\u10920..\u10939' | '\u10980..\u109B7' | '\u109BE..\u109BF' | '\u10A00' | '\u10A10..\u10A13' | '\u10A15..\u10A17' | '\u10A19..\u10A33' | '\u10A60..\u10A7C' | '\u10B00..\u10B35' | '\u10B40..\u10B55' | '\u10B60..\u10B72' | '\u10C00..\u10C48' | '\u11003..\u11037' | '\u11083..\u110AF' | '\u110D0..\u110E8' | '\u11103..\u11126' | '\u11183..\u111B2' | '\u111C1..\u111C4' | '\u11680..\u116AA' | '\u12000..\u1236E' | '\u13000..\u1342E' | '\u16800..\u16A38' | '\u16F00..\u16F44' | '\u16F50' | '\u1B000..\u1B001' | '\u1EE00..\u1EE03' | '\u1EE05..\u1EE1F' | '\u1EE21..\u1EE22' | '\u1EE24' | '\u1EE27' | '\u1EE29..\u1EE32' | '\u1EE34..\u1EE37' | '\u1EE39' | '\u1EE3B' | '\u1EE42' | '\u1EE47' | '\u1EE49' | '\u1EE4B' | '\u1EE4D..\u1EE4F' | '\u1EE51..\u1EE52' | '\u1EE54' | '\u1EE57' | '\u1EE59' | '\u1EE5B' | '\u1EE5D' | '\u1EE5F' | '\u1EE61..\u1EE62' | '\u1EE64' | '\u1EE67..\u1EE6A' | '\u1EE6C..\u1EE72' | '\u1EE74..\u1EE77' | '\u1EE79..\u1EE7C' | '\u1EE7E' | '\u1EE80..\u1EE89' | '\u1EE8B..\u1EE9B' | '\u1EEA1..\u1EEA3' | '\u1EEA5..\u1EEA9' | '\u1EEAB..\u1EEBB' | '\u20000' | '\u2A6D6' | '\u2A700' | '\u2B734' | '\u2B740' | '\u2B81D';
fragment unicode_lt : '\u01C5' | '\u01C8' | '\u01CB' | '\u01F2' | '\u1F88..\u1F8F' | '\u1F98..\u1F9F' | '\u1FA8..\u1FAF' | '\u1FBC' | '\u1FCC';
fragment unicode_lu : '\u0041..\u005A' | '\u00C0..\u00D6' | '\u00D8..\u00DE' | '\u0100' | '\u0102' | '\u0104' | '\u0106' | '\u0108' | '\u010A' | '\u010C' | '\u010E' | '\u0110' | '\u0112' | '\u0114' | '\u0116' | '\u0118' | '\u011A' | '\u011C' | '\u011E' | '\u0120' | '\u0122' | '\u0124' | '\u0126' | '\u0128' | '\u012A' | '\u012C' | '\u012E' | '\u0130' | '\u0132' | '\u0134' | '\u0136' | '\u0139' | '\u013B' | '\u013D' | '\u013F' | '\u0141' | '\u0143' | '\u0145' | '\u0147' | '\u014A' | '\u014C' | '\u014E' | '\u0150' | '\u0152' | '\u0154' | '\u0156' | '\u0158' | '\u015A' | '\u015C' | '\u015E' | '\u0160' | '\u0162' | '\u0164' | '\u0166' | '\u0168' | '\u016A' | '\u016C' | '\u016E' | '\u0170' | '\u0172' | '\u0174' | '\u0176' | '\u0178..\u0179' | '\u017B' | '\u017D' | '\u0181..\u0182' | '\u0184' | '\u0186..\u0187' | '\u0189..\u018B' | '\u018E..\u0191' | '\u0193..\u0194' | '\u0196..\u0198' | '\u019C..\u019D' | '\u019F..\u01A0' | '\u01A2' | '\u01A4' | '\u01A6..\u01A7' | '\u01A9' | '\u01AC' | '\u01AE..\u01AF' | '\u01B1..\u01B3' | '\u01B5' | '\u01B7..\u01B8' | '\u01BC' | '\u01C4' | '\u01C7' | '\u01CA' | '\u01CD' | '\u01CF' | '\u01D1' | '\u01D3' | '\u01D5' | '\u01D7' | '\u01D9' | '\u01DB' | '\u01DE' | '\u01E0' | '\u01E2' | '\u01E4' | '\u01E6' | '\u01E8' | '\u01EA' | '\u01EC' | '\u01EE' | '\u01F1' | '\u01F4' | '\u01F6..\u01F8' | '\u01FA' | '\u01FC' | '\u01FE' | '\u0200' | '\u0202' | '\u0204' | '\u0206' | '\u0208' | '\u020A' | '\u020C' | '\u020E' | '\u0210' | '\u0212' | '\u0214' | '\u0216' | '\u0218' | '\u021A' | '\u021C' | '\u021E' | '\u0220' | '\u0222' | '\u0224' | '\u0226' | '\u0228' | '\u022A' | '\u022C' | '\u022E' | '\u0230' | '\u0232' | '\u023A..\u023B' | '\u023D..\u023E' | '\u0241' | '\u0243..\u0246' | '\u0248' | '\u024A' | '\u024C' | '\u024E' | '\u0370' | '\u0372' | '\u0376' | '\u0386' | '\u0388..\u038A' | '\u038C' | '\u038E..\u038F' | '\u0391..\u03A1' | '\u03A3..\u03AB' | '\u03CF' | '\u03D2..\u03D4' | '\u03D8' | '\u03DA' | '\u03DC' | '\u03DE' | '\u03E0' | '\u03E2' | '\u03E4' | '\u03E6' | '\u03E8' | '\u03EA' | '\u03EC' | '\u03EE' | '\u03F4' | '\u03F7' | '\u03F9..\u03FA' | '\u03FD..\u042F' | '\u0460' | '\u0462' | '\u0464' | '\u0466' | '\u0468' | '\u046A' | '\u046C' | '\u046E' | '\u0470' | '\u0472' | '\u0474' | '\u0476' | '\u0478' | '\u047A' | '\u047C' | '\u047E' | '\u0480' | '\u048A' | '\u048C' | '\u048E' | '\u0490' | '\u0492' | '\u0494' | '\u0496' | '\u0498' | '\u049A' | '\u049C' | '\u049E' | '\u04A0' | '\u04A2' | '\u04A4' | '\u04A6' | '\u04A8' | '\u04AA' | '\u04AC' | '\u04AE' | '\u04B0' | '\u04B2' | '\u04B4' | '\u04B6' | '\u04B8' | '\u04BA' | '\u04BC' | '\u04BE' | '\u04C0..\u04C1' | '\u04C3' | '\u04C5' | '\u04C7' | '\u04C9' | '\u04CB' | '\u04CD' | '\u04D0' | '\u04D2' | '\u04D4' | '\u04D6' | '\u04D8' | '\u04DA' | '\u04DC' | '\u04DE' | '\u04E0' | '\u04E2' | '\u04E4' | '\u04E6' | '\u04E8' | '\u04EA' | '\u04EC' | '\u04EE' | '\u04F0' | '\u04F2' | '\u04F4' | '\u04F6' | '\u04F8' | '\u04FA' | '\u04FC' | '\u04FE' | '\u0500' | '\u0502' | '\u0504' | '\u0506' | '\u0508' | '\u050A' | '\u050C' | '\u050E' | '\u0510' | '\u0512' | '\u0514' | '\u0516' | '\u0518' | '\u051A' | '\u051C' | '\u051E' | '\u0520' | '\u0522' | '\u0524' | '\u0526' | '\u0531..\u0556' | '\u10A0..\u10C5' | '\u10C7' | '\u10CD' | '\u1E00' | '\u1E02' | '\u1E04' | '\u1E06' | '\u1E08' | '\u1E0A' | '\u1E0C' | '\u1E0E' | '\u1E10' | '\u1E12' | '\u1E14' | '\u1E16' | '\u1E18' | '\u1E1A' | '\u1E1C' | '\u1E1E' | '\u1E20' | '\u1E22' | '\u1E24' | '\u1E26' | '\u1E28' | '\u1E2A' | '\u1E2C' | '\u1E2E' | '\u1E30' | '\u1E32' | '\u1E34' | '\u1E36' | '\u1E38' | '\u1E3A' | '\u1E3C' | '\u1E3E' | '\u1E40' | '\u1E42' | '\u1E44' | '\u1E46' | '\u1E48' | '\u1E4A' | '\u1E4C' | '\u1E4E' | '\u1E50' | '\u1E52' | '\u1E54' | '\u1E56' | '\u1E58' | '\u1E5A' | '\u1E5C' | '\u1E5E' | '\u1E60' | '\u1E62' | '\u1E64' | '\u1E66' | '\u1E68' | '\u1E6A' | '\u1E6C' | '\u1E6E' | '\u1E70' | '\u1E72' | '\u1E74' | '\u1E76' | '\u1E78' | '\u1E7A' | '\u1E7C' | '\u1E7E' | '\u1E80' | '\u1E82' | '\u1E84' | '\u1E86' | '\u1E88' | '\u1E8A' | '\u1E8C' | '\u1E8E' | '\u1E90' | '\u1E92' | '\u1E94' | '\u1E9E' | '\u1EA0' | '\u1EA2' | '\u1EA4' | '\u1EA6' | '\u1EA8' | '\u1EAA' | '\u1EAC' | '\u1EAE' | '\u1EB0' | '\u1EB2' | '\u1EB4' | '\u1EB6' | '\u1EB8' | '\u1EBA' | '\u1EBC' | '\u1EBE' | '\u1EC0' | '\u1EC2' | '\u1EC4' | '\u1EC6' | '\u1EC8' | '\u1ECA' | '\u1ECC' | '\u1ECE' | '\u1ED0' | '\u1ED2' | '\u1ED4' | '\u1ED6' | '\u1ED8' | '\u1EDA' | '\u1EDC' | '\u1EDE' | '\u1EE0' | '\u1EE2' | '\u1EE4' | '\u1EE6' | '\u1EE8' | '\u1EEA' | '\u1EEC' | '\u1EEE' | '\u1EF0' | '\u1EF2' | '\u1EF4' | '\u1EF6' | '\u1EF8' | '\u1EFA' | '\u1EFC' | '\u1EFE' | '\u1F08..\u1F0F' | '\u1F18..\u1F1D' | '\u1F28..\u1F2F' | '\u1F38..\u1F3F' | '\u1F48..\u1F4D' | '\u1F59' | '\u1F5B' | '\u1F5D' | '\u1F5F' | '\u1F68..\u1F6F' | '\u1FB8..\u1FBB' | '\u1FC8..\u1FCB' | '\u1FD8..\u1FDB' | '\u1FE8..\u1FEC' | '\u1FF8..\u1FFB' | '\u2102' | '\u2107' | '\u210B..\u210D' | '\u2110..\u2112' | '\u2115' | '\u2119..\u211D' | '\u2124' | '\u2126' | '\u2128' | '\u212A..\u212D' | '\u2130..\u2133' | '\u213E..\u213F' | '\u2145' | '\u2183' | '\u2C00..\u2C2E' | '\u2C60' | '\u2C62..\u2C64' | '\u2C67' | '\u2C69' | '\u2C6B' | '\u2C6D..\u2C70' | '\u2C72' | '\u2C75' | '\u2C7E..\u2C80' | '\u2C82' | '\u2C84' | '\u2C86' | '\u2C88' | '\u2C8A' | '\u2C8C' | '\u2C8E' | '\u2C90' | '\u2C92' | '\u2C94' | '\u2C96' | '\u2C98' | '\u2C9A' | '\u2C9C' | '\u2C9E' | '\u2CA0' | '\u2CA2' | '\u2CA4' | '\u2CA6' | '\u2CA8' | '\u2CAA' | '\u2CAC' | '\u2CAE' | '\u2CB0' | '\u2CB2' | '\u2CB4' | '\u2CB6' | '\u2CB8' | '\u2CBA' | '\u2CBC' | '\u2CBE' | '\u2CC0' | '\u2CC2' | '\u2CC4' | '\u2CC6' | '\u2CC8' | '\u2CCA' | '\u2CCC' | '\u2CCE' | '\u2CD0' | '\u2CD2' | '\u2CD4' | '\u2CD6' | '\u2CD8' | '\u2CDA' | '\u2CDC' | '\u2CDE' | '\u2CE0' | '\u2CE2' | '\u2CEB' | '\u2CED' | '\u2CF2' | '\uA640' | '\uA642' | '\uA644' | '\uA646' | '\uA648' | '\uA64A' | '\uA64C' | '\uA64E' | '\uA650' | '\uA652' | '\uA654' | '\uA656' | '\uA658' | '\uA65A' | '\uA65C' | '\uA65E' | '\uA660' | '\uA662' | '\uA664' | '\uA666' | '\uA668' | '\uA66A' | '\uA66C' | '\uA680' | '\uA682' | '\uA684' | '\uA686' | '\uA688' | '\uA68A' | '\uA68C' | '\uA68E' | '\uA690' | '\uA692' | '\uA694' | '\uA696' | '\uA722' | '\uA724' | '\uA726' | '\uA728' | '\uA72A' | '\uA72C' | '\uA72E' | '\uA732' | '\uA734' | '\uA736' | '\uA738' | '\uA73A' | '\uA73C' | '\uA73E' | '\uA740' | '\uA742' | '\uA744' | '\uA746' | '\uA748' | '\uA74A' | '\uA74C' | '\uA74E' | '\uA750' | '\uA752' | '\uA754' | '\uA756' | '\uA758' | '\uA75A' | '\uA75C' | '\uA75E' | '\uA760' | '\uA762' | '\uA764' | '\uA766' | '\uA768' | '\uA76A' | '\uA76C' | '\uA76E' | '\uA779' | '\uA77B' | '\uA77D..\uA77E' | '\uA780' | '\uA782' | '\uA784' | '\uA786' | '\uA78B' | '\uA78D' | '\uA790' | '\uA792' | '\uA7A0' | '\uA7A2' | '\uA7A4' | '\uA7A6' | '\uA7A8' | '\uA7AA' | '\uFF21..\uFF3A' | '\u10400..\u10427' | '\u1D400..\u1D419' | '\u1D434..\u1D44D' | '\u1D468..\u1D481' | '\u1D49C' | '\u1D49E..\u1D49F' | '\u1D4A2' | '\u1D4A5..\u1D4A6' | '\u1D4A9..\u1D4AC' | '\u1D4AE..\u1D4B5' | '\u1D4D0..\u1D4E9' | '\u1D504..\u1D505' | '\u1D507..\u1D50A' | '\u1D50D..\u1D514' | '\u1D516..\u1D51C' | '\u1D538..\u1D539' | '\u1D53B..\u1D53E' | '\u1D540..\u1D544' | '\u1D546' | '\u1D54A..\u1D550' | '\u1D56C..\u1D585' | '\u1D5A0..\u1D5B9' | '\u1D5D4..\u1D5ED' | '\u1D608..\u1D621' | '\u1D63C..\u1D655' | '\u1D670..\u1D689' | '\u1D6A8..\u1D6C0' | '\u1D6E2..\u1D6FA' | '\u1D71C..\u1D734' | '\u1D756..\u1D76E' | '\u1D790..\u1D7A8';
fragment unicode_mc : '\u0903' | '\u093B' | '\u093E..\u0940' | '\u0949..\u094C' | '\u094E..\u094F' | '\u0982..\u0983' | '\u09BE..\u09C0' | '\u09C7..\u09C8' | '\u09CB..\u09CC' | '\u09D7' | '\u0A03' | '\u0A3E..\u0A40' | '\u0A83' | '\u0ABE..\u0AC0' | '\u0AC9' | '\u0ACB..\u0ACC' | '\u0B02..\u0B03' | '\u0B3E' | '\u0B40' | '\u0B47..\u0B48' | '\u0B4B..\u0B4C' | '\u0B57' | '\u0BBE..\u0BBF' | '\u0BC1..\u0BC2' | '\u0BC6..\u0BC8' | '\u0BCA..\u0BCC' | '\u0BD7' | '\u0C01..\u0C03' | '\u0C41..\u0C44' | '\u0C82..\u0C83' | '\u0CBE' | '\u0CC0..\u0CC4' | '\u0CC7..\u0CC8' | '\u0CCA..\u0CCB' | '\u0CD5..\u0CD6' | '\u0D02..\u0D03' | '\u0D3E..\u0D40' | '\u0D46..\u0D48' | '\u0D4A..\u0D4C' | '\u0D57' | '\u0D82..\u0D83' | '\u0DCF..\u0DD1' | '\u0DD8..\u0DDF' | '\u0DF2..\u0DF3' | '\u0F3E..\u0F3F' | '\u0F7F' | '\u102B..\u102C' | '\u1031' | '\u1038' | '\u103B..\u103C' | '\u1056..\u1057' | '\u1062..\u1064' | '\u1067..\u106D' | '\u1083..\u1084' | '\u1087..\u108C' | '\u108F' | '\u109A..\u109C' | '\u17B6' | '\u17BE..\u17C5' | '\u17C7..\u17C8' | '\u1923..\u1926' | '\u1929..\u192B' | '\u1930..\u1931' | '\u1933..\u1938' | '\u19B0..\u19C0' | '\u19C8..\u19C9' | '\u1A19..\u1A1B' | '\u1A55' | '\u1A57' | '\u1A61' | '\u1A63..\u1A64' | '\u1A6D..\u1A72' | '\u1B04' | '\u1B35' | '\u1B3B' | '\u1B3D..\u1B41' | '\u1B43..\u1B44' | '\u1B82' | '\u1BA1' | '\u1BA6..\u1BA7' | '\u1BAA' | '\u1BAC..\u1BAD' | '\u1BE7' | '\u1BEA..\u1BEC' | '\u1BEE' | '\u1BF2..\u1BF3' | '\u1C24..\u1C2B' | '\u1C34..\u1C35' | '\u1CE1' | '\u1CF2..\u1CF3' | '\u302E..\u302F' | '\uA823..\uA824' | '\uA827' | '\uA880..\uA881' | '\uA8B4..\uA8C3' | '\uA952..\uA953' | '\uA983' | '\uA9B4..\uA9B5' | '\uA9BA..\uA9BB' | '\uA9BD..\uA9C0' | '\uAA2F..\uAA30' | '\uAA33..\uAA34' | '\uAA4D' | '\uAA7B' | '\uAAEB' | '\uAAEE..\uAAEF' | '\uAAF5' | '\uABE3..\uABE4' | '\uABE6..\uABE7' | '\uABE9..\uABEA' | '\uABEC' | '\u11000' | '\u11002' | '\u11082' | '\u110B0..\u110B2' | '\u110B7..\u110B8' | '\u1112C' | '\u11182' | '\u111B3..\u111B5' | '\u111BF..\u111C0' | '\u116AC' | '\u116AE..\u116AF' | '\u116B6' | '\u16F51..\u16F7E' | '\u1D165..\u1D166';
fragment unicode_me : '\u0488..\u0489' | '\u20DD..\u20E0' | '\u20E2..\u20E4';
fragment unicode_mn : '\u0300..\u036F' | '\u0483..\u0487' | '\u0591..\u05BD' | '\u05BF' | '\u05C1..\u05C2' | '\u05C4..\u05C5' | '\u05C7' | '\u0610..\u061A' | '\u064B..\u065F' | '\u0670' | '\u06D6..\u06DC' | '\u06DF..\u06E4' | '\u06E7..\u06E8' | '\u06EA..\u06ED' | '\u0711' | '\u0730..\u074A' | '\u07A6..\u07B0' | '\u07EB..\u07F3' | '\u0816..\u0819' | '\u081B..\u0823' | '\u0825..\u0827' | '\u0829..\u082D' | '\u0859..\u085B' | '\u08E4..\u08FE' | '\u0900..\u0902' | '\u093A' | '\u093C' | '\u0941..\u0948' | '\u094D' | '\u0951..\u0957' | '\u0962..\u0963' | '\u0981' | '\u09BC' | '\u09C1..\u09C4' | '\u09CD' | '\u09E2..\u09E3' | '\u0A01..\u0A02' | '\u0A3C' | '\u0A41..\u0A42' | '\u0A47..\u0A48' | '\u0A4B..\u0A4D' | '\u0A51' | '\u0A70..\u0A71' | '\u0A75' | '\u0A81..\u0A82' | '\u0ABC' | '\u0AC1..\u0AC5' | '\u0AC7..\u0AC8' | '\u0ACD' | '\u0AE2..\u0AE3' | '\u0B01' | '\u0B3C' | '\u0B3F' | '\u0B41..\u0B44' | '\u0B4D' | '\u0B56' | '\u0B62..\u0B63' | '\u0B82' | '\u0BC0' | '\u0BCD' | '\u0C3E..\u0C40' | '\u0C46..\u0C48' | '\u0C4A..\u0C4D' | '\u0C55..\u0C56' | '\u0C62..\u0C63' | '\u0CBC' | '\u0CBF' | '\u0CC6' | '\u0CCC..\u0CCD' | '\u0CE2..\u0CE3' | '\u0D41..\u0D44' | '\u0D4D' | '\u0D62..\u0D63' | '\u0DCA' | '\u0DD2..\u0DD4' | '\u0DD6' | '\u0E31' | '\u0E34..\u0E3A' | '\u0E47..\u0E4E' | '\u0EB1' | '\u0EB4..\u0EB9' | '\u0EBB..\u0EBC' | '\u0EC8..\u0ECD' | '\u0F18..\u0F19' | '\u0F35' | '\u0F37' | '\u0F39' | '\u0F71..\u0F7E' | '\u0F80..\u0F84' | '\u0F86..\u0F87' | '\u0F8D..\u0F97' | '\u0F99..\u0FBC' | '\u0FC6' | '\u102D..\u1030' | '\u1032..\u1037' | '\u1039..\u103A' | '\u103D..\u103E' | '\u1058..\u1059' | '\u105E..\u1060' | '\u1071..\u1074' | '\u1082' | '\u1085..\u1086' | '\u108D' | '\u109D' | '\u135D..\u135F' | '\u1712..\u1714' | '\u1732..\u1734' | '\u1752..\u1753' | '\u1772..\u1773' | '\u17B4..\u17B5' | '\u17B7..\u17BD' | '\u17C6' | '\u17C9..\u17D3' | '\u17DD' | '\u180B..\u180D' | '\u18A9' | '\u1920..\u1922' | '\u1927..\u1928' | '\u1932' | '\u1939..\u193B' | '\u1A17..\u1A18' | '\u1A56' | '\u1A58..\u1A5E' | '\u1A60' | '\u1A62' | '\u1A65..\u1A6C' | '\u1A73..\u1A7C' | '\u1A7F' | '\u1B00..\u1B03' | '\u1B34' | '\u1B36..\u1B3A' | '\u1B3C' | '\u1B42' | '\u1B6B..\u1B73' | '\u1B80..\u1B81' | '\u1BA2..\u1BA5' | '\u1BA8..\u1BA9' | '\u1BAB' | '\u1BE6' | '\u1BE8..\u1BE9' | '\u1BED' | '\u1BEF..\u1BF1' | '\u1C2C..\u1C33' | '\u1C36..\u1C37' | '\u1CD0..\u1CD2' | '\u1CD4..\u1CE0' | '\u1CE2..\u1CE8' | '\u1CED' | '\u1CF4' | '\u1DC0..\u1DE6' | '\u1DFC..\u1DFF' | '\u20D0..\u20DC' | '\u20E1' | '\u20E5..\u20F0' | '\u2CEF..\u2CF1' | '\u2D7F' | '\u2DE0..\u2DFF' | '\u302A..\u302D' | '\u3099..\u309A' | '\uA66F' | '\uA674..\uA67D' | '\uA69F' | '\uA6F0..\uA6F1' | '\uA802' | '\uA806' | '\uA80B' | '\uA825..\uA826' | '\uA8C4' | '\uA8E0..\uA8F1' | '\uA926..\uA92D' | '\uA947..\uA951' | '\uA980..\uA982' | '\uA9B3' | '\uA9B6..\uA9B9' | '\uA9BC' | '\uAA29..\uAA2E' | '\uAA31..\uAA32' | '\uAA35..\uAA36' | '\uAA43' | '\uAA4C' | '\uAAB0' | '\uAAB2..\uAAB4' | '\uAAB7..\uAAB8' | '\uAABE..\uAABF' | '\uAAC1' | '\uAAEC..\uAAED' | '\uAAF6' | '\uABE5' | '\uABE8' | '\uABED' | '\uFB1E' | '\uFE00..\uFE0F' | '\uFE20..\uFE26' | '\u101FD' | '\u10A01..\u10A03' | '\u10A05..\u10A06' | '\u10A0C..\u10A0F' | '\u10A38..\u10A3A' | '\u10A3F' | '\u11001' | '\u11038..\u11046' | '\u11080..\u11081' | '\u110B3..\u110B6' | '\u110B9..\u110BA' | '\u11100..\u11102' | '\u11127..\u1112B' | '\u1112D..\u11134' | '\u11180..\u11181' | '\u111B6..\u111BE' | '\u116AB' | '\u116AD' | '\u116B0..\u116B5' | '\u116B7' | '\u16F8F..\u16F92' | '\u1D167..\u1D169' | '\u1D17B..\u1D182' | '\u1D185..\u1D18B' | '\u1D1AA..\u1D1AD' | '\u1D242..\u1D244';
fragment unicode_nd : '\u0030..\u0039' | '\u0660..\u0669' | '\u06F0..\u06F9' | '\u07C0..\u07C9' | '\u0966..\u096F' | '\u09E6..\u09EF' | '\u0A66..\u0A6F' | '\u0AE6..\u0AEF' | '\u0B66..\u0B6F' | '\u0BE6..\u0BEF' | '\u0C66..\u0C6F' | '\u0CE6..\u0CEF' | '\u0D66..\u0D6F' | '\u0E50..\u0E59' | '\u0ED0..\u0ED9' | '\u0F20..\u0F29' | '\u1040..\u1049' | '\u1090..\u1099' | '\u17E0..\u17E9' | '\u1810..\u1819' | '\u1946..\u194F' | '\u19D0..\u19D9' | '\u1A80..\u1A89' | '\u1A90..\u1A99' | '\u1B50..\u1B59' | '\u1BB0..\u1BB9' | '\u1C40..\u1C49' | '\u1C50..\u1C59' | '\uA620..\uA629' | '\uA8D0..\uA8D9' | '\uA900..\uA909' | '\uA9D0..\uA9D9' | '\uAA50..\uAA59' | '\uABF0..\uABF9' | '\uFF10..\uFF19' | '\u104A0..\u104A9' | '\u11066..\u1106F' | '\u110F0..\u110F9' | '\u11136..\u1113F' | '\u111D0..\u111D9' | '\u116C0..\u116C9';
fragment unicode_nl : '\u16EE..\u16F0' | '\u2160..\u2182' | '\u2185..\u2188' | '\u3007' | '\u3021..\u3029' | '\u3038..\u303A' | '\uA6E6..\uA6EF' | '\u10140..\u10174' | '\u10341' | '\u1034A' | '\u103D1..\u103D5';
fragment unicode_no : '\u00B2..\u00B3' | '\u00B9' | '\u00BC..\u00BE' | '\u09F4..\u09F9' | '\u0B72..\u0B77' | '\u0BF0..\u0BF2' | '\u0C78..\u0C7E' | '\u0D70..\u0D75' | '\u0F2A..\u0F33' | '\u1369..\u137C' | '\u17F0..\u17F9' | '\u19DA' | '\u2070' | '\u2074..\u2079' | '\u2080..\u2089' | '\u2150..\u215F' | '\u2189' | '\u2460..\u249B' | '\u24EA..\u24FF' | '\u2776..\u2793' | '\u2CFD' | '\u3192..\u3195' | '\u3220..\u3229' | '\u3248..\u324F' | '\u3251..\u325F' | '\u3280..\u3289' | '\u32B1..\u32BF' | '\uA830..\uA835' | '\u10107..\u10133' | '\u10175..\u10178' | '\u1018A' | '\u10320..\u10323' | '\u10858..\u1085F' | '\u10916..\u1091B' | '\u10A40..\u10A47' | '\u10A7D..\u10A7E' | '\u10B58..\u10B5F' | '\u10B78..\u10B7F' | '\u10E60..\u10E7E' | '\u11052..\u11065' | '\u1D360..\u1D371';
fragment unicode_pc : '\u005F' | '\u203F..\u2040' | '\u2054' | '\uFE33..\uFE34' | '\uFE4D..\uFE4F';
fragment unicode_pd : '\u002D' | '\u058A' | '\u05BE' | '\u1400' | '\u1806' | '\u2010..\u2015' | '\u2E17' | '\u2E1A' | '\u2E3A..\u2E3B' | '\u301C' | '\u3030' | '\u30A0' | '\uFE31..\uFE32' | '\uFE58' | '\uFE63';
fragment unicode_pe : '\u0029' | '\u005D' | '\u007D' | '\u0F3B' | '\u0F3D' | '\u169C' | '\u2046' | '\u207E' | '\u208E' | '\u232A' | '\u2769' | '\u276B' | '\u276D' | '\u276F' | '\u2771' | '\u2773' | '\u2775' | '\u27C6' | '\u27E7' | '\u27E9' | '\u27EB' | '\u27ED' | '\u27EF' | '\u2984' | '\u2986' | '\u2988' | '\u298A' | '\u298C' | '\u298E' | '\u2990' | '\u2992' | '\u2994' | '\u2996' | '\u2998' | '\u29D9' | '\u29DB' | '\u29FD' | '\u2E23' | '\u2E25' | '\u2E27' | '\u2E29' | '\u3009' | '\u300B' | '\u300D' | '\u300F' | '\u3011' | '\u3015' | '\u3017' | '\u3019' | '\u301B' | '\u301E..\u301F' | '\uFD3F' | '\uFE18' | '\uFE36' | '\uFE38' | '\uFE3A' | '\uFE3C' | '\uFE3E' | '\uFE40' | '\uFE42' | '\uFE44' | '\uFE48' | '\uFE5A' | '\uFE5C' | '\uFE5E' | '\uFF09' | '\uFF3D' | '\uFF5D' | '\uFF60';
fragment unicode_pf : '\u00BB' | '\u2019' | '\u201D' | '\u203A' | '\u2E03' | '\u2E05' | '\u2E0A' | '\u2E0D' | '\u2E1D';
fragment unicode_pi : '\u00AB' | '\u2018' | '\u201B..\u201C' | '\u201F' | '\u2039' | '\u2E02' | '\u2E04' | '\u2E09' | '\u2E0C' | '\u2E1C';
fragment unicode_po : '\u0021..\u0023' | '\u0025..\u0027' | '\u002A' | '\u002C' | '\u002E..\u002F' | '\u003A..\u003B' | '\u003F..\u0040' | '\u005C' | '\u00A1' | '\u00A7' | '\u00B6..\u00B7' | '\u00BF' | '\u037E' | '\u0387' | '\u055A..\u055F' | '\u0589' | '\u05C0' | '\u05C3' | '\u05C6' | '\u05F3..\u05F4' | '\u0609..\u060A' | '\u060C..\u060D' | '\u061B' | '\u061E..\u061F' | '\u066A..\u066D' | '\u06D4' | '\u0700..\u070D' | '\u07F7..\u07F9' | '\u0830..\u083E' | '\u085E' | '\u0964..\u0965' | '\u0970' | '\u0AF0' | '\u0DF4' | '\u0E4F' | '\u0E5A..\u0E5B' | '\u0F04..\u0F12' | '\u0F14' | '\u0F85' | '\u0FD0..\u0FD4' | '\u0FD9..\u0FDA' | '\u104A..\u104F' | '\u10FB' | '\u1360..\u1368' | '\u166D..\u166E' | '\u16EB..\u16ED' | '\u1735..\u1736' | '\u17D4..\u17D6' | '\u17D8..\u17DA' | '\u1800..\u1805' | '\u1807..\u180A' | '\u1944..\u1945' | '\u1A1E..\u1A1F' | '\u1AA0..\u1AA6' | '\u1AA8..\u1AAD' | '\u1B5A..\u1B60' | '\u1BFC..\u1BFF' | '\u1C3B..\u1C3F' | '\u1C7E..\u1C7F' | '\u1CC0..\u1CC7' | '\u1CD3' | '\u2016..\u2017' | '\u2020..\u2027' | '\u2030..\u2038' | '\u203B..\u203E' | '\u2041..\u2043' | '\u2047..\u2051' | '\u2053' | '\u2055..\u205E' | '\u2CF9..\u2CFC' | '\u2CFE..\u2CFF' | '\u2D70' | '\u2E00..\u2E01' | '\u2E06..\u2E08' | '\u2E0B' | '\u2E0E..\u2E16' | '\u2E18..\u2E19' | '\u2E1B' | '\u2E1E..\u2E1F' | '\u2E2A..\u2E2E' | '\u2E30..\u2E39' | '\u3001..\u3003' | '\u303D' | '\u30FB' | '\uA4FE..\uA4FF' | '\uA60D..\uA60F' | '\uA673' | '\uA67E' | '\uA6F2..\uA6F7' | '\uA874..\uA877' | '\uA8CE..\uA8CF' | '\uA8F8..\uA8FA' | '\uA92E..\uA92F' | '\uA95F' | '\uA9C1..\uA9CD' | '\uA9DE..\uA9DF' | '\uAA5C..\uAA5F' | '\uAADE..\uAADF' | '\uAAF0..\uAAF1' | '\uABEB' | '\uFE10..\uFE16' | '\uFE19' | '\uFE30' | '\uFE45..\uFE46' | '\uFE49..\uFE4C' | '\uFE50..\uFE52' | '\uFE54..\uFE57' | '\uFE5F..\uFE61' | '\uFE68' | '\uFE6A..\uFE6B' | '\uFF01..\uFF03' | '\uFF05..\uFF07' | '\uFF0A' | '\uFF0C' | '\uFF0E..\uFF0F' | '\uFF1A..\uFF1B' | '\uFF1F..\uFF20' | '\uFF3C' | '\uFF61' | '\uFF64..\uFF65' | '\u10100..\u10102' | '\u1039F' | '\u103D0' | '\u10857' | '\u1091F' | '\u1093F' | '\u10A50..\u10A58' | '\u10A7F' | '\u10B39..\u10B3F' | '\u11047..\u1104D' | '\u110BB..\u110BC' | '\u110BE..\u110C1' | '\u11140..\u11143' | '\u111C5..\u111C8';
fragment unicode_ps : '\u0028' | '\u005B' | '\u007B' | '\u0F3A' | '\u0F3C' | '\u169B' | '\u201A' | '\u201E' | '\u2045' | '\u207D' | '\u208D' | '\u2329' | '\u2768' | '\u276A' | '\u276C' | '\u276E' | '\u2770' | '\u2772' | '\u2774' | '\u27C5' | '\u27E6' | '\u27E8' | '\u27EA' | '\u27EC' | '\u27EE' | '\u2983' | '\u2985' | '\u2987' | '\u2989' | '\u298B' | '\u298D' | '\u298F' | '\u2991' | '\u2993' | '\u2995' | '\u2997' | '\u29D8' | '\u29DA' | '\u29FC' | '\u2E22' | '\u2E24' | '\u2E26' | '\u2E28' | '\u3008' | '\u300A' | '\u300C' | '\u300E' | '\u3010' | '\u3014' | '\u3016' | '\u3018' | '\u301A' | '\u301D' | '\uFD3E' | '\uFE17' | '\uFE35' | '\uFE37' | '\uFE39' | '\uFE3B' | '\uFE3D' | '\uFE3F' | '\uFE41' | '\uFE43' | '\uFE47' | '\uFE59' | '\uFE5B' | '\uFE5D' | '\uFF08' | '\uFF3B' | '\uFF5B' | '\uFF5F';
fragment unicode_sc : '\u0024' | '\u00A2..\u00A5' | '\u058F' | '\u060B' | '\u09F2..\u09F3' | '\u09FB' | '\u0AF1' | '\u0BF9' | '\u0E3F' | '\u17DB' | '\u20A0..\u20B9' | '\uA838' | '\uFDFC' | '\uFE69' | '\uFF04' | '\uFFE0..\uFFE1';
fragment unicode_sk : '\u005E' | '\u0060' | '\u00A8' | '\u00AF' | '\u00B4' | '\u00B8' | '\u02C2..\u02C5' | '\u02D2..\u02DF' | '\u02E5..\u02EB' | '\u02ED' | '\u02EF..\u02FF' | '\u0375' | '\u0384..\u0385' | '\u1FBD' | '\u1FBF..\u1FC1' | '\u1FCD..\u1FCF' | '\u1FDD..\u1FDF' | '\u1FED..\u1FEF' | '\u1FFD..\u1FFE' | '\u309B..\u309C' | '\uA700..\uA716' | '\uA720..\uA721' | '\uA789..\uA78A' | '\uFBB2..\uFBC1' | '\uFF3E' | '\uFF40';
fragment unicode_sm : '\u002B' | '\u003C..\u003E' | '\u007C' | '\u007E' | '\u00AC' | '\u00B1' | '\u00D7' | '\u00F7' | '\u03F6' | '\u0606..\u0608' | '\u2044' | '\u2052' | '\u207A..\u207C' | '\u208A..\u208C' | '\u2118' | '\u2140..\u2144' | '\u214B' | '\u2190..\u2194' | '\u219A..\u219B' | '\u21A0' | '\u21A3' | '\u21A6' | '\u21AE' | '\u21CE..\u21CF' | '\u21D2' | '\u21D4' | '\u21F4..\u22FF' | '\u2308..\u230B' | '\u2320..\u2321' | '\u237C' | '\u239B..\u23B3' | '\u23DC..\u23E1' | '\u25B7' | '\u25C1' | '\u25F8..\u25FF' | '\u266F' | '\u27C0..\u27C4' | '\u27C7..\u27E5' | '\u27F0..\u27FF' | '\u2900..\u2982' | '\u2999..\u29D7' | '\u29DC..\u29FB' | '\u29FE..\u2AFF' | '\u2B30..\u2B44' | '\u2B47..\u2B4C' | '\uFB29' | '\uFE62' | '\uFE64..\uFE66' | '\uFF0B' | '\uFF1C..\uFF1E' | '\uFF5C' | '\uFF5E' | '\uFFE2' | '\uFFE9..\uFFEC' | '\u1D6C1' | '\u1D6DB' | '\u1D6FB' | '\u1D715' | '\u1D735' | '\u1D74F' | '\u1D76F' | '\u1D789' | '\u1D7A9' | '\u1D7C3';
fragment unicode_so : '\u00A6' | '\u00A9' | '\u00AE' | '\u00B0' | '\u0482' | '\u060E..\u060F' | '\u06DE' | '\u06E9' | '\u06FD..\u06FE' | '\u07F6' | '\u09FA' | '\u0B70' | '\u0BF3..\u0BF8' | '\u0BFA' | '\u0C7F' | '\u0D79' | '\u0F01..\u0F03' | '\u0F13' | '\u0F15..\u0F17' | '\u0F1A..\u0F1F' | '\u0F34' | '\u0F36' | '\u0F38' | '\u0FBE..\u0FC5' | '\u0FC7..\u0FCC' | '\u0FCE..\u0FCF' | '\u0FD5..\u0FD8' | '\u109E..\u109F' | '\u1390..\u1399' | '\u1940' | '\u19DE..\u19FF' | '\u1B61..\u1B6A' | '\u1B74..\u1B7C' | '\u2100..\u2101' | '\u2103..\u2106' | '\u2108..\u2109' | '\u2114' | '\u2116..\u2117' | '\u211E..\u2123' | '\u2125' | '\u2127' | '\u2129' | '\u212E' | '\u213A..\u213B' | '\u214A' | '\u214C..\u214D' | '\u214F' | '\u2195..\u2199' | '\u219C..\u219F' | '\u21A1..\u21A2' | '\u21A4..\u21A5' | '\u21A7..\u21AD' | '\u21AF..\u21CD' | '\u21D0..\u21D1' | '\u21D3' | '\u21D5..\u21F3' | '\u2300..\u2307' | '\u230C..\u231F' | '\u2322..\u2328' | '\u232B..\u237B' | '\u237D..\u239A' | '\u23B4..\u23DB' | '\u23E2..\u23F3' | '\u2400..\u2426' | '\u2440..\u244A' | '\u249C..\u24E9' | '\u2500..\u25B6' | '\u25B8..\u25C0' | '\u25C2..\u25F7' | '\u2600..\u266E' | '\u2670..\u26FF' | '\u2701..\u2767' | '\u2794..\u27BF' | '\u2800..\u28FF' | '\u2B00..\u2B2F' | '\u2B45..\u2B46' | '\u2B50..\u2B59' | '\u2CE5..\u2CEA' | '\u2E80..\u2E99' | '\u2E9B..\u2EF3' | '\u2F00..\u2FD5' | '\u2FF0..\u2FFB' | '\u3004' | '\u3012..\u3013' | '\u3020' | '\u3036..\u3037' | '\u303E..\u303F' | '\u3190..\u3191' | '\u3196..\u319F' | '\u31C0..\u31E3' | '\u3200..\u321E' | '\u322A..\u3247' | '\u3250' | '\u3260..\u327F' | '\u328A..\u32B0' | '\u32C0..\u32FE' | '\u3300..\u33FF' | '\u4DC0..\u4DFF' | '\uA490..\uA4C6' | '\uA828..\uA82B' | '\uA836..\uA837' | '\uA839' | '\uAA77..\uAA79' | '\uFDFD' | '\uFFE4' | '\uFFE8' | '\uFFED..\uFFEE' | '\uFFFC..\uFFFD' | '\u10137..\u1013F' | '\u10179..\u10189' | '\u10190..\u1019B' | '\u101D0..\u101FC' | '\u1D000..\u1D0F5' | '\u1D100..\u1D126' | '\u1D129..\u1D164' | '\u1D16A..\u1D16C' | '\u1D183..\u1D184' | '\u1D18C..\u1D1A9' | '\u1D1AE..\u1D1DD' | '\u1D200..\u1D241' | '\u1D245' | '\u1D300..\u1D356' | '\u1F000..\u1F02B' | '\u1F030..\u1F093' | '\u1F0A0..\u1F0AE' | '\u1F0B1..\u1F0BE' | '\u1F0C1..\u1F0CF' | '\u1F0D1..\u1F0DF' | '\u1F110..\u1F12E' | '\u1F130..\u1F16B' | '\u1F170..\u1F19A' | '\u1F1E6..\u1F202' | '\u1F210..\u1F23A' | '\u1F240..\u1F248' | '\u1F250..\u1F251' | '\u1F300..\u1F320' | '\u1F330..\u1F335' | '\u1F337..\u1F37C' | '\u1F380..\u1F393' | '\u1F3A0..\u1F3C4' | '\u1F3C6..\u1F3CA' | '\u1F3E0..\u1F3F0' | '\u1F400..\u1F43E' | '\u1F440' | '\u1F442..\u1F4F7' | '\u1F4F9..\u1F4FC' | '\u1F500..\u1F53D' | '\u1F540..\u1F543' | '\u1F550..\u1F567' | '\u1F5FB..\u1F640' | '\u1F645..\u1F64F' | '\u1F680..\u1F6C5';
fragment unicode_zl : '\u2028';
fragment unicode_zp : '\u2029';
fragment unicode_zs : '\u0020' | '\u00A0' | '\u1680' | '\u180E' | '\u2000..\u200A' | '\u202F' | '\u205F';
fragment unicode_all : unicode_cc | unicode_cf | unicode_co | unicode_cs | unicode_ll | unicode_lm | unicode_lo | unicode_lt | unicode_lu
  | unicode_mc | unicode_me | unicode_mn | unicode_nd | unicode_nl | unicode_no | unicode_pc | unicode_pd | unicode_pe | unicode_pf |
  | unicode_pi | unicode_po | unicode_ps | unicode_sc | unicode_sk | unicode_sm | unicode_so | unicode_zl | unicode_zp | unicode_zs;


  // <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
  digit : '0'..'9';

  newline : '\u000a' | '\u000d' | '\u0085';

  white_space : ( unicode_zs | unicode_zl | unicode_zp | newline )+;

  // <simple Latin upper case letter> ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
  simple_latin_upper_case_letter : 'A'..'Z';

  // <simple Latin lower case letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
  simple_latin_lower_case_letter : 'a'..'z';

  // <nonquote character> ::= !! See the Syntax Rules.
  nonquote_character : unicode_all ~ '\u0027';

  //  <nondoublequote character> ::= !! See the Syntax Rules.
  nondoublequote_character : unicode_all ~ '\u0022';

  //  <Unicode escape character> ::= !! See the Syntax Rules.
  unicode_escape_character : unicode_cc | unicode_cf | unicode_co | unicode_cs | unicode_lm | unicode_lo | unicode_lt | unicode_mc
    | unicode_me | unicode_mn | unicode_nd | unicode_no | unicode_pc | unicode_pd | unicode_pe | unicode_pf | unicode_pi | unicode_po
    | unicode_ps | unicode_sc | unicode_sk | unicode_sm | unicode_so;

  // <identifier start> ::= !! See the Syntax Rules.
  identifier_start : unicode_lu | unicode_ll | unicode_lt | unicode_lm | unicode_lo | unicode_nl;

  // <identifier extend> ::= !! See the Syntax Rules.
  identifier_extend : unicode_lu | unicode_ll | unicode_lt | unicode_lm | unicode_lo | unicode_nl | unicode_mn | unicode_mc | unicode_nd | unicode_pc | unicode_cf;

  // non-reserved words
  t_a : a;
  t_absolute : a b s o l u t e ;
  t_action : a c t i o n ;
  t_ada : a d a ;
  t_add : a d d ;
  t_admin : a d m i n ;
  t_after : a f t e r ;
  t_always : a l w a y s ;
  t_asc : a s c ;
  t_assertion : a s s e r t i o n ;
  t_assignment : a s s i g n m e n t ;
  t_attribute : a t t r i b u t e ;
  t_attributes : a t t r i b u t e s ;
  t_before : b e f o r e ;
  t_bernoulli : b e r n o u l l i ;
  t_breadth : b r e a d t h ;
  t_c : c;
  t_cascade : c a s c a d e ;
  t_catalog : c a t a l o g ;
  t_catalog_name : c a t a l o g UNDERSCORE n a m e ;
  t_chain : c h a i n ;
  t_character_set_catalog : c h a r a c t e r UNDERSCORE s e t UNDERSCORE c a t a l o g ;
  t_character_set_name : c h a r a c t e r UNDERSCORE s e t UNDERSCORE n a m e ;
  t_character_set_schema : c h a r a c t e r UNDERSCORE s e t UNDERSCORE s c h e m a ;
  t_characteristics : c h a r a c t e r i s t i c s ;
  t_characters : c h a r a c t e r s ;
  t_class_origin : c l a s s UNDERSCORE o r i g i n ;
  t_cobol : c o b o l ;
  t_collation : c o l l a t i o n ;
  t_collation_catalog : c o l l a t i o n UNDERSCORE c a t a l o g ;
  t_collation_name : c o l l a t i o n UNDERSCORE n a m e ;
  t_collation_schema : c o l l a t i o n UNDERSCORE s c h e m a ;
  t_column_name : c o l u m n UNDERSCORE n a m e ;
  t_COMMAnd_function : c o m m a n d UNDERSCORE f u n c t i o n ;
  t_COMMAnd_function_code : c o m m a n d UNDERSCORE f u n c t i o n UNDERSCORE c o d e ;
  t_committed : c o m m i t t e d ;
  t_condition_number : c o n d i t i o n UNDERSCORE n u m b e r ;
  t_connection : c o n n e c t i o n ;
  t_connection_name : c o n n e c t i o n UNDERSCORE n a m e ;
  t_constraint_catalog : c o n s t r a i n t UNDERSCORE c a t a l o g ;
  t_constraint_name : c o n s t r a i n t UNDERSCORE n a m e ;
  t_constraint_schema : c o n s t r a i n t UNDERSCORE s c h e m a ;
  t_constraints : c o n s t r a i n t s ;
  t_constructor : c o n s t r u c t o r ;
  t_continue : c o n t i n u e ;
  t_cursor_name : c u r s o r UNDERSCORE n a m e ;
  t_data : d a t a ;
  t_datetime_interval_code : d a t e t i m e UNDERSCORE i n t e r v a l UNDERSCORE c o d e ;
  t_datetime_interval_precision : d a t e t i m e UNDERSCORE i n t e r v a l UNDERSCORE p r e c i s i o n ;
  t_defaults : d e f a u l t s ;
  t_deferrable : d e f e r r a b l e ;
  t_deferred : d e f e r r e d ;
  t_defined : d e f i n e d ;
  t_definer : d e f i n e r ;
  t_degree : d e g r e e ;
  t_depth : d e p t h ;
  t_derived : d e r i v e d ;
  t_desc : d e s c ;
  t_descriptor : d e s c r i p t o r ;
  t_diagnostics : d i a g n o s t i c s ;
  t_dispatch : d i s p a t c h ;
  t_domain : d o m a i n ;
  t_dynamic_function : d y n a m i c UNDERSCORE f u n c t i o n ;
  t_dynamic_function_code : d y n a m i c UNDERSCORE f u n c t i o n UNDERSCORE c o d e ;
  t_enforced : e n f o r c e d ;
  t_exclude : e x c l u d e ;
  t_excluding : e x c l u d i n g ;
  t_expression : e x p r e s s i o n ;
  t_final : f i n a l ;
  t_first : f i r s t ; 
  t_flag : f l a g ;
  t_following : f o l l o w i n g ;
  t_fortran : f o r t r a n ;
  t_found : f o u n d ;
  t_general : g e n e r a l ;
  t_generated : g e n e r a t e d ;
  t_g : g;
  t_go : g o ;
  t_goto : g o t o ;
  t_granted : g r a n t e d ;
  t_hierarchy : h i e r a r c h y ;
  t_ignore : i g n o r e ;
  t_immediate : i m m e d i a t e ;
  t_immediately : i m m e d i a t e l y ;
  t_implementation : i m p l e m e n t a t i o n ;
  t_including : i n c l u d i n g ;
  t_increment : i n c r e m e n t ;
  t_initially : i n i t i a l l y ;
  t_input : i n p u t ;
  t_instance : i n s t a n c e ;
  t_instantiable : i n s t a n t i a b l e ;
  t_instead : i n s t e a d ;
  t_invoker : i n v o k e r ; 
  t_isolation : i s o l a t i o n ;
  t_k : k;
  t_key : k e y ;
  t_key_member : k e y UNDERSCORE m e m b e r ;
  t_key_type : k e y UNDERSCORE t y p e ;
  t_last : l a s t ;
  t_length : l e n g t h ;
  t_level : l e v e l ;
  t_locator : l o c a t o r ;
  t_m : m; 
  t_map : m a p ; 
  t_matched : m a t c h e d ;
  t_maxvalue : m a x v a l u e ;
  t_message_length : m e s s a g e UNDERSCORE l e n g t h ;
  t_message_octet_length : m e s s a g e UNDERSCORE o c t e t UNDERSCORE l e n g t h ;
  t_message_text : m e s s a g e UNDERSCORE t e x t ;
  t_minvalue : m i n v a l u e ;
  t_more : m o r e ;
  t_mumps : m u m p s ;
  t_name : n a m e ;
  t_names : n a m e s ;
  t_nesting : n e s t i n g ;
  t_next : n e x t ;
  t_nfc : n f c ;
  t_nfd : n f d ;
  t_nfkc : n f k c ;
  t_nfkd : n f k d ;
  t_normalized : n o r m a l i z e d ;
  t_nullable : n u l l a b l e ;
  t_nulls : n u l l s ;
  t_number : n u m b e r ;
  t_object : o b j e c t ;
  t_octets : o c t e t s ;
  t_option : o p t i o n ;
  t_options : o p t i o n s ;
  t_ordering : o r d e r i n g ;
  t_ordinality : o r d i n a l i t y ;
  t_others : o t h e r s ; 
  t_output : o u t p u t ;
  t_overriding : o v e r r i d i n g ;
  t_p : p;
  t_pad : p a d ;
  t_parameter_mode : p a r a m e t e r UNDERSCORE m o d e ;
  t_parameter_name : p a r a m e t e r UNDERSCORE n a m e ;
  t_parameter_ordinal_position : p a r a m e t e r UNDERSCORE o r d i n a l UNDERSCORE p o s i t i o n ;
  t_parameter_specific_catalog : p a r a m e t e r UNDERSCORE s p e c i f i c UNDERSCORE c a t a l o g ;
  t_parameter_specific_name : p a r a m e t e r UNDERSCORE s p e c i f i c UNDERSCORE n a m e ;
  t_parameter_specific_schema : p a r a m e t e r UNDERSCORE s p e c i f i c UNDERSCORE s c h e m a ;
  t_partial : p a r t i a l ;
  t_pascal : p a s c a l ;
  t_path : p a t h ;
  t_placing : p l a c i n g ;
  t_pli : p l i ;
  t_preceding : p r e c e d i n g ;
  t_preserve : p r e s e r v e ;
  t_prior : p r i o r ;
  t_privileges : p r i v i l e g e s ;
  t_public : p u b l i c ;
  t_read : r e a d ;
  t_relative : r e l a t i v e ;
  t_repeatable : r e p e a t a b l e ;
  t_respect : r e s p e c t ;
  t_restart : r e s t a r t ;
  t_restrict : r e s t r i c t ;
  t_returned_cardinality : r e t u r n e d UNDERSCORE c a r d i n a l i t y ;
  t_returned_length : r e t u r n e d UNDERSCORE l e n g t h ;
  t_returned_octet_length : r e t u r n e d UNDERSCORE o c t e t UNDERSCORE l e n g t h ;
  t_returned_sqlstate : r e t u r n e d UNDERSCORE s q l s t a t e ;
  t_role : r o l e ;
  t_routine : r o u t i n e ;
  t_routine_catalog : r o u t i n e UNDERSCORE c a t a l o g ;
  t_routine_name : r o u t i n e UNDERSCORE n a m e ;
  t_routine_schema : r o u t i n e UNDERSCORE s c h e m a ;
  t_row_count : r o w UNDERSCORE c o u n t ;
  t_scale : s c a l e ;
  t_schema : s c h e m a ;
  t_schema_name : s c h e m a UNDERSCORE n a m e ;
  t_scope_catalog : s c o p e UNDERSCORE c a t a l o g ;
  t_scope_name : s c o p e UNDERSCORE n a m e ;
  t_scope_schema : s c o p e UNDERSCORE s c h e m a ;
  t_section : s e c t i o n ; 
  t_security : s e c u r i t y ;
  t_self : s e l f ;
  t_sequence : s e q u e n c e ;
  t_serializable : s e r i a l i z a b l e ;
  t_server_name : s e r v e r UNDERSCORE n a m e ;
  t_session : s e s s i o n ;
  t_sets : s e t s ;
  t_simple : s i m p l e ;
  t_size : s i z e ;
  t_source : s o u r c e ;
  t_space : s p a c e ;
  t_specific_name : s p e c i f i c UNDERSCORE n a m e ;
  t_state : s t a t e ;
  t_statement : s t a t e m e n t ;
  t_structure : s t r u c t u r e ;
  t_style : s t y l e ;
  t_subclass_origin : s u b c l a s s UNDERSCORE o r i g i n ;
  t_t : t;
  t_table_name : t a b l e UNDERSCORE n a m e ;
  t_temporary : t e m p o r a r y ;
  t_ties : t i e s ;
  t_top_level_count : t o p UNDERSCORE l e v e l UNDERSCORE c o u n t ;
  t_transaction : t r a n s a c t i o n ; 
  t_transaction_active : t r a n s a c t i o n UNDERSCORE a c t i v e ;
  t_transactions_committed : t r a n s a c t i o n s UNDERSCORE c o m m i t t e d ;
  t_transactions_rolled_back : t r a n s a c t i o n s UNDERSCORE r o l l e d UNDERSCORE b a c k ;
  t_transform : t r a n s f o r m ;
  t_transforms : t r a n s f o r m s ;
  t_trigger_catalog : t r i g g e r UNDERSCORE c a t a l o g ;
  t_trigger_name : t r i g g e r UNDERSCORE n a m e ;
  t_trigger_schema : t r i g g e r UNDERSCORE s c h e m a ;
  t_type : t y p e ;
  t_unbounded : u n b o u n d e d ;
  t_uncommitted : u n c o m m i t t e d ;
  t_under : u n d e r ;
  t_unnamed : u n n a m e d ;
  t_usage : u s a g e ;
  t_user_defined_type_catalog : u s e r UNDERSCORE d e f i n e d UNDERSCORE t y p e UNDERSCORE c a t a l o g ;
  t_user_defined_type_code : u s e r UNDERSCORE d e f i n e d UNDERSCORE t y p e UNDERSCORE c o d e ;
  t_user_defined_type_name : u s e r UNDERSCORE d e f i n e d UNDERSCORE t y p e UNDERSCORE n a m e ;
  t_user_defined_type_schema : u s e r UNDERSCORE d e f i n e d UNDERSCORE t y p e UNDERSCORE s c h e m a ;
  t_utf8 : u t f '8';
  t_utf16 : u t f '1' '6';
  t_view : v i e w ;
  t_work : w o r k ;
  t_write : w r i t e ;
  t_zone : z o n e ;

  // reserved words
  t_abs : a b s ;
  t_all : a l l ;
  t_allocate : a l l o c a t e ;
  t_alter : a l t e r ;
  t_and : a n d ;
  t_any : a n y ;
  t_are : a r e ;
  t_array : a r r a y ;
  t_array_agg : a r r a y UNDERSCORE a g g ; 
  t_array_max_cardinality : a r r a y UNDERSCORE m a x UNDERSCORE c a r d i n a l i t y ;
  t_as : a s ;
  t_asensitive : a s e n s i t i v e ;
  t_asymmetric : a s y m m e t r i c ;
  t_at : a t ;
  t_atomic : a t o m i c ;
  t_authorization : a u t h o r i z a t i o n ;
  t_avg : a v g ;
  t_begin : b e g i n ;
  t_begin_frame : b e g i n UNDERSCORE f r a m e ;
  t_begin_partition : b e g i n UNDERSCORE p a r t i t i o n ;
  t_between : b e t w e e n ;
  t_bigint : b i g i n t ;
  t_binary : b i n a r y ;
  t_blob : b l o b ;
  t_boolean : b o o l e a n ;
  t_both : b o t h ; 
  t_by : b y ;
  t_call : c a l l ;
  t_called : c a l l e d ;
  t_cardinality : c a r d i n a l i t y ;
  t_cascaded : c a s c a d e d ;
  t_case : c a s e ;
  t_cast : c a s t;
  t_ceil : c e i l ;
  t_ceiling : c e i l i n g ;
  t_char : c h a r ;
  t_char_length : c h a r UNDERSCORE l e n g t h ;
  t_character : c h a r a c t e r ;
  t_character_length : c h a r a c t e r UNDERSCORE l e n g t h ;
  t_check : c h e c k ;
  t_clob : c l o b ;
  t_close : c l o s e ; 
  t_coalesce : c o a l e s c e ;
  t_collate : c o l l a t e ;
  t_collect : c o l l e c t ;
  t_column : c o l u m n ;
  t_commit : c o m m i t ;
  t_condition : c o n d i t i o n ;
  t_connect : c o n n e c t ;
  t_constraint : c o n s t r a i n t ;
  t_contains : c o n t a i n s ;
  t_convert : c o n v e r t ;
  t_corr : c o r r ; 
  t_corresponding : c o r r e s p o n d i n g ;
  t_count : c o u n t ;
  t_covar_pop : c o v a r UNDERSCORE p o p ; 
  t_covar_samp : c o v a r UNDERSCORE s a m p ;
  t_create : c r e a t e ;
  t_cross : c r o s s ;
  t_cube : c u b e ;
  t_cume_dist : c u m e UNDERSCORE d i s t ;
  t_current : c u r r e n t ;
  t_current_catalog : c u r r e n t UNDERSCORE c a t a l o g ;
  t_current_date : c u r r e n t UNDERSCORE d a t e ;
  t_current_default_transform_group : c u r r e n t UNDERSCORE d e f a u l t UNDERSCORE t r a n s f o r m UNDERSCORE g r o u p ;
  t_current_path : c u r r e n t UNDERSCORE p a t h ;
  t_current_role : c u r r e n t UNDERSCORE r o l e ;
  t_current_row : c u r r e n t UNDERSCORE r o w ;
  t_current_schema : c u r r e n t UNDERSCORE s c h e m a ;
  t_current_time : c u r r e n t UNDERSCORE t i m e ;
  t_current_timestamp : c u r r e n t UNDERSCORE t i m e s t a m p ;
  t_current_transform_group_for_type : c u r r e n t UNDERSCORE t r a n s f o r m UNDERSCORE g r o u p UNDERSCORE f o r UNDERSCORE t y p e ;
  t_current_user : c u r r e n t UNDERSCORE u s e r ;
  t_cursor : c u r s o r ;
  t_cycle : c y c l e ;
  t_date : d a t e ;
  t_day : d a y ;
  t_deallocate : d e a l l o c a t e ;
  t_dec : d e c ;
  t_decimal : d e c i m a l ; 
  t_declare : d e c l a r e ;
  t_default : d e f a u l t ;
  t_delete : d e l e t e ;
  t_dense_rank : d e n s e UNDERSCORE r a n k ;
  t_deref : d e r e f ;
  t_describe : d e s c r i b e ;
  t_deterministic : d e t e r m i n i s t i c ;
  t_disconnect : d i s c o n n e c t ;
  t_distinct : d i s t i n c t ; 
  t_double : d o u b l e ;
  t_drop : d r o p ;
  t_dynamic : d y n a m i c ;
  t_each : e a c h ;
  t_element : e l e m e n t ;
  t_else : e l s e ;
  t_end : e n d ;
  t_end_frame : e n d UNDERSCORE f r a m e ;
  t_end_partition : e n d UNDERSCORE p a r t i t i o n ;
  t_end_exec : e n d '-' e x e c ;
  t_equals : e q u a l s ;
  t_escape : e s c a p e ;
  t_every : e v e r y ;
  t_except : e x c e p t ; 
  t_exec : e x e c ;
  t_execute : e x e c u t e ;
  t_exists : e x i s t s ;
  t_exp : e x p ;
  t_external : e x t e r n a l ;
  t_extract : e x t r a c t ;
  t_false : f a l s e ;
  t_fetch : f e t c h ;
  t_filter : f i l t e r ;
  t_first_value : f i r s t UNDERSCORE v a l u e ;
  t_float : f l o a t ;
  t_floor : f l o o r ;
  t_for : f o r ;
  t_foreign : f o r e i g n ;
  t_frame_row : f r a m e UNDERSCORE r o w ;
  t_free : f r e e ;
  t_from : f r o m ;
  t_full : f u l l ;
  t_function : f u n c t i o n ;
  t_fusion : f u s i o n ;
  t_get : g e t ;
  t_global : g l o b a l ; 
  t_grant : g r a n t ;
  t_group : g r o u p ;
  t_grouping : g r o u p i n g ;
  t_groups : g r o u p s ;
  t_having : h a v i n g ;
  t_hold : h o l d ;
  t_hour : h o u r ;
  t_identity : i d e n t i t y ;
  t_in : i n ;
  t_indicator : i n d i c a t o r ;
  t_inner : i n n e r ;
  t_inout : i n o u t ;
  t_insensitive : i n s e n s i t i v e ;
  t_insert : i n s e r t ;
  t_int : i n t ;
  t_integer : i n t e g e r ;
  t_intersect : i n t e r s e c t ;
  t_intersection : i n t e r s e c t i o n ; 
  t_interval : i n t e r v a l ; 
  t_into : i n t o ;
  t_is : i s ;
  t_join : j o i n ; 
  t_lag : l a g ;
  t_language : l a n g u a g e ;
  t_large : l a r g e ;
  t_last_value : l a s t UNDERSCORE v a l u e ;
  t_lateral : l a t e r a l ;
  t_lead : l e a d ;
  t_leading : l e a d i n g ;
  t_left : l e f t ;
  t_like : l i k e ;
  t_like_regex : l i k e UNDERSCORE r e g e x ;
  t_ln : l n ;
  t_local : l o c a l ;
  t_localtime : l o c a l t i m e ;
  t_localtimestamp : l o c a l t i m e s t a m p ;
  t_lower : l o w e r ;
  t_match : m a t c h ;
  t_max : m a x ;
  t_member : m e m b e r ;
  t_merge : m e r g e ;
  t_method : m e t h o d ;
  t_min : m i n ;
  t_minute : m i n u t e ;
  t_mod : m o d ;
  t_modifies : m o d i f i e s ;
  t_module : m o d u l e ;
  t_month : m o n t h ;
  t_multiset : m u l t i s e t ;
  t_national : n a t i o n a l ;
  t_natural : n a t u r a l ;
  t_nchar : n c h a r ;
  t_nclob : n c l o b ;
  t_new : n e w ;
  t_no : n o ;
  t_none : n o n e ;
  t_normalize : n o r m a l i z e ;
  t_not : n o t ;
  t_nth_value : n t h UNDERSCORE v a l u e ;
  t_ntile : n t i l e ;
  t_null : n u l l ;
  t_nullif : n u l l i f ;
  t_numeric : n u m e r i c ;
  t_octet_length : o c t e t UNDERSCORE l e n g t h ;
  t_occurrence : o c c u r r e n c e ;
  t_occurrences_regex : o c c u r r e n c e s UNDERSCORE r e g e x ;
  t_of : o f ; 
  t_offset : o f f s e t ;
  t_old : o l d ;
  t_on : o n ;
  t_only : o n l y ;
  t_open : o p e n ;
  t_or : o r ; 
  t_order : o r d e r ;
  t_out : o u t ;
  t_outer : o u t e r ;
  t_over : o v e r ;
  t_overlaps : o v e r l a p s ;
  t_overlay : o v e r l a  y ;
  t_parameter : p a r a m e t e r ;
  t_partition : p a r t i t i o n ;
  t_percent : p e r c e n t ;
  t_percent_rank : p e r c e n t UNDERSCORE r a n k ;
  t_percentile_cont : p e r c e n t i l e UNDERSCORE c o n t ;
  t_percentile_disc : p e r c e n t i l e UNDERSCORE d i s c ;
  t_period : p e r i o d ;
  t_portion : p o r t i o n ;
  t_position : p o s i t i o n ;
  t_position_regex : p o s i t i o n UNDERSCORE r e g e x ;
  t_power : p o w e r ;
  t_precedes : p r e c e d e s ;
  t_precision : p r e c i s i o n ;
  t_prepare : p r e p a r e ;
  t_primary : p r i m a r y ;
  t_procedure : p r o c e d u r e ;
  t_range : r a n g e ;
  t_rank : r a n k ;
  t_reads : r e a d s ;
  t_real : r e a l ;
  t_recursive : r e c u r s i v e ;
  t_ref : r e f ;
  t_references : r e f e r e n c e s ;
  t_referencing : r e f e r e n c i n g ;
  t_regr_avgx : r e g r UNDERSCORE a v g x ;
  t_regr_avgy : r e g r UNDERSCORE a v g y ;
  t_regr_count : r e g r UNDERSCORE c o u n t ;
  t_regr_intercept : r e g r UNDERSCORE i n t e r c e p t ;
  t_regr_r2 : r e g r UNDERSCORE r '2' ;
  t_regr_slope : r e g r UNDERSCORE s l o p e ;
  t_regr_sxx : r e g r UNDERSCORE s x x ;
  t_regr_sxy : r e g r UNDERSCORE s x y ;
  t_regr_syy : r e g r UNDERSCORE s y y ;
  t_release : r e l e a s e ;
  t_result : r e s u l t ;
  t_return : r e t u r n ;
  t_returns : r e t u r n s ;
  t_revoke : r e v o k e ;
  t_right : r i g h t ;
  t_rollback : r o l l b a c k ;
  t_rollup : r o l l u p ;
  t_row : r o w ;
  t_row_number : r o w UNDERSCORE n u m b e r ;
  t_rows : r o w s ;
  t_savepoint : s a v e p o i n t ;
  t_scope : s c o p e ;
  t_scroll : s c r o l l ;
  t_search : s e a r c h ;
  t_second : s e c o n d ;
  t_select : s e l e c t ;
  t_sensitive : s e n s i t i v e ;
  t_session_user : s e s s i o n UNDERSCORE u s e r ;
  t_set : s e t ; 
  t_similar : s i m i l a r ; 
  t_smallint : s m a l l i n t ;
  t_some : s o m e ;
  t_specific : s p e c i f i c ;
  t_specifictype : s p e c i f i c t y p e ;
  t_sql : s q l ;
  t_sqlexception : s q l e x c e p t i o n ;
  t_sqlstate : s q l s t a t e ;
  t_sqlwarning : s q l w a r n i n g ;
  t_sqrt : s q r t ;
  t_start : s t a r t ;
  t_static : s t a t i c ;
  t_stddev_pop : s t d d e v UNDERSCORE p o p ;
  t_stddev_samp : s t d d e v UNDERSCORE s a m p ;
  t_submultiset : s u b m u l t i s e t ;
  t_substring : s u b s t r i n g ;
  t_substring_regex : s u b s t r i n g UNDERSCORE r e g e x ;
  t_succeeds : s u c c e e d s ;
  t_sum : s u m ;
  t_symmetric : s y m m e t r i c ;
  t_system : s y s t e m ;
  t_system_time : s y s t e m UNDERSCORE t i m e ;
  t_system_user : s y s t e m UNDERSCORE u s e r ;
  t_table : t a b l e ;
  t_tablesample : t a b l e s a m p l e ;
  t_then : t h e n ;
  t_time : t i m e ;
  t_timestamp : t i m e s t a m p ;
  t_timezone_hour : t i m e z o n e UNDERSCORE h o u r ;
  t_timezone_minute : t i m e z o n e UNDERSCORE m i n u t e ;
  t_to : t o ;
  t_trailing : t r a i l i n g ;
  t_translate : t r a n s l a t e ;
  t_translate_regex : t r a n s l a t e UNDERSCORE r e g e x ;
  t_translation : t r a n s l a t i o n ;
  t_treat : t r e a t ;
  t_trigger : t r i g g e r ;
  t_truncate : t r u n c a t e ;
  t_trim : t r i m ;
  t_trim_array : t r i m UNDERSCORE a r r a y ;
  t_true : t r u e ;
  t_uescape : u e s c a p e ;
  t_union : u n i o n ;
  t_unique : u n i q u e ;
  t_unknown : u n k n o w n ;
  t_unnest : u n n e s t ;
  t_update : u p d a t e ;
  t_upper : u p p e r ;
  t_user : u s e r ;
  t_using : u s i n g ;
  t_value : v a l u e ;
  t_values : v a l u e s ;
  t_value_of : v a l u e UNDERSCORE o f ;
  t_var_pop : v a r UNDERSCORE p o p ;
  t_var_samp : v a r UNDERSCORE s a m p ;
  t_varbinary : v a r b i n a r y ;
  t_varchar : v a r c h a r ;
  t_varying : v a r y i n g ;
  t_versioning : v e r s i o n i n g ;
  t_when : w h e n ;
  t_whenever : w h e n e v e r ;
  t_where : w h e r e ;
  t_width_bucket : w i d t h UNDERSCORE b u c k e t ;
  t_window : w i n d o w ;
  t_with : w i t h ;
  t_within : w i t h i n ;
  t_without : w i t h o u t ;
  t_year : y e a r ;

direct_sql_statements : direct_sql_statement+;

// <direct SQL statement> ::= <directly executable statement> <SEMICOLON>
direct_sql_statement : directly_executable_statement SEMICOLON;

// <directly executable statement> ::= <direct SQL data statement> | <SQL schema statement> | <SQL transaction statement> | <SQL connection statement> | <SQL session statement> | <direct implementation-defined statement>
// TODO: look at enabling the schema, transaction, connection, and session sql as well.
directly_executable_statement : {direct} direct_sql_data_statement; // | {schema} sql_schema_statment | {transaction} sql_transaction_statement | {connection} sql_connection_statement | {session} sql_session_statement;

// <direct SQL data statement> ::= <delete statement: searched> | <direct select statement: multiple rows> | <insert statement> | <update statement: searched> | <truncate table statement> | <merge statement> | <temporary table declaration>
direct_sql_data_statement : {delete} delete_statement_searched
     | {select} direct_select_statement_multiple | {insert} insert_statement | {update} update_statement_searched | {truncate} truncate_table_statement
     | {merge} merge_statement | {temp_table} temporary_table_declaration;

// <delete statement: searched> ::= DELETE FROM <target table> [ FOR PORTION OF <application time PERIOD name> FROM <point in time 1> TO <point in time 2> ] [ [ AS ] <correlation name> ] [ WHERE <search condition> ]
delete_statement_searched : t_delete t_from target_table (t_for t_portion t_of application_time_period_name t_from point_in_time1 t_to point_in_time2)? (t_as? correlation_name)? (t_where search_condition)?;

// <truncate table statement> ::= TRUNCATE TABLE <target table> [ <identity column restart option> ]
truncate_table_statement : t_truncate t_table target_table identity_column_restart_option?;

// <identity column restart option> ::= CONTINUE IDENTITY | RESTART IDENTITY
identity_column_restart_option : {continue} t_continue t_identity | {restart} t_restart t_identity;

// <insert statement> ::= INSERT INTO <insertion target> <insert columns and source>
insert_statement : t_insert t_into insertion_target insert_columns_and_source;

// <insertion target> ::= <table name>
insertion_target : table_name;

// <insert columns and source> ::= <from subquery> | <from constructor> | <from default>
insert_columns_and_source : {subquery} from_subquery | {constructor} from_constructor | {default} from_default;

// <from subquery> ::= [ <left paren> <insert column list> <right paren> ] [ <override clause> ] <query expression>
from_subquery : (LEFT_PAREN insert_column_list RIGHT_PAREN)? override_clause? query_expression; 

// <from constructor> ::= [ <left paren> <insert column list> <right paren> ] [ <override clause> ] <contextually typed table value constructor>
from_constructor : (LEFT_PAREN insert_column_list RIGHT_PAREN)? override_clause? contextually_typed_table_value_constructor;

// <override clause> ::= OVERRIDING USER VALUE | OVERRIDING SYSTEM VALUE 
override_clause : {user} t_overriding t_user t_value | {system} t_overriding t_system t_value;

// <from default> ::= DEFAULT VALUES
from_default : t_default t_values;

// <insert column list> ::= <column name list>
insert_column_list : column_name_list;

// <merge statement> ::= MERGE INTO <target table> [ [ AS ] <merge correlation name> ] USING <table reference> ON <search condition> <merge operation specification>
merge_statement : t_merge t_into target_table (t_as? merge_correlation_name)? t_using table_reference t_on search_condition merge_operation_specification;

// <merge correlation name> ::= <correlation name>
merge_correlation_name : correlation_name;

// <merge operation specification> ::= <merge when clause>...
merge_operation_specification : merge_when_clause+;

// <merge when clause> ::= <merge when matched clause> | <merge when not matched clause>
merge_when_clause : {match} merge_when_matched_clause | {no_match} merge_when_not_matched_clause;

// <merge when matched clause> ::= WHEN MATCHED [ AND <search condition> ] THEN <merge update or delete specification>
merge_when_matched_clause : t_when t_matched (t_and search_condition)? t_then merge_update_or_delete_specification;

// <merge update or delete specification> ::= <merge update specification> | <merge delete specification>
merge_update_or_delete_specification : {update} merge_update_specification | {delete} merge_delete_specification;

// <merge when not matched clause> ::= WHEN NOT MATCHED [ AND <search condition> ] THEN <merge insert specification>
merge_when_not_matched_clause : t_when t_not t_matched (t_and search_condition)? t_then merge_insert_specification;

// <merge update specification> ::= UPDATE SET <set clause list>
merge_update_specification : t_update t_set set_clause_list;

// <merge delete specification> ::= DELETE
merge_delete_specification : t_delete;

// <merge insert specification> ::= INSERT [ <left paren> <insert column list> <right paren> ] [ <override clause> ] VALUES <merge insert value list>
merge_insert_specification : t_insert (LEFT_PAREN insert_column_list RIGHT_PAREN)? override_clause? t_values merge_insert_value_list;

// <merge insert value list> ::= <left paren> <merge insert value element> [ { <comma> <merge insert value element> }... ] <right paren>
merge_insert_value_list : LEFT_PAREN merge_insert_value_element (COMMA merge_insert_value_element)* RIGHT_PAREN;

// <merge insert value element> ::= <value expression> | <contextually typed value specification>
merge_insert_value_element : {exp} value_expression | {spec} contextually_typed_value_specification;

// <update statement: searched> ::= UPDATE <target table> [ FOR PORTION OF <application time period name> FROM <point in time 1> TO <point in time 2> ] [ [ AS ] <correlation name> ] SET <set clause list> [ WHERE <search condition> ]
update_statement_searched : t_update target_table (t_for t_portion t_of application_time_period_name t_from point_in_time1 t_to point_in_time2)? (t_as? correlation_name)? t_set set_clause_list (t_where search_condition)?;

// <set clause list> ::= <set clause> [ { <comma> <set clause> }... ]
set_clause_list : set_clause (COMMA set_clause)*;

// <set clause> ::= <multiple column assignment> | <set target> <equals operator> <update source>
set_clause : {multi} multiple_column_assignment  | {target} set_target EQUALS_OPERATOR update_source;

// <set target> ::= <update target> | <mutated set clause>
set_target : {update} update_target | {mutated} mutated_set_clause;

// <multiple column assignment> ::= <set target list> <equals operator> <assigned row> 
multiple_column_assignment : set_target_list EQUALS_OPERATOR assigned_row;

// <set target list> ::= <left paren> <set target> [ { <comma> <set target> }... ] <right paren>
set_target_list : LEFT_PAREN set_target (COMMA set_target)* RIGHT_PAREN;

// <assigned row> ::= <contextually typed row value expression>
assigned_row : contextually_typed_row_value_expression;

// <update target> ::= <object column> | <object column> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
update_target : {unbracketed} object_column | {bracketed} object_column left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph;

// <object column> ::= <column name>
object_column : column_name;

// <mutated set clause> ::= <mutated target> <period> <method name>
mutated_set_clause : mutated_target PERIOD method_name;

// <mutated target> ::= <object column> | <mutated set clause>
mutated_target : {object} object_column | {mutated} mutated_set_clause;

// <update source> ::= <value expression> | <contextually typed value specification>
update_source : {exp} value_expression | {spec} contextually_typed_value_specification;

// <temporary table declaration> ::= DECLARE LOCAL TEMPORARY TABLE <table name> <table element list> [ ON COMMIT <table commit action> ROWS ]
temporary_table_declaration : t_declare t_local t_temporary t_table table_name table_element_list (t_on t_commit table_commit_action t_rows)?;

// <direct select statement: multiple rows> ::= <cursor specification>
direct_select_statement_multiple : cursor_specification;

// <search condition> ::= <boolean value expression>
search_condition : boolean_value_expression;

// <boolean value expression> ::= <boolean term> | <boolean value expression> OR <boolean term>
boolean_value_expression : {term} boolean_term | {exp_or_term} boolean_value_expression t_or boolean_term;

// <boolean term> ::= <boolean factor> | <boolean term> AND <boolean factor>
boolean_term : {factor} boolean_factor | {term_and_factor} boolean_term t_and boolean_factor;

// <boolean factor> ::= [ NOT ] <boolean test>
boolean_factor : t_not? boolean_test;

// <boolean test> ::= <boolean primary> [ IS [ NOT ] <truth value> ]
boolean_test : boolean_primary (t_is t_not? truth_value)?;

// <truth value> ::= TRUE | FALSE | UNKNOWN
truth_value : {true} t_true | {false} t_false | {unknown} t_unknown;

// <boolean primary> ::= <predicate> | <boolean predicand>
boolean_primary : {predicate} predicate | {predicand} boolean_predicand;

// <boolean predicand> ::= <parenthesized boolean value expression> | <nonparenthesized value expression primary>
boolean_predicand : {paren} parenthesized_boolean_value_expression | {nonparen} nonparenthesized_value_expression_primary;

// <parenthesized boolean value expression> ::= <left paren> <boolean value expression> <right paren>
parenthesized_boolean_value_expression : LEFT_PAREN boolean_value_expression RIGHT_PAREN;

// <target table> ::= <table name> | ONLY <left paren> <table name> <right paren>
target_table : {table} table_name | {only} t_only LEFT_PAREN table_name RIGHT_PAREN;

// <datetime value expression> ::= <datetime term> | <interval value expression> <plus sign> <datetime term>
//   | <datetime value expression> <plus sign> <interval term> | <datetime value expression> <minus sign> <interval term>
datetime_value_expression : {term} datetime_term | {interval} interval_value_expression PLUS_SIGN datetime_term | {value_plus} datetime_value_expression PLUS_SIGN interval_term | {value_minus} datetime_value_expression MINUS_SIGN interval_term;

// <datetime term> ::= <datetime factor>
datetime_term : datetime_factor;

// <datetime factor> ::= <datetime primary> [ <time zone> ]
datetime_factor : datetime_primary time_zone?;

// <datetime primary> ::= <value expression primary> | <datetime value function>
datetime_primary : {expression} value_expression_primary | {function} datetime_value_function;

// <time zone> ::= AT <time zone specifier>
time_zone : t_at time_zone_specifier;

// <time zone specifier> ::= LOCAL | TIME ZONE <interval primary>
time_zone_specifier : {local} t_local | {time_zone} t_time t_zone interval_primary;

// <cursor specification> ::= <query expression> [ <updatability clause> ]
cursor_specification : query_expression updatability_clause?;

// <updatability clause> ::= FOR { READ ONLY | UPDATE [ OF <column name list> ] }
updatability_clause : t_for (t_read t_only | t_update (t_of column_name_list)?);

// <query expression> ::= [ <with clause> ] <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ]
query_expression : with_clause? query_expression_body order_by_clause? result_offset_clause? fetch_first_clause?;

// <with clause> ::= WITH [ RECURSIVE ] <with list>
with_clause : t_with t_recursive? with_list;

// <with list> ::= <with list element> [ { <comma> <with list element> }... ]
with_list : with_list_element (COMMA with_list_element)*;

// <with list element> ::= <query name> [ <left paren> <with column list> <right paren> ] AS <table subquery> [ <search or cycle clause> ]
with_list_element : query_name (LEFT_PAREN with_column_list RIGHT_PAREN)? t_as table_subquery search_or_cycle_clause?;

// <with column list> ::= <column name list>
with_column_list : column_name_list;

// <query expression body> ::= <query term> | <query expression body> UNION [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
//   | <query expression body> EXCEPT [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
query_expression_body : {term} query_term |  {union} query_expression_body t_union (t_all | t_distinct)? corresponding_spec? query_term
   |  {except} query_expression_body t_except (t_all | t_distinct)? corresponding_spec? query_term;

// <query term> ::= <query primary> | <query term> INTERSECT [ ALL | DISTINCT ] [ <corresponding spec> ] <query primary>
query_term : {primary} query_primary | {intersect} query_term t_intersect (t_all | t_distinct)? corresponding_spec? query_primary;

// <query primary> ::= <simple table> | <left paren> <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ] <right paren>
query_primary : {simple} simple_table |  {not_simple} LEFT_PAREN query_expression_body order_by_clause? result_offset_clause? fetch_first_clause? RIGHT_PAREN;

// <simple table> ::= <query specification> | <table value constructor> | <explicit table>
simple_table : {query} query_specification | {table} table_value_constructor | {explicit} explicit_table;

// <explicit table> ::= TABLE <table or query name>
explicit_table : t_table table_or_query_name;

// <corresponding spec> ::= CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]
corresponding_spec : t_corresponding (t_by LEFT_PAREN corresponding_column_list RIGHT_PAREN)?;

// <corresponding column list> ::= <column name list>
corresponding_column_list : column_name_list;

// <order by clause> ::= ORDER BY <sort specification list>
order_by_clause : t_order t_by sort_specification_list;

// <result offset clause> ::= OFFSET <offset row count> { ROW | ROWS }
result_offset_clause : t_offset offset_row_count (t_row | t_rows);

// <fetch first clause> ::= FETCH { FIRST | NEXT } [ <fetch first quantity> ] { ROW | ROWS } { ONLY | WITH TIES }
fetch_first_clause : t_fetch (t_first | t_next) fetch_first_quantity? (t_row | t_rows) (t_only | t_with t_ties);

// <fetch first quantity> ::= <fetch first row count> | <fetch first percentage>
fetch_first_quantity : {count} fetch_first_row_count | {PERCENT} fetch_first_percentage;

// <offset row count> ::= <simple value specification>
offset_row_count : simple_value_specification;

// <fetch first row count> ::= <simple value specification>
fetch_first_row_count : simple_value_specification;

// <fetch first percentage> ::= <simple value specification> PERCENT
fetch_first_percentage : simple_value_specification PERCENT;

// <table reference> ::= <table factor> | <joined table>
table_reference : {factor} table_factor | {joined} joined_table;

// <table factor> ::= <table primary> [ <sample clause> ]
table_factor : table_primary sample_clause?;

// <sample clause> ::= TABLESAMPLE <sample method> <left paren> <sample percentage> <right paren> [ <repeatable clause> ]
sample_clause : t_tablesample sample_method LEFT_PAREN sample_percentage RIGHT_PAREN repeatable_clause?;

// <sample method> ::= BERNOULLI | SYSTEM
sample_method : {bernoulli} t_bernoulli | {system} t_system;

// <repeatable clause> ::= REPEATABLE <left paren> <repeat argument> <right paren>
repeatable_clause : t_repeatable LEFT_PAREN repeat_argument RIGHT_PAREN;

// <sample percentage> ::= <numeric value expression>
sample_percentage : numeric_value_expression;

// <repeat argument> ::= <numeric value expression>
repeat_argument : numeric_value_expression;

// <table primary> ::= <table or query name> [ <query system time period specification> ] [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
//   | <derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <lateral derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <collection derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <table function derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <only spec> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
//   | <data change delta table> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
//   | <parenthesized joined table>
table_primary : {table_or_query} table_or_query_name query_system_time_period_specification? ( t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)? )
   | {derived} derived_table t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)?
   | {lateral} lateral_derived_table t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)?
   | {collection} collection_derived_table t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)?
   | {function} table_function_derived_table t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)?
   | {only_spec} only_spec (t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)?)?
   | {data_change} data_change_delta_table (t_as? correlation_name (LEFT_PAREN derived_column_list RIGHT_PAREN)?)?
   | {join} parenthesized_joined_table;


// <query system time PERIOD specification> ::= FOR SYSTEM_TIME AS OF <point in time 1>
//   | FOR SYSTEM_TIME BETWEEN [ ASYMMETRIC | SYMMETRIC ] <point in time 1> AND <point in time 2>
//   | FOR SYSTEM_TIME FROM <point in time 1> TO <point in time 2>
query_system_time_period_specification : {since} t_for t_system_time t_as t_of point_in_time1
   | {between} t_for t_system t_time t_between (t_asymmetric | t_symmetric)? point_in_time1 t_and point_in_time2
   | {from} t_for t_system t_time t_from point_in_time1 t_to  point_in_time2;

// <point in time 1> ::= <point in time>
point_in_time1 : point_in_time;

// <point in time 2> ::= <point in time>
point_in_time2 : point_in_time;

// <point in time> ::= <datetime value expression>
point_in_time : datetime_value_expression;

// <only spec> ::= ONLY <left paren> <table or query name> <right paren>
only_spec : t_only LEFT_PAREN table_or_query_name RIGHT_PAREN;

// <lateral derived table> ::= LATERAL <table subquery>
lateral_derived_table : t_lateral table_subquery;

// <collection derived table> ::= UNNEST <left paren> <collection value expression> [ { <comma> <collection value expression> }... ] <right paren> [ WITH ORDINALITY ]
collection_derived_table : t_unnest LEFT_PAREN collection_value_expression (COMMA collection_value_expression)* RIGHT_PAREN (t_with t_ordinality)?;

// <table function derived table> ::= TABLE <left paren> <collection value expression> <right paren>
table_function_derived_table : t_table LEFT_PAREN collection_value_expression RIGHT_PAREN;

// <derived table> ::= <table subquery>
derived_table : table_subquery;

// <table or query name> ::= <table name> | <transition table name> | <query name>
table_or_query_name : {table} table_name | {transition} transition_table_name | query_name;

// <derived column list> ::= <column name list>
derived_column_list : column_name_list;

// <column name list> ::= <column name> [ { <comma> <column name> }... ]
column_name_list : column_name (COMMA column_name)*;

// <data change delta table> ::= <result option> TABLE <left paren> <data change statement> <right paren>
data_change_delta_table : result_option t_table LEFT_PAREN data_change_statement RIGHT_PAREN;

// <data change statement> ::= <delete statement: searched> | <insert statement> | <merge statement> | <update statement: searched>
data_change_statement : {delete} delete_statement_searched | {insert} insert_statement | {merge} merge_statement | {update} update_statement_searched;

// <result option> ::= FINAL | NEW | OLD
result_option : {final} t_final | {new} t_new | {old} t_old;

// <parenthesized joined table> ::= <left paren> <parenthesized joined table> <right paren> | <left paren> <joined table> <right paren>
parenthesized_joined_table : {paren} LEFT_PAREN parenthesized_joined_table RIGHT_PAREN | {joined} LEFT_PAREN joined_table RIGHT_PAREN;

// <value expression> ::= <common value expression> | <boolean value expression> | <row value expression>
value_expression : {common} common_value_expression | {boolean} boolean_value_expression | {row} row_value_expression;

// <common value expression> ::= <numeric value expression> | <string value expression> | <datetime value expression>
//   | <interval value expression> | <user-defined type value expression> | <reference value expression> | <collection value expression>
common_value_expression : {numeric} numeric_value_expression | {string} string_value_expression | {datetime} datetime_value_expression
    | {interval} interval_value_expression | {user} user_defined_type_value_expression | {reference} reference_value_expression | {collection} collection_value_expression;

// <user-defined type value expression> ::= <value expression primary>
user_defined_type_value_expression : value_expression_primary;

// <reference value expression> ::= <value expression primary>
reference_value_expression : value_expression_primary;

// <collection value expression> ::= <array value expression> | <multiset value expression>
collection_value_expression : {array} array_value_expression | {multiset} multiset_value_expression;

// <contextually typed value specification> ::= <implicitly typed value specification> | <default specification>
contextually_typed_value_specification : {implicit} implicitly_typed_value_specification | {default} default_specification;

// <implicitly typed value specification> ::= <null specification> | <empty specification>
implicitly_typed_value_specification : {null} null_specification | {empty} empty_specification;

// <null specification> ::= NULL
null_specification : t_null;

// <empty specification> ::= ARRAY <left bracket or trigraph> <right bracket or trigraph> | MULTISET <left bracket or trigraph> <right bracket or trigraph>
empty_specification : {array} t_array left_bracket_or_trigraph right_bracket_or_trigraph | {multiset} t_multiset left_bracket_or_trigraph right_bracket_or_trigraph;

// <default specification> ::= DEFAULT
default_specification : t_default;

// <row value expression> ::= <row value special case> | <explicit row value constructor>
row_value_expression : {special} row_value_special_case | {explicit} explicit_row_value_constructor;

// <table row value expression> ::= <row value special case> | <row value constructor>
table_row_value_expression : {special} row_value_special_case | {constructor} row_value_constructor;

// <contextually typed row value expression> ::= <row value special case> | <contextually typed row value constructor>
contextually_typed_row_value_expression : {row} row_value_special_case | {context} contextually_typed_row_value_constructor;

// <row value predicand> ::= <row value special case> | <row value constructor predicand>
row_value_predicand : {row_value_special_case} row_value_special_case | {row_value_constructor_predicand} row_value_constructor_predicand;

// <row value special case> ::= <nonparenthesized value expression primary>
row_value_special_case : nonparenthesized_value_expression_primary;

// <value specification> ::= <literal> | <general value specification>
// <unsigned value specification> ::= <unsigned literal> | <general value specification>
unsigned_value_specification : {literal} unsigned_literal | {general} general_value_specification;

// <general value specification> ::= <host parameter specification> | <SQL parameter reference> | <dynamic parameter specification>
//   | <embedded variable specification> | <current collation specification> | CURRENT_CATALOG | CURRENT_DEFAULT_TRANSFORM_GROUP | CURRENT_PATH
//   | CURRENT_ROLE | CURRENT_SCHEMA | CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name> | CURRENT_USER | SESSION_USER | SYSTEM_USER | USER | VALUE
general_value_specification : {host_parameter_specification} host_parameter_specification | {sql_parameter_reference} sql_parameter_reference | {dynamic_parameter_specification} dynamic_parameter_specification
   | {embedded_variable_specification} embedded_variable_specification | {current_collation_specification} current_collation_specification | {current_catalog} t_current_catalog | {current_default_transform_group} t_current_default_transform_group | {current_path} t_current_path
   | {current_role} t_current_role | {current_schema} t_current_schema | {current_transform_group_for_type} t_current_transform_group_for_type path_resolved_user_defined_type_name | {current_user} t_current_user | {session_user} t_session_user | {system_user} t_system_user | {user} t_user | {value} t_value;

// <simple value specification> ::= <literal> | <host parameter name> | <SQL parameter reference> | <embedded variable name>
simple_value_specification : {literal} literal | {host} host_parameter_name | {sql} sql_parameter_reference | {embedded} embedded_variable_name; 

// <target specification> ::= <host parameter specification> | <SQL parameter reference> | <column reference> | <target array element specification>
//   | <dynamic parameter specification> | <embedded variable specification>
target_specification : {host} host_parameter_specification | {sql} sql_parameter_reference | {column} column_reference  | {target} target_array_element_specification
   | {dynamic} dynamic_parameter_specification | {embedded}  embedded_variable_specification;

// <simple target specification> ::= <host parameter name> | <SQL parameter reference> | <column reference> | <embedded variable name>
simple_target_specification : {host} host_parameter_name | {sql} sql_parameter_reference | {column} column_reference | {embedded} embedded_variable_name;

// <host parameter specification> ::= <host parameter name> [ <indicator parameter> ]
host_parameter_specification : host_parameter_name indicator_parameter?;

// <dynamic parameter specification> ::= <question mark>
dynamic_parameter_specification : QUESTION_MARK;

// <embedded variable specification> ::= <embedded variable name> [ <indicator variable> ]
embedded_variable_specification : embedded_variable_name indicator_variable?;

// <indicator variable> ::= [ INDICATOR ] <embedded variable name>
indicator_variable : t_indicator? embedded_variable_name;

// <indicator parameter> ::= [ INDICATOR ] <host parameter name>
indicator_parameter : t_indicator? host_parameter_name;

// <target array element specification> ::= <target array reference> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
target_array_element_specification : target_array_reference left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph;

// <target array reference> ::= <SQL parameter reference> | <column reference>
target_array_reference : {sql} sql_parameter_reference | {column} column_reference;

// <current collation specification> ::= COLLATION FOR <left paren> <string value expression> <right paren>
current_collation_specification : t_collation t_for LEFT_PAREN string_value_expression RIGHT_PAREN;

// <identifier> ::= <actual identifier>
identifier : actual_identifier;

// <actual identifier> ::= <regular identifier> | <delimited identifier> | <Unicode delimited identifier>
actual_identifier : {regular_identifier} regular_identifier | {delimited_identifier} delimited_identifier | {unicode_delimited_identifier} unicode_delimited_identifier;

// <SQL language identifier> ::= <SQL language identifier start> [ <SQL language identifier part>... ]
sql_language_identifier : sql_language_identifier_start sql_language_identifier_part*;

// <SQL language identifier start> ::= <simple Latin letter>
sql_language_identifier_start : simple_latin_letter;

// <SQL language identifier part> ::= <simple Latin letter> | <digit> | <UNDERSCORE>
sql_language_identifier_part : {letter} simple_latin_letter | {digit} digit | {UNDERSCORE} UNDERSCORE;

// <authorization identifier> ::= <role name> | <user identifier>
authorization_identifier : {role_name} role_name | {user_identifier} user_identifier;

// <table name> ::= <local or schema qualified name>
table_name : local_or_schema_qualified_name;

// <domain name> ::= <schema qualified name>
domain_name : schema_qualified_name;

// <schema name> ::= [ <catalog name> <period> ] <unqualified schema name>
schema_name : (catalog_name PERIOD)? unqualified_schema_name;

// <unqualified schema name> ::= <identifier>
unqualified_schema_name : identifier;

// <catalog name> ::= <identifier>
catalog_name : identifier;

// <schema qualified name> ::= [ <schema name> <period> ] <qualified identifier>
schema_qualified_name : (schema_name PERIOD)? qualified_identifier;

// <local or schema qualified name> ::= [ <local or schema qualifier> <period> ] <qualified identifier>
local_or_schema_qualified_name : (local_or_schema_qualifier PERIOD)? qualified_identifier;

// <local or schema qualifier> ::= <schema name> | <local qualifier>
local_or_schema_qualifier : {schema_name} schema_name | {local_qualifier} local_qualifier;

// <qualified identifier> ::= <identifier>
qualified_identifier : identifier;

// <column name> ::= <identifier>
column_name : identifier;

// <correlation name> ::= <identifier>
correlation_name : identifier;

// <query name> ::= <identifier>
query_name : identifier;

// SQL-client module name> ::= <identifier>
sql_client_module_name : identifier;

// <procedure name> ::= <identifier>
procedure_name : identifier;

// <schema qualified routine name> ::= <schema qualified name>
schema_qualified_routine_name : schema_qualified_name;

// <method name> ::= <identifier>
method_name : identifier;

// <specific name> ::= <schema qualified name>
specific_name : schema_qualified_name;

// <cursor name> ::= <local qualified name>
cursor_name : local_qualified_name;

// <local qualified name> ::= [ <local qualifier> <period> ] <qualified identifier>
local_qualified_name : (local_qualifier PERIOD)? qualified_identifier;

// <local qualifier> ::= MODULE
local_qualifier : t_module;

// <host parameter name> ::= <colon> <identifier>
host_parameter_name : COLON identifier;

// <SQL parameter name> ::= <identifier>
sql_parameter_name : identifier;

// <constraint name> ::= <schema qualified name>
constraint_name : schema_qualified_name;

// <external routine name> ::= <identifier> | <character string literal> 
external_routine_name : {identifier} identifier | {character_string_literal} character_string_literal;

// <trigger name> ::= <schema qualified name>
trigger_name : schema_qualified_name;

// <collation name> ::= <schema qualified name>
collation_name : schema_qualified_name;

// <character set name> ::=[ <schema name> <period> ] <SQL language identifier>
character_set_name : (schema_name PERIOD)? sql_language_identifier;

// <transliteration name> ::= <schema qualified name>
transliteration_name : schema_qualified_name;

// <transcoding name> ::= <schema qualified name>
transcoding_name : schema_qualified_name;

// <schema-resolved user-defined type name> ::= <user-defined type name>
schema_resolved_user_defined_type_name : user_defined_type_name;

// <user-defined type name> ::= [ <schema name> <period> ] <qualified identifier>
user_defined_type_name : (schema_name PERIOD)? qualified_identifier;

// <attribute name> ::= <identifier>
attribute_name : identifier;

// <field name> ::= <identifier>
field_name : identifier;

// <savepoint name> ::= <identifier>
savepoint_name : identifier;

// <sequence generator name> ::= <schema qualified name>
sequence_generator_name : schema_qualified_name;

// <role name> ::= <identifier>
role_name : identifier;

// <user identifier> ::= <identifier>
user_identifier : identifier;

// <connection name> ::= <simple value specification>
connection_name : simple_value_specification;

// <SQL-server name> ::= <simple value specification>
sql_server_name : simple_value_specification;

// <connection user name> ::= <simple value specification>
connection_user_name : simple_value_specification;

// <SQL statement name> ::= <statement name> | <extended statement name>
sql_statement_name : {statement_name} statement_name | {extended_statement_name} extended_statement_name;

// <statement name> ::= <identifier>
statement_name : identifier;

// <extended statement name> ::= [ <scope option> ] <simple value specification>
extended_statement_name : scope_option? simple_value_specification;

// <dynamic cursor name> ::= <cursor name> | <extended cursor name>
dynamic_cursor_name : {cursor_name} cursor_name | {extended_cursor_name} extended_cursor_name;

// <extended cursor name> ::= [ <scope option> ] <simple value specification>
extended_cursor_name : scope_option? simple_value_specification;

// <descriptor name> ::= <non-extended descriptor name> | <extended descriptor name>
descriptor_name : {non_extended_descriptor_name} non_extended_descriptor_name | {extended_descriptor_name} extended_descriptor_name;

// <non-extended descriptor name> ::= <identifier>
non_extended_descriptor_name : identifier;

// <extended descriptor name> ::= [ <scope option> ] <simple value specification>
extended_descriptor_name : scope_option? simple_value_specification;

// <scope option> ::= GLOBAL | LOCAL
scope_option : {global} t_global | {local} t_local;

// <window name> ::= <identifier>
window_name : identifier;

// <table definition> ::= CREATE [ <table scope> ] TABLE <table name> <table contents source> [ WITH <system versioning clause> ] [ ON COMMIT <table commit action> ROWS ]
// <table contents source> ::= <table element list> | <typed table clause> | <as subquery clause>
// <table scope> ::= <global or local> TEMPORARY
// <global or local> ::= GLOBAL | LOCAL
// <system versioning clause> ::= SYSTEM VERSIONING
// <table commit action> ::= PRESERVE | DELETE
table_commit_action : {preserve} t_preserve | {delete} t_delete;

// <table element list> ::= <left paren> <table element> [ { <comma> <table element> }... ] <right paren>
table_element_list : LEFT_PAREN table_element (COMMA table_element)* RIGHT_PAREN;

// <table element> ::= <column definition> | <table PERIOD definition> | <table constraint definition> | <like clause>
table_element : {column} column_definition | {PERIOD} table_period_definition | {constraint} table_constraint_definition | {like} like_clause;

// <typed table clause> ::= OF <path-resolved user-defined type name> [ <subtable clause> ] [ <typed table element list> ]
// <typed table element list> ::= <left paren> <typed table element> [ { <comma> <typed table element> }... ] <right paren>
// <typed table element> ::= <column options> | <table constraint definition> | <self-referencing column specification>
typed_table_element : {column} column_options | {table} table_constraint_definition | {self} self_referencing_column_specification;

// <self-referencing column specification> ::= REF IS <self-referencing column name> [ <reference generation> ]
self_referencing_column_specification : t_ref t_is self_referencing_column_name reference_generation?;

// <reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED
reference_generation : {system} t_system t_generated | {user} t_user t_generated | {derived} t_derived;

// <self-referencing column name> ::= <column name>
self_referencing_column_name : column_name;

// <column options> ::= <column name> WITH OPTIONS <column option list>
column_options : column_name t_with t_options column_option_list;

// <column option list> ::= [ <scope clause> ] [ <default clause> ] [ <column constraint definition>... ]
column_option_list : scope_clause? default_clause? column_constraint_definition*;

// <subtable clause> ::= UNDER <supertable clause>
// <supertable clause> ::= <supertable name>
// <supertable name> ::= <table name>
// <like clause> ::= LIKE <table name> [ <like options> ]
like_clause : t_like table_name like_options?;

// <like options> ::= <like option>...
like_options : like_option+;

// <like option> ::= <identity option> | <column default option> | <generation option>
like_option : {identity} identity_option | {column} column_default_option | {generated} generation_option;

// <identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY
identity_option : {including} t_including t_identity | {excluding} t_excluding t_identity;

// <column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS
column_default_option : {including} t_including t_defaults | {excluding} t_excluding t_defaults;

// <generation option> ::= INCLUDING GENERATED | EXCLUDING GENERATED
generation_option : {including} t_including t_generated | {excluding} t_excluding t_generated;

// <as subquery clause> ::= [ <left paren> <column name list> <right paren> ] AS <table subquery> <with or without data>
// <with or without data> ::= WITH NO DATA | WITH DATA
// <table PERIOD definition> ::= <system or application time PERIOD specification> <left paren> <PERIOD begin column name> <comma> <PERIOD end column name> <right paren>
// <system or application time PERIOD specification> ::= <system time PERIOD specification> | <application time PERIOD specification>
system_or_application_time_period_specification : {system} system_time_period_specification | {application} application_time_period_specification;

// <system time PERIOD specification> ::= PERIOD FOR SYSTEM_TIME
system_time_period_specification : t_period t_for t_system_time;

// <application time PERIOD specification> ::= PERIOD FOR <application time PERIOD name>
application_time_period_specification : t_period t_for application_time_period_name;

// <application time PERIOD name> ::= <identifier>
application_time_period_name : identifier;

// <PERIOD begin column name> ::= <column name>
// <PERIOD end column name> ::= <column name>

// <value expression primary> ::= <parenthesized value expression> | <nonparenthesized value expression primary>
value_expression_primary : parenthesized_value_expression | nonparenthesized_value_expression_primary;

// <parenthesized value expression> ::= <left paren> <value expression> <right paren>
parenthesized_value_expression : LEFT_PAREN value_expression RIGHT_PAREN;

// <nonparenthesized value expression primary> ::= <unsigned value specification> | <column reference> | <set function specification>
//    | <window function> | <nested window function> | <scalar subquery> | <case expression> | <cast specification> | <field reference>
//    | <subtype treatment> | <method invocation> | <static method invocation> | <new specification> | <attribute or method reference>
//    | <reference resolution> | <collection value constructor> | <array element reference> | <multiset element reference>
//    | <next value expression> | <routine invocation>
nonparenthesized_value_expression_primary : {unsigned} unsigned_value_specification | {column} column_reference | {set} set_function_specification
  | {window} window_function | {nested} nested_window_function | {scalar} scalar_subquery | {case} case_expression | {cast} cast_specification | {field} field_reference
  | {subtype} subtype_treatment | {method} method_invocation | {static} static_method_invocation | {new} new_specification | {attribute} attribute_or_method_reference
  | {reference} reference_resolution | {collection} collection_value_constructor | {array} array_element_reference | {multiset} multiset_element_reference
  | {next} next_value_expression | {routine} routine_invocation;

// <collection value constructor> ::= <array value constructor> | <multiset value constructor>
collection_value_constructor : {array} array_value_constructor | {multiset} multiset_value_constructor;

// <interval value expression> ::= <interval term> | <interval value expression 1> <plus sign> <interval term 1>
//   | <interval value expression 1> <minus sign> <interval term 1>
//   | <left paren> <datetime value expression> <minus sign> <datetime term> <right paren> <interval qualifier>
interval_value_expression : {term} interval_term | {plus} interval_value_expression1 PLUS_SIGN interval_term1
   | {minus} interval_value_expression1 MINUS_SIGN interval_term1
   | {paren} LEFT_PAREN datetime_value_expression MINUS_SIGN datetime_term RIGHT_PAREN interval_qualifier;

// <interval term> ::= <interval factor> | <interval term 2> <ASTERISK> <factor> | <interval term 2> <SOLIDUS> <factor> | <term> <ASTERISK> <interval factor>
interval_term : {factor} interval_factor | {ASTERISK} interval_term2 ASTERISK factor | {SOLIDUS} interval_term2 SOLIDUS factor | {term} term ASTERISK interval_factor ;

// <interval factor> ::= [ <sign> ] <interval primary>
interval_factor : sign? interval_primary;

// <interval primary> ::= <value expression primary> [ <interval qualifier> ] | <interval value function>
interval_primary : {expression} value_expression_primary interval_qualifier? | {function} interval_value_function;

// <interval value expression 1> ::= <interval value expression>
interval_value_expression1 : interval_value_expression;

// <interval term 1> ::= <interval term>
interval_term1 : interval_term;

// <interval term 2> ::= <interval term>
interval_term2 : interval_term;

// <datetime value function> ::= <current date value function> | <current time value function> | <current timestamp value function> | <current local time value function> | <current local timestamp value function>
datetime_value_function : {date} current_date_value_function | {time} current_time_value_function | {timestamp} current_timestamp_value_function
   | {local_time} current_local_time_value_function | {local_timestamp} current_local_timestamp_value_function;

// <current date value function> ::= CURRENT_DATE
current_date_value_function : t_current_date;

// <current time value function> ::= CURRENT_TIME [ <left paren> <time precision> <right paren> ]
current_time_value_function : t_current_time (LEFT_PAREN time_precision RIGHT_PAREN)?;

// <current local time value function> ::= LOCALTIME [ <left paren> <time precision> <right paren> ]
current_local_time_value_function : t_localtime (LEFT_PAREN time_precision RIGHT_PAREN)?;

// <current timestamp value function> ::= CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
current_timestamp_value_function : t_current_timestamp (LEFT_PAREN timestamp_precision RIGHT_PAREN)?;

// <current local timestamp value function> ::= LOCALTIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
current_local_timestamp_value_function : t_localtimestamp (LEFT_PAREN timestamp_precision RIGHT_PAREN)?;

// <scalar subquery> ::= <subquery>
scalar_subquery : subquery;

// <row subquery> ::= <subquery>
row_subquery : subquery;

// <table subquery> ::= <subquery>
table_subquery : subquery;

// <subquery> ::= <left paren> <query expression> <right paren>
subquery : LEFT_PAREN query_expression RIGHT_PAREN;

// <search or cycle clause> ::= <search clause> | <cycle clause> | <search clause> <cycle clause>
search_or_cycle_clause : {search} search_clause | {cycle} cycle_clause | {both} search_clause cycle_clause;
 
// <search clause> ::= SEARCH <recursive search order> SET <sequence column>
search_clause : t_search recursive_search_order t_set sequence_column;

// <recursive search order> ::= DEPTH FIRST BY <column name list> | BREADTH FIRST BY <column name list>
recursive_search_order : {depth_first} t_depth t_first t_by column_name_list | {breadth_first} t_breadth t_first t_by column_name_list;

// <sequence column> ::= <column name>
sequence_column : column_name;

// <cycle clause> ::= CYCLE <cycle column list> SET <cycle mark column> TO <cycle mark value> DEFAULT <non-cycle mark value> USING <path column>
cycle_clause : t_cycle cycle_column_list t_set cycle_mark_column t_to cycle_mark_value t_default non_cycle_mark_value t_using path_column;

// <cycle column list> ::= <cycle column> [ { <comma> <cycle column> }... ]
cycle_column_list : cycle_column (COMMA cycle_column)*;

// <cycle column> ::= <column name>
cycle_column : column_name;

// <cycle mark column> ::= <column name>
cycle_mark_column : column_name;

// <path column> ::= <column name>
path_column : column_name;

// <cycle mark value> ::= <value expression>
cycle_mark_value : value_expression;

// <non-cycle mark value> ::= <value expression>
non_cycle_mark_value : value_expression;

// <query specification> ::= SELECT [ <set quantifier> ] <select list> <table expression>
query_specification : t_select set_quantifier? select_list table_expression;

// <select list> ::= <ASTERISK> | <select sublist> [ { <comma> <select sublist> }... ]
select_list : {ASTERISK} ASTERISK | {sublist} select_sublist (COMMA select_sublist)*;

// <select sublist> ::= <derived column> | <qualified ASTERISK>
select_sublist : {derived} derived_column | {qualified} qualified_asterisk;

// <qualified ASTERISK> ::= <asterisked identifier chain> <period> <ASTERISK> | <all fields reference>
qualified_asterisk : {ASTERISK} asterisked_identifier_chain PERIOD ASTERISK | {all} all_fields_reference;

// <asterisked identifier chain> ::= <asterisked identifier> [ { <period> <asterisked identifier> }... ]
asterisked_identifier_chain : asterisked_identifier (PERIOD asterisked_identifier)*;
 
// <asterisked identifier> ::= <identifier>
asterisked_identifier : identifier;

// <derived column> ::= <value expression> [ <as clause> ]
derived_column : value_expression as_clause?;

// <as clause> ::= [ AS ] <column name>
as_clause : t_as? column_name;

// <all fields reference> ::= <value expression primary> <period> <ASTERISK> [ AS <left paren> <all fields column name list> <right paren> ]
all_fields_reference : value_expression_primary PERIOD ASTERISK (t_as LEFT_PAREN all_fields_column_name_list RIGHT_PAREN)?;

// <all fields column name list> ::= <column name list>
all_fields_column_name_list : column_name_list;

// <table value constructor> ::= VALUES <row value expression list>
table_value_constructor : t_values row_value_expression_list;

// <row value expression list> ::= <table row value expression> [ { <comma> <table row value expression> }... ]
row_value_expression_list : table_row_value_expression (COMMA table_row_value_expression)*;

// <contextually typed table value constructor> ::= VALUES <contextually typed row value expression list>
contextually_typed_table_value_constructor : t_values contextually_typed_row_value_expression_list;

// <contextually typed row value expression list> ::= <contextually typed row value expression> [ { <comma> <contextually typed row value expression> }... ]
contextually_typed_row_value_expression_list : contextually_typed_row_value_expression (COMMA contextually_typed_row_value_expression)*;

// <sort specification list> ::= <sort specification> [ { <comma> <sort specification> }... ]
sort_specification_list : sort_specification (COMMA sort_specification)*;

// <sort specification> ::= <sort key> [ <ordering specification> ] [ <null ordering> ]
sort_specification : sort_key ordering_specification? null_ordering?;

// <sort key> ::= <value expression>
sort_key : value_expression;

// <ordering specification> ::= ASC | DESC
ordering_specification : {asc} t_asc | {desc} t_desc;

// <null ordering> ::= NULLS FIRST | NULLS LAST
null_ordering : {first} t_nulls t_first | {last} t_nulls t_last;

// <joined table> ::= <cross join> | <qualified join> | <natural join>
joined_table : {cross} cross_join | {qualified} qualified_join | {natural} natural_join;

// <where clause> ::= WHERE <search condition>
where_clause : t_where search_condition;

// <cross join> ::= <table reference> CROSS JOIN <table factor>
cross_join : table_reference t_cross t_join table_factor;

// <qualified join> ::= { <table reference> | <partitioned join table> } [ <join type> ] JOIN { <table reference> | <partitioned join table> } <join specification>
qualified_join : (table_reference | partitioned_join_table) join_type? t_join (table_reference | partitioned_join_table) join_specification;

// <partitioned join table> ::= <table factor> PARTITION BY <partitioned join column reference list>
partitioned_join_table : table_factor t_partition t_by partitioned_join_column_reference_list;

// <partitioned join column reference list> ::= <left paren> <partitioned join column reference> [ { <comma> <partitioned join column reference> }... ] <right paren>
partitioned_join_column_reference_list : LEFT_PAREN partitioned_join_column_reference (COMMA partitioned_join_column_reference)* RIGHT_PAREN;

// <partitioned join column reference> ::= <column reference>
partitioned_join_column_reference : column_reference;

// <natural join> ::= { <table reference> | <partitioned join table> } NATURAL [ <join type> ] JOIN { <table factor> | <partitioned join table> }
natural_join : (table_reference | partitioned_join_table) t_natural join_type? t_join (table_reference | partitioned_join_table);

// <join specification> ::= <join condition> | <named columns join>
join_specification : {condition} join_condition | {named} named_columns_join; 

// <join condition> ::= ON <search condition>
join_condition : t_on search_condition;

// <named columns join> ::= USING <left paren> <join column list> <right paren>
named_columns_join : t_using LEFT_PAREN join_column_list RIGHT_PAREN;

// <join type> ::= INNER | <outer join type> [ OUTER ]
join_type : {inner} t_inner | {outer} outer_join_type t_outer?;

// <outer join type> ::= LEFT | RIGHT | FULL
outer_join_type : {left} t_left | {right} t_right | {full} t_full;

// <join column list> ::= <column name list>
join_column_list : column_name_list;

// <numeric value expression> ::= <term> | <numeric value expression> <plus sign> <term> | <numeric value expression> <minus sign> <term>
numeric_value_expression : {term} term | {plus}  numeric_value_expression PLUS_SIGN term | {minus} numeric_value_expression MINUS_SIGN term;

// <term> ::= <factor> | <term> <ASTERISK> <factor> | <term> <SOLIDUS> <factor>
term : {factor} factor | {mult} term ASTERISK factor | {div} term SOLIDUS factor;
 
// <factor> ::= [ <sign> ] <numeric primary>
factor : sign? numeric_primary;

// <numeric primary> ::= <value expression primary> | <numeric value function>
numeric_primary : {expression} value_expression_primary | {function} numeric_value_function;

// <trigger definition> ::= CREATE TRIGGER <trigger name> <trigger action time> <trigger event> ON <table name> [ REFERENCING <transition table or variable list> ] <triggered action>
// <trigger action time> ::= BEFORE | AFTER | INSTEAD OF
// <trigger event> ::= INSERT | DELETE | UPDATE [ OF <trigger column list> ]
// <trigger column list> ::= <column name list>
// <triggered action> ::= [ FOR EACH { ROW | STATEMENT } ] [ <triggered when clause> ] <triggered SQL statement>
// <triggered when clause> ::= WHEN <left paren> <search condition> <right paren>
// <triggered SQL statement> ::= <SQL procedure statement> | BEGIN ATOMIC { <SQL procedure statement> <SEMICOLON> }... END
// <transition table or variable list> ::= <transition table or variable>...
// <transition table or variable> ::= OLD [ ROW ] [ AS ] <old transition variable name> | NEW [ ROW ] [ AS ] <new transition variable name> | OLD TABLE [ AS ] <old transition table name> | NEW TABLE [ AS ] <new transition table name>
// <old transition table name> ::= <transition table name>
// <new transition table name> ::= <transition table name>
// <transition table name> ::= <identifier>
transition_table_name : identifier;

// <old transition variable name> ::= <correlation name>
// <new transition variable name> ::= <correlation name>
new_transition_variable_name : correlation_name;

// <string value expression> ::= <character value expression> | <binary value expression>
string_value_expression : {character} character_value_expression | {binary} binary_value_expression;

// <character value expression> ::= <concatenation> | <character factor>
character_value_expression : {concat} concatenation | {factor} character_factor;

// <concatenation> ::= <character value expression> <concatenation operator> <character factor>
concatenation : character_value_expression CONCATENATION_OPERATOR character_factor;

// <character factor> ::= <character primary> [ <collate clause> ]
character_factor : character_primary collate_clause?;

// <character primary> ::= <value expression primary> | <string value function>
character_primary : {expression} value_expression_primary | {function} string_value_function;

// <binary value expression> ::= <binary concatenation> | <binary factor>
binary_value_expression : {concat} binary_concatenation | {factor} binary_factor; 

// <binary factor> ::= <binary primary>
binary_factor : binary_primary;

// <binary primary> ::= <value expression primary> | <string value function>
binary_primary : {expression} value_expression_primary | {function} string_value_function;

// <binary concatenation> ::= <binary value expression> <concatenation operator> <binary factor>
binary_concatenation : binary_value_expression CONCATENATION_OPERATOR binary_factor;

// <array value expression> ::= <array concatenation> | <array primary>
array_value_expression : {concat} array_concatenation | {primary} array_primary;

// <array concatenation> ::= <array value expression 1> <concatenation operator> <array primary>
array_concatenation : array_value_expression1 CONCATENATION_OPERATOR array_primary;

// <array value expression 1> ::= <array value expression>
array_value_expression1 : array_value_expression;

// <array primary> ::= <array value function> | <value expression primary>
array_primary : {function} array_value_function | {expression} value_expression_primary;

// <multiset value expression> ::= <multiset term> | <multiset value expression> MULTISET UNION [ ALL | DISTINCT ] <multiset term> | <multiset value expression> MULTISET EXCEPT [ ALL | DISTINCT ] <multiset term>
multiset_value_expression : {term} multiset_term
    | {union} multiset_value_expression t_multiset t_union (t_all | t_distinct)? multiset_term
    | {except} multiset_value_expression t_multiset t_except (t_all | t_distinct)? multiset_term;

// <multiset term> ::= <multiset primary> | <multiset term> MULTISET INTERSECT [ ALL | DISTINCT ] <multiset primary>
multiset_term : {primary} multiset_primary | {intersect} multiset_term t_multiset t_intersect (t_all | t_distinct)? multiset_primary;

// <multiset primary> ::= <multiset value function> | <value expression primary>
multiset_primary : {function} multiset_value_function |  {expression} value_expression_primary;

// <row value constructor> ::= <common value expression> | <boolean value expression> | <explicit row value constructor>
row_value_constructor : {common} common_value_expression | {boolean} boolean_value_expression | {explicit} explicit_row_value_constructor;

// <explicit row value constructor> ::= <left paren> <row value constructor element> <comma> <row value constructor element list> <right paren>
//   | ROW <left paren> <row value constructor element list> <right paren> | <row subquery>
explicit_row_value_constructor : {list2} LEFT_PAREN row_value_constructor_element COMMA row_value_constructor_element_list RIGHT_PAREN
    | {list1} t_row LEFT_PAREN row_value_constructor_element_list RIGHT_PAREN
    | {subquery} row_subquery;

// <row value constructor element list> ::= <row value constructor element> [ { <comma> <row value constructor element> }... ]
row_value_constructor_element_list : row_value_constructor_element (COMMA row_value_constructor_element)*;

// <row value constructor element> ::= <value expression>
row_value_constructor_element : value_expression;

// <contextually typed row value constructor> ::= <common value expression> | <boolean value expression> | <contextually typed value specification> | <left paren> <contextually typed value specification> <right paren> | <left paren> <contextually typed row value constructor element> <comma> <contextually typed row value constructor element list> <right paren> | ROW <left paren> <contextually typed row value constructor element list> <right paren>
contextually_typed_row_value_constructor : {common} common_value_expression | {boolean} boolean_value_expression | {specification} contextually_typed_value_specification
    | {paren_spec} LEFT_PAREN contextually_typed_value_specification RIGHT_PAREN
    | {list} LEFT_PAREN contextually_typed_row_value_constructor_element COMMA contextually_typed_row_value_constructor_element_list RIGHT_PAREN
    | {row} t_row LEFT_PAREN contextually_typed_row_value_constructor_element_list RIGHT_PAREN;

// <contextually typed row value constructor element list> ::= <contextually typed row value constructor element> [ { <comma> <contextually typed row value constructor element> }... ]
contextually_typed_row_value_constructor_element_list : contextually_typed_row_value_constructor_element (COMMA contextually_typed_row_value_constructor_element)*;

// <contextually typed row value constructor element> ::= <value expression> | <contextually typed value specification>
contextually_typed_row_value_constructor_element : {value} value_expression | contextually_typed_value_specification;

// <row value constructor predicand> ::= <common value expression> | <boolean predicand> | <explicit row value constructor>
row_value_constructor_predicand : {common} common_value_expression | {explicit} explicit_row_value_constructor | {boolean} boolean_predicand;

// literals

// <literal> ::= <signed numeric literal> | <general literal>
literal : {signed_numeric_literal} signed_numeric_literal | {general_literal} general_literal;

// <unsigned literal> ::= <unsigned numeric literal> | <general literal>
unsigned_literal : {unsigned_numeric_literal} unsigned_numeric_literal | {general_literal} general_literal;

// <general literal> ::= <character string literal> | <national character string literal> | <Unicode character string literal> | <binary string literal>
// | <datetime literal> | <interval literal> | <boolean literal>
general_literal : {character_string_literal} character_string_literal | {national_character_string_literal}  national_character_string_literal
  | {unicode_character_string_literal} unicode_character_string_literal | {binary_string_literal} binary_string_literal
  | {datetime_literal} datetime_literal | {interval_literal} interval_literal | {boolean_literal} boolean_literal;

// <character string literal> ::= [ <introducer><character set specification> ] <quote> [ <character representation>... ] <quote> [ { <separator> <quote> [ <character representation>... ] <quote> }... ]
character_string_literal : (introducer character_set_specification)? QUOTE character_representation* QUOTE (separator QUOTE character_representation* QUOTE)*;

// see spec document 
character_set_specification : {utf8} t_utf8 | {utf16} t_utf16;

// <introducer> ::= <UNDERSCORE> 
introducer : UNDERSCORE;

//<character representation> ::= <nonquote character> | <quote symbol>
character_representation : {nonquote_character} nonquote_character | {quote_symbol} quote_symbol;

// <quote symbol> ::= <quote><quote>
quote_symbol : QUOTE QUOTE;

// <national character string literal> ::= N <quote> [ <character representation>... ] <quote> [ { <separator> <quote> [ <character representation>... ] <quote> }... ]
national_character_string_literal : n QUOTE character_representation* QUOTE (separator QUOTE character_representation* QUOTE)*;

// <Unicode character string literal> ::= [ <introducer><character set specification> ] U<AMPERSAND><quote> [ <Unicode representation>... ] <quote> [ { <separator> <quote> [ <Unicode representation>... ] <quote> }... ] <Unicode escape specifier>
unicode_character_string_literal : (introducer character_set_specification)? u AMPERSAND QUOTE unicode_representation* QUOTE  (separator QUOTE unicode_representation* QUOTE)* unicode_escape_specifier;

// <Unicode representation> ::= <character representation> | <Unicode escape value>
unicode_representation : {character_representation} character_representation | {unicode_escape_value} unicode_escape_value;

// <binary string literal> ::= X <quote> [ <SPACE>... ] [ { <hexit> [ <SPACE>... ] <hexit> [ <SPACE>... ] }... ] <quote> [ { <separator> <quote> [ <SPACE>... ] [ { <hexit> [ <SPACE>... ] <hexit> [ <SPACE>... ] }... ] <quote> }... ]
binary_string_literal : x QUOTE SPACE* (hexit SPACE* hexit SPACE*)* QUOTE (separator QUOTE SPACE* (hexit SPACE* hexit SPACE*)* QUOTE)*;

// <hexit> ::= <digit> | A | B | C | D | E | F | a | b | c | d | e | f
hexit : {digit} digit | {a} a | {b} b | {c} c | {d} d | {e} e | {f} f;

// <signed numeric literal> ::= [ <sign> ] <unsigned numeric literal>
signed_numeric_literal : sign? unsigned_numeric_literal;

// <unsigned numeric literal> ::= <exact numeric literal> | <approximate numeric literal>
unsigned_numeric_literal : {exact_numeric_literal} exact_numeric_literal | {approximate_numeric_literal} approximate_numeric_literal;

//<exact numeric literal> ::= <unsigned integer> [ <period> [ <unsigned integer> ] ] | <period> <unsigned integer>
exact_numeric_literal :  unsigned_integer (PERIOD unsigned_integer?)? | (PERIOD unsigned_integer?)?;

// <sign> ::= <plus sign> | <minus sign>
 sign : {PLUS_SIGN} PLUS_SIGN | {MINUS_SIGN} MINUS_SIGN;

// <approximate numeric literal> ::= <mantissa> E <exponent>
approximate_numeric_literal : mantissa e exponent;

// <mantissa> ::= <exact numeric literal>
mantissa : exact_numeric_literal;

// <exponent> ::= <signed integer>
exponent : signed_integer;

// <signed integer> ::= [ <sign> ] <unsigned integer>
signed_integer : sign? unsigned_integer;

// <unsigned integer> ::= <digit>...
unsigned_integer : digit+;

// <datetime literal> ::= <date literal> | <time literal> | <timestamp literal>
datetime_literal : {date_literal} date_literal | {time_literal} time_literal | {timestamp_literal} timestamp_literal;

// <date literal> ::= DATE <date string>
date_literal : t_date date_string;

// <time literal> ::= TIME <time string>
time_literal : t_time time_string;

// <timestamp literal> ::= TIMESTAMP <timestamp string>
timestamp_literal : t_timestamp timestamp_string;

// <date string> ::= <quote> <unquoted date string> <quote>
date_string : QUOTE unquoted_date_string QUOTE;

// <time string> ::= <quote> <unquoted time string> <quote>
time_string : QUOTE unquoted_time_string QUOTE;

// <timestamp string> ::= <quote> <unquoted timestamp string> <quote>
timestamp_string : QUOTE unquoted_timestamp_string QUOTE;

// <time zone interval> ::= <sign> <hours value> <COLON> <minutes value>
time_zone_interval : sign hours_value COLON minutes_value;

// <date value> ::= <years value> <minus sign> <months value> <minus sign> <days value>
date_value : hours_value COLON minutes_value COLON seconds_value;

// <time value> ::= <hours value> <COLON> <minutes value> <COLON> <seconds value>
time_value : hours_value COLON minutes_value COLON seconds_value;

// <interval literal> ::= INTERVAL [ <sign> ] <interval string> <interval qualifier>
interval_literal : t_interval sign? interval_qualifier;

// <interval string> ::= <quote> <unquoted interval string> <quote>
interval_string : QUOTE unquoted_interval_string QUOTE;

// <unquoted date string> ::= <date value>
unquoted_date_string : date_value;

// <unquoted time string> ::= <time value> [ <time zone interval> ]
unquoted_time_string : time_value time_zone_interval?;

// <unquoted timestamp string> ::= <unquoted date string> <SPACE> <unquoted time string>
unquoted_timestamp_string : unquoted_date_string SPACE unquoted_time_string;

// <unquoted interval string> ::= [ <sign> ] { <year-month literal> | <day-time literal> }
unquoted_interval_string : sign? (year_month_literal | day_time_literal);

// <year-month literal> ::= <years value> [ <minus sign> <months value> ] | <months value>
year_month_literal : {years_month} years_value (MINUS_SIGN months_value)? | {month} months_value;

// <day-time literal> ::= <day-time interval> | <time interval>
day_time_literal : {day_time_interval} day_time_interval | {time_interval} time_interval;

// <day-time interval> ::= <days value> [ <SPACE> <hours value> [ <COLON> <minutes value> [ <COLON> <seconds value> ] ] ]
day_time_interval : days_value (SPACE hours_value (COLON minutes_value (COLON seconds_value)?)?)?;

// <time interval> ::= <hours value> [ <COLON> <minutes value> [ <COLON> <seconds value> ] ] | <minutes value> [ <COLON> <seconds value> ] | <seconds value>
time_interval : {hours_minutes} hours_value (COLON minutes_value (COLON seconds_value)?)? | {minutes_seconds} minutes_value (COLON seconds_value)? | {seconds_value} seconds_value;

// <years value> ::= <datetime value>
years_value : datetime_value;

// <months value> ::= <datetime value>
months_value : datetime_value;

// <days value> ::= <datetime value>
days_value : datetime_value;

// <hours value> ::= <datetime value>
hours_value : datetime_value;

// <minutes value> ::= <datetime value>
minutes_value : datetime_value;

// <seconds value> ::= <seconds integer value> [ <period> [ <seconds fraction> ] ]
seconds_value : seconds_integer_value milliseconds_value?;

milliseconds_value : PERIOD seconds_fraction?;

// <seconds integer value> ::= <unsigned integer>
seconds_integer_value : unsigned_integer;

// <seconds fraction> ::= <unsigned integer>
seconds_fraction : unsigned_integer;

// <datetime value> ::= <unsigned integer>
datetime_value : unsigned_integer;

// <boolean literal> ::= TRUE | FALSE | UNKNOWN
boolean_literal : {true} t_true | {false} t_false | {unknown} t_unknown;

// <SQL parameter reference> ::= <basic identifier chain>
sql_parameter_reference : basic_identifier_chain;

// <column reference> ::= <basic identifier chain> | MODULE <period> <qualified identifier> <period> <column name>
column_reference : {basic} basic_identifier_chain | {module} t_module PERIOD qualified_identifier PERIOD column_name;

// <SQL terminal character> ::= <SQL language character>
sql_terminal_character : sql_language_character;
 
// <SQL language character> ::= <simple Latin letter> | <digit> | <SQL special character>
sql_language_character : {simple_latin_letter} simple_latin_letter | {digit} digit | {sql_special_character} sql_special_character;

// <simple Latin letter> ::= <simple Latin upper case letter> | <simple Latin lower case letter>
simple_latin_letter : {simple_latin_upper_case_letter} simple_latin_upper_case_letter | {simple_latin_lower_case_letter} simple_latin_lower_case_letter;

// <SQL special character> ::= <sp> | <double quote> | <PERCENT> | <AMPERSAND> | <quote> | <left paren>c| <right paren>c| <ASTERISK> | <plus sign> | <comma> | <minus sign> | <period>
// | <SOLIDUS> | <COLON> | <SEMICOLON> | <less than operator> | <equals operator> | <greater than operator> | <question mark> | <left bracket> | <right bracket> | <CIRCUMFLEX> | <UNDERSCORE> | <vertical bar> | <left brace> | <right brace>
sql_special_character : 
    {SPACE} SPACE | {DOUBLE_QUOTE} DOUBLE_QUOTE | {DOUBLE_QUOTE} DOUBLE_QUOTE | {PERCENT} PERCENT | {AMPERSAND} AMPERSAND
  | {QUOTE} QUOTE | {QUOTE} QUOTE | {LEFT_PAREN} LEFT_PAREN | {RIGHT_PAREN} RIGHT_PAREN | {ASTERISK} ASTERISK | {PLUS_SIGN} PLUS_SIGN
  | {COMMA} COMMA | {MINUS_SIGN} MINUS_SIGN | {PERIOD} PERIOD | {SOLIDUS} SOLIDUS | {COLON} COLON | {COLON} COLON | {SEMICOLON} SEMICOLON
  | {LESS_THAN_OPERATOR} LESS_THAN_OPERATOR | {EQUALS_OPERATOR} EQUALS_OPERATOR | {GREATER_THAN_OPERATOR} GREATER_THAN_OPERATOR
  | {QUESTION_MARK} QUESTION_MARK | {LEFT_BRACKET} LEFT_BRACKET | {RIGHT_BRACKET} RIGHT_BRACKET | {CIRCUMFLEX} CIRCUMFLEX
  | {UNDERSCORE} UNDERSCORE | {VERTICAL_BAR} VERTICAL_BAR | {LEFT_BRACE} LEFT_BRACE | {RIGHT_BRACE} RIGHT_BRACE;

// <left bracket or trigraph> ::= <left bracket> | <left bracket trigraph>
left_bracket_or_trigraph : {LEFT_BRACKET} LEFT_BRACKET | {LEFT_BRACKET_TRIGRAPH} LEFT_BRACKET_TRIGRAPH;

// <right bracket or trigraph> ::= <right bracket> | <right bracket trigraph>
right_bracket_or_trigraph : {RIGHT_BRACKET} RIGHT_BRACKET | {RIGHT_BRACKET_TRIGRAPH} RIGHT_BRACKET_TRIGRAPH;

// <token> ::= <nondelimiter token> | <delimiter token>
token : {nondelimiter_token} nondelimiter_token | {delimiter_token} delimiter_token;

// <nondelimiter token> ::= <regular identifier> | <key word> | <unsigned numeric literal> | <national character string literal> | 
//    <binary string literal> | <large object length token> | <Unicode delimited identifier> | <Unicode character string literal> | <SQL language identifier>
nondelimiter_token : {regular_identifier} regular_identifier | {key_word} key_word | {unsigned_numeric_literal} unsigned_numeric_literal 
  | {national_character_string_literal} national_character_string_literal | {binary_string_literal} binary_string_literal 
  | {large_object_length_token} large_object_length_token | {unicode_delimited_identifier} unicode_delimited_identifier 
  | {unicode_character_string_literal} unicode_character_string_literal | {sql_language_identifier} sql_language_identifier;

// <regular identifier> ::= <identifier body>
regular_identifier : identifier_body;

// <identifier body> ::= <identifier start> [ <identifier part>... ]
identifier_body : identifier_start identifier_extend*;

// <identifier part> ::= <identifier start> | <identifier extend>
//identifier_part : {identifier_start} identifier_start | {identifier_extend} identifier_extend;

// <large object length token> ::= <digit>... <multiplier>
large_object_length_token : digit+ multiplier;

// <multiplier> ::= K | M | G | T | P
multiplier : {kilo} KILO | {mega} MEGA | {giga} GIGA | {tera} TERA | {peta} PETA;

//  <delimited identifier> ::= <double quote> <delimited identifier body> <double quote>
delimited_identifier : DOUBLE_QUOTE delimited_identifier_body DOUBLE_QUOTE;

//  <delimited identifier body> ::= <delimited identifier part>...
delimited_identifier_body : delimited_identifier_part+;

//  <delimited identifier part> ::= <nondoublequote character> | <doublequote symbol>
delimited_identifier_part : {nondoublequote_character} nondoublequote_character | {DOUBLEQUOTE_SYMBOL} DOUBLEQUOTE_SYMBOL;

//  <Unicode delimited identifier> ::= U<AMPERSAND><double quote> <Unicode delimiter body> <double quote> <Unicode escape specifier>
unicode_delimited_identifier : u AMPERSAND DOUBLE_QUOTE unicode_delimiter_body DOUBLE_QUOTE unicode_escape_specifier;

//  <Unicode escape specifier> ::= [ UESCAPE <quote><Unicode escape character><quote> ]
unicode_escape_specifier : (t_uescape QUOTE unicode_escape_character QUOTE)?;

//  <Unicode delimiter body> ::= <Unicode identifier part>...
unicode_delimiter_body : unicode_idenfitifer_part+ ;

//  <Unicode identifier part> ::= <delimited identifier part> | <Unicode escape value>
unicode_idenfitifer_part : {delimited_identifier_part} delimited_identifier_part | {unicode_escape_value} unicode_escape_value;

//  <Unicode escape value> ::= <Unicode 4 digit escape value> | <Unicode 6 digit escape value> | <Unicode character escape value>
unicode_escape_value : {unicode_four_digit_escape_value} unicode_four_digit_escape_value | {unicode_six_digit_escape_value} unicode_six_digit_escape_value 
  | {unicode_character_escape_value} unicode_character_escape_value;

//  <Unicode 4 digit escape value> ::= <Unicode escape character><hexit><hexit><hexit><hexit>
unicode_four_digit_escape_value : unicode_escape_character hexit hexit hexit hexit;


//  <Unicode 6 digit escape value> ::= <Unicode escape character><plus sign><hexit><hexit><hexit><hexit><hexit><hexit>
unicode_six_digit_escape_value : unicode_escape_character PLUS_SIGN hexit hexit hexit hexit hexit hexit;

//  <Unicode character escape value> ::= <Unicode escape character><Unicode escape character>
unicode_character_escape_value : unicode_escape_character unicode_escape_character1;

unicode_escape_character1 : unicode_escape_character;

//  <delimiter token> ::= <character string literal> | <date string> | <time string> | <timestamp string> | <interval string> | <delimited identifier>
//  | <SQL special character> | <not equals operator> | <greater than or equals operator> | <less than or equals operator> | 
//  <concatenation operator | <right arrow> | <left bracket trigraph> | <right bracket trigraph> | <double COLON> | <double PERIOD> | <named argument assignment token>
delimiter_token : {character_string_literal} character_string_literal | {date_string} date_string | {time_string} time_string 
  | {timestamp_string} timestamp_string | {interval_string} interval_string | {delimited_identifier} delimited_identifier
  | {sql_special_character} sql_special_character | {NOT_EQUALS_OPERATOR} NOT_EQUALS_OPERATOR | {GREATER_THAN_OR_EQUALS_OPERATOR} GREATER_THAN_OR_EQUALS_OPERATOR
  | {LESS_THAN_OR_EQUALS_OPERATOR} LESS_THAN_OR_EQUALS_OPERATOR | {CONCATENATION_OPERATOR} CONCATENATION_OPERATOR | {RIGHT_ARROW} RIGHT_ARROW
  | {LEFT_BRACKET_TRIGRAPH} LEFT_BRACKET_TRIGRAPH | {RIGHT_BRACKET_TRIGRAPH} RIGHT_BRACKET_TRIGRAPH | {DOUBLE_COLON} DOUBLE_COLON 
  | {DOUBLE_PERIOD} DOUBLE_PERIOD | {NAMED_ARGUMENT_ASSIGNMENT_TOKEN} NAMED_ARGUMENT_ASSIGNMENT_TOKEN;

//  <separator> ::= { <comment> | <white SPACE> }...
separator : (comment | white_space)+;

//  <comment> ::= <simple comment> | <bracketed comment>
comment : {simple_comment} simple_comment | {bracketed_comment} bracketed_comment;

//  <simple comment> ::= <simple comment introducer> [ <comment character>... ] <newline>
simple_comment : SIMPLE_COMMENT_INTRODUCER comment_character* newline;

//  <bracketed comment> ::= <bracketed comment introducer> <bracketed comment contents> <bracketed comment terminator>
bracketed_comment : BRACKETED_COMMENT_INTRODUCER bracketed_comment_contents BRACKETED_COMMENT_TERMINATOR;

//  <bracketed comment contents> ::= [ { <comment character> | <separator> }... ] !! See the Syntax Rules.
bracketed_comment_contents : (comment_character | separator)*;

// <comment character> ::= <nonquote character> | <quote>
comment_character : {nonquote_character} nonquote_character | {quote} QUOTE;

key_word : {reserved_word} reserved_word | {non_reserved_word} non_reserved_word;

non_reserved_word :
    {t_a} t_a | {t_absolute} t_absolute | {t_action} t_action | {t_ada} t_ada | {t_add} t_add | {t_admin} t_admin | {t_after} t_after | {t_always} t_always
  | {t_asc} t_asc | {t_assertion} t_assertion | {t_assignment} t_assignment | {t_attribute} t_attribute | {t_attributes} t_attributes | {t_before} t_before
  | {t_bernoulli} t_bernoulli | {t_breadth} t_breadth | {t_c} t_c | {t_cascade} t_cascade | {t_catalog} t_catalog | {t_catalog_name} t_catalog_name
  | {t_chain} t_chain | {t_character_set_catalog} t_character_set_catalog | {t_character_set_name} t_character_set_name | {t_character_set_schema} t_character_set_schema
  | {t_characteristics} t_characteristics | {t_characters} t_characters | {t_class_origin} t_class_origin | {t_cobol} t_cobol | {t_collation} t_collation
  | {t_collation_catalog} t_collation_catalog | {t_collation_name} t_collation_name | {t_collation_schema} t_collation_schema | {t_column_name} t_column_name
  | {t_COMMAnd_function} t_COMMAnd_function | {t_COMMAnd_function_code} t_COMMAnd_function_code | {t_committed} t_committed | {t_condition_number} t_condition_number
  | {t_connection} t_connection | {t_connection_name} t_connection_name | {t_constraint_catalog} t_constraint_catalog | {t_constraint_name} t_constraint_name
  | {t_constraint_schema} t_constraint_schema | {t_constraints} t_constraints | {t_constructor} t_constructor | {t_continue} t_continue | {t_cursor_name} t_cursor_name
  | {t_data} t_data | {t_datetime_interval_code} t_datetime_interval_code | {t_datetime_interval_precision} t_datetime_interval_precision
  | {t_defaults} t_defaults | {t_deferrable} t_deferrable | {t_deferred} t_deferred | {t_defined} t_defined | {t_definer} t_definer | {t_degree} t_degree
  | {t_depth} t_depth | {t_derived} t_derived | {t_desc} t_desc | {t_descriptor} t_descriptor | {t_diagnostics} t_diagnostics | {t_dispatch} t_dispatch
  | {t_domain} t_domain | {t_dynamic_function} t_dynamic_function | {t_dynamic_function_code} t_dynamic_function_code | {t_enforced} t_enforced
  | {t_exclude} t_exclude | {t_excluding} t_excluding | {t_expression} t_expression | {t_final} t_final | {t_first} t_first | {t_flag} t_flag | {t_following} t_following
  | {t_fortran} t_fortran | {t_found} t_found | {t_g} t_g | {t_general} t_general | {t_generated} t_generated | {t_go} t_go | {t_goto} t_goto | {t_granted} t_granted
  | {t_hierarchy} t_hierarchy | {t_ignore} t_ignore | {t_immediate} t_immediate | {t_immediately} t_immediately | {t_implementation} t_implementation
  | {t_including} t_including | {t_increment} t_increment | {t_initially} t_initially | {t_input} t_input | {t_instance} t_instance | {t_instantiable} t_instantiable
  | {t_instead} t_instead | {t_invoker} t_invoker | {t_isolation} t_isolation | {t_k} t_k | {t_key} t_key | {t_key_member} t_key_member | {t_key_type} t_key_type
  | {t_last} t_last | {t_length} t_length | {t_level} t_level | {t_locator} t_locator | {t_m} t_m | {t_map} t_map | {t_matched} t_matched | {t_maxvalue} t_maxvalue
  | {t_message_length} t_message_length | {t_message_octet_length} t_message_octet_length | {t_message_text} t_message_text | {t_minvalue} t_minvalue
  | {t_more} t_more | {t_mumps} t_mumps | {t_name} t_name | {t_names} t_names | {t_nesting} t_nesting | {t_next} t_next | {t_nfc} t_nfc | {t_nfd} t_nfd | {t_nfkc} t_nfkc
  | {t_nfkd} t_nfkd | {t_normalized} t_normalized | {t_nullable} t_nullable | {t_nulls} t_nulls | {t_number} t_number | {t_object} t_object | {t_octets} t_octets
  | {t_option} t_option | {t_options} t_options | {t_ordering} t_ordering | {t_ordinality} t_ordinality | {t_others} t_others | {t_output} t_output | {t_overriding} t_overriding
  | {t_p} t_p | {t_pad} t_pad | {t_parameter_mode} t_parameter_mode | {t_parameter_name} t_parameter_name | {t_parameter_ordinal_position} t_parameter_ordinal_position
  | {t_parameter_specific_catalog} t_parameter_specific_catalog | {t_parameter_specific_name} t_parameter_specific_name | {t_parameter_specific_schema} t_parameter_specific_schema
  | {t_partial} t_partial | {t_pascal} t_pascal | {t_path} t_path | {t_placing} t_placing | {t_pli} t_pli | {t_preceding} t_preceding | {t_preserve} t_preserve
  | {t_prior} t_prior | {t_privileges} t_privileges | {t_public} t_public | {t_read} t_read | {t_relative} t_relative | {t_repeatable} t_repeatable | {t_respect} t_respect
  | {t_restart} t_restart | {t_restrict} t_restrict | {t_returned_cardinality} t_returned_cardinality | {t_returned_length} t_returned_length
  | {t_returned_octet_length} t_returned_octet_length | {t_returned_sqlstate} t_returned_sqlstate | {t_role} t_role | {t_routine} t_routine
  | {t_routine_catalog} t_routine_catalog | {t_routine_name} t_routine_name | {t_routine_schema} t_routine_schema | {t_row_count} t_row_count
  | {t_scale} t_scale | {t_schema} t_schema | {t_schema_name} t_schema_name | {t_scope_catalog} t_scope_catalog | {t_scope_name} t_scope_name
  | {t_scope_schema} t_scope_schema | {t_section} t_section | {t_security} t_security | {t_self} t_self | {t_sequence} t_sequence | {t_serializable} t_serializable
  | {t_server_name} t_server_name | {t_session} t_session | {t_sets} t_sets | {t_simple} t_simple | {t_size} t_size | {t_source} t_source | {t_space} t_space
  | {t_specific_name} t_specific_name | {t_state} t_state | {t_statement} t_statement | {t_structure} t_structure | {t_style} t_style | {t_subclass_origin} t_subclass_origin
  | {t_t} t_t | {t_table_name} t_table_name | {t_temporary} t_temporary | {t_ties} t_ties | {t_top_level_count} t_top_level_count | {t_transaction} t_transaction
  | {t_transaction_active} t_transaction_active | {t_transactions_committed} t_transactions_committed | {t_transactions_rolled_back} t_transactions_rolled_back
  | {t_transform} t_transform | {t_transforms} t_transforms | {t_trigger_catalog} t_trigger_catalog | {t_trigger_name} t_trigger_name | {t_trigger_schema} t_trigger_schema
  | {t_type} t_type | {t_unbounded} t_unbounded | {t_uncommitted} t_uncommitted | {t_under} t_under | {t_unnamed} t_unnamed | {t_usage} t_usage | {t_user_defined_type_catalog} t_user_defined_type_catalog
  | {t_user_defined_type_code} t_user_defined_type_code | {t_user_defined_type_name} t_user_defined_type_name | {t_user_defined_type_schema} t_user_defined_type_schema
  | {t_view} t_view | {t_work} t_work | {t_write} t_write | {t_zone} t_zone;

reserved_word :
    {t_abs} t_abs | {t_all} t_all | {t_allocate} t_allocate | {t_alter} t_alter | {t_and} t_and | {t_any} t_any | {t_are} t_are | {t_array} t_array | {t_array_agg} t_array_agg
  | {t_array_max_cardinality} t_array_max_cardinality | {t_as} t_as | {t_asensitive} t_asensitive | {t_asymmetric} t_asymmetric | {t_at} t_at | {t_atomic} t_atomic
  | {t_authorization} t_authorization | {t_avg} t_avg | {t_begin} t_begin | {t_begin_frame} t_begin_frame | {t_begin_partition} t_begin_partition
  | {t_between} t_between | {t_bigint} t_bigint | {t_binary} t_binary | {t_blob} t_blob | {t_boolean} t_boolean | {t_both} t_both | {t_by} t_by | {t_call} t_call
  | {t_called} t_called | {t_cardinality} t_cardinality | {t_cascaded} t_cascaded | {t_case} t_case | {t_cast} t_cast | {t_ceil} t_ceil | {t_ceiling} t_ceiling
  | {t_char} t_char | {t_char_length} t_char_length | {t_character} t_character | {t_character_length} t_character_length | {t_check} t_check | {t_clob} t_clob
  | {t_close} t_close | {t_coalesce} t_coalesce | {t_collate} t_collate | {t_collect} t_collect | {t_column} t_column | {t_commit} t_commit | {t_condition} t_condition
  | {t_connect} t_connect | {t_constraint} t_constraint | {t_contains} t_contains | {t_convert} t_convert | {t_corr} t_corr | {t_corresponding} t_corresponding
  | {t_count} t_count | {t_covar_pop} t_covar_pop | {t_covar_samp} t_covar_samp | {t_create} t_create | {t_cross} t_cross | {t_cube} t_cube | {t_cume_dist} t_cume_dist
  | {t_current} t_current | {t_current_catalog} t_current_catalog | {t_current_date} t_current_date | {t_current_default_transform_group} t_current_default_transform_group
  | {t_current_path} t_current_path | {t_current_role} t_current_role | {t_current_row} t_current_row | {t_current_schema} t_current_schema
  | {t_current_time} t_current_time | {t_current_timestamp} t_current_timestamp | {t_current_transform_group_for_type} t_current_transform_group_for_type
  | {t_current_user} t_current_user | {t_cursor} t_cursor | {t_cycle} t_cycle | {t_date} t_date | {t_day} t_day | {t_deallocate} t_deallocate | {t_dec} t_dec
  | {t_decimal} t_decimal | {t_declare} t_declare | {t_default} t_default | {t_delete} t_delete | {t_dense_rank} t_dense_rank | {t_deref} t_deref | {t_describe} t_describe
  | {t_deterministic} t_deterministic | {t_disconnect} t_disconnect | {t_distinct} t_distinct | {t_double} t_double | {t_drop} t_drop | {t_dynamic} t_dynamic
  | {t_each} t_each | {t_element} t_element | {t_else} t_else | {t_end} t_end | {t_end_frame} t_end_frame | {t_end_partition} t_end_partition | {t_end_exec} t_end_exec
  | {t_equals} t_equals | {t_escape} t_escape | {t_every} t_every | {t_except} t_except | {t_exec} t_exec | {t_execute} t_execute | {t_exists} t_exists | {t_exp} t_exp
  | {t_external} t_external | {t_extract} t_extract | {t_false} t_false | {t_fetch} t_fetch | {t_filter} t_filter | {t_first_value} t_first_value | {t_float} t_float
  | {t_floor} t_floor | {t_for} t_for | {t_foreign} t_foreign | {t_frame_row} t_frame_row | {t_free} t_free | {t_from} t_from | {t_full} t_full | {t_function} t_function
  | {t_fusion} t_fusion | {t_get} t_get | {t_global} t_global | {t_grant} t_grant | {t_group} t_group | {t_grouping} t_grouping | {t_groups} t_groups | {t_having} t_having
  | {t_hold} t_hold | {t_hour} t_hour | {t_identity} t_identity | {t_in} t_in | {t_indicator} t_indicator | {t_inner} t_inner | {t_inout} t_inout | {t_insensitive} t_insensitive
  | {t_insert} t_insert | {t_int} t_int | {t_integer} t_integer | {t_intersect} t_intersect | {t_intersection} t_intersection | {t_interval} t_interval
  | {t_into} t_into | {t_is} t_is | {t_join} t_join | {t_lag} t_lag | {t_language} t_language | {t_large} t_large | {t_last_value} t_last_value | {t_lateral} t_lateral
  | {t_lead} t_lead | {t_leading} t_leading | {t_left} t_left | {t_like} t_like | {t_like_regex} t_like_regex | {t_ln} t_ln | {t_local} t_local | {t_localtime} t_localtime
  | {t_localtimestamp} t_localtimestamp | {t_lower} t_lower | {t_match} t_match | {t_max} t_max | {t_member} t_member | {t_merge} t_merge | {t_method} t_method
  | {t_min} t_min | {t_minute} t_minute | {t_mod} t_mod | {t_modifies} t_modifies | {t_module} t_module | {t_month} t_month | {t_multiset} t_multiset | {t_national} t_national
  | {t_natural} t_natural | {t_nchar} t_nchar | {t_nclob} t_nclob | {t_new} t_new | {t_no} t_no | {t_none} t_none | {t_normalize} t_normalize | {t_not} t_not | {t_nth_value} t_nth_value
  | {t_ntile} t_ntile | {t_null} t_null | {t_nullif} t_nullif | {t_numeric} t_numeric | {t_octet_length} t_octet_length | {t_occurrence } t_occurrence | {t_occurrences_regex} t_occurrences_regex
  | {t_of} t_of | {t_offset} t_offset | {t_old} t_old | {t_on} t_on | {t_only} t_only | {t_open} t_open | {t_or} t_or | {t_order} t_order | {t_out} t_out | {t_outer} t_outer
  | {t_over} t_over | {t_overlaps} t_overlaps | {t_overlay} t_overlay | {t_parameter} t_parameter | {t_partition} t_partition | {t_percent} t_percent
  | {t_percent_rank} t_percent_rank | {t_percentile_cont} t_percentile_cont | {t_percentile_disc} t_percentile_disc | {t_period} t_period
  | {t_portion} t_portion | {t_position} t_position | {t_position_regex} t_position_regex | {t_power} t_power | {t_precedes} t_precedes | {t_precision} t_precision
  | {t_prepare} t_prepare | {t_primary} t_primary | {t_procedure} t_procedure | {t_range} t_range | {t_rank} t_rank | {t_reads} t_reads | {t_real} t_real | {t_recursive} t_recursive
  | {t_ref} t_ref | {t_references} t_references | {t_referencing} t_referencing | {t_regr_avgx} t_regr_avgx | {t_regr_avgy} t_regr_avgy | {t_regr_count} t_regr_count
  | {t_regr_intercept} t_regr_intercept | {t_regr_r2} t_regr_r2 | {t_regr_slope} t_regr_slope | {t_regr_sxx} t_regr_sxx | {t_regr_sxy} t_regr_sxy
  | {t_regr_syy} t_regr_syy | {t_release} t_release | {t_result} t_result | {t_return} t_return | {t_returns} t_returns | {t_revoke} t_revoke | {t_right} t_right
  | {t_rollback} t_rollback | {t_rollup} t_rollup | {t_row} t_row | {t_row_number} t_row_number | {t_rows} t_rows | {t_savepoint} t_savepoint | {t_scope} t_scope
  | {t_scroll} t_scroll | {t_search} t_search | {t_second} t_second | {t_select} t_select | {t_sensitive} t_sensitive | {t_session_user} t_session_user | {t_set} t_set
  | {t_similar} t_similar | {t_smallint} t_smallint | {t_some} t_some | {t_specific} t_specific | {t_specifictype} t_specifictype | {t_sql} t_sql | {t_sqlexception} t_sqlexception
  | {t_sqlstate} t_sqlstate | {t_sqlwarning} t_sqlwarning | {t_sqrt} t_sqrt | {t_start} t_start | {t_static} t_static | {t_stddev_pop} t_stddev_pop | {t_stddev_samp} t_stddev_samp
  | {t_submultiset} t_submultiset | {t_substring} t_substring | {t_substring_regex} t_substring_regex | {t_succeeds} t_succeeds | {t_sum} t_sum | {t_symmetric} t_symmetric
  | {t_system} t_system | {t_system_time} t_system_time | {t_system_user} t_system_user | {t_table} t_table | {t_tablesample} t_tablesample | {t_then} t_then
  | {t_time} t_time | {t_timestamp} t_timestamp | {t_timezone_hour} t_timezone_hour | {t_timezone_minute} t_timezone_minute | {t_to} t_to | {t_trailing} t_trailing
  | {t_translate} t_translate | {t_translate_regex} t_translate_regex | {t_translation} t_translation | {t_treat} t_treat | {t_trigger} t_trigger
  | {t_truncate} t_truncate | {t_trim} t_trim | {t_trim_array} t_trim_array | {t_true} t_true | {t_uescape} t_uescape | {t_union} t_union | {t_unique} t_unique
  | {t_unknown} t_unknown | {t_unnest} t_unnest | {t_update} t_update | {t_upper} t_upper | {t_user} t_user | {t_using} t_using | {t_value} t_value | {t_values} t_values
  | {t_value_of} t_value_of | {t_var_pop} t_var_pop | {t_var_samp} t_var_samp | {t_varbinary} t_varbinary | {t_varchar} t_varchar | {t_varying} t_varying
  | {t_versioning} t_versioning | {t_when} t_when | {t_whenever} t_whenever | {t_where} t_where | {t_width_bucket} t_width_bucket | {t_window} t_window
  | {t_with} t_with | {t_within} t_within | {t_without} t_without | {t_year} t_year;

// <column definition> ::= <column name> [ <data type or domain name> ] 
//  [ <default clause> | <identity column specification> | <generation clause> | <system time period start column specification> | <system time period end column specification> ] 
//  [ <column constraint definition>... ] [ <collate clause> ]
column_definition : column_name data_type_or_domain_name? (default_clause | identity_column_specification | generation_clause | system_time_period_start_column_specification
    |  system_time_period_end_column_specification)? column_constraint_definition* collate_clause?;

// <data type or domain name> ::= <data type> | <domain name>
data_type_or_domain_name : {type} data_type | {name} domain_name;

// <system time period start column specification> ::= <timestamp generation rule> AS ROW START
system_time_period_start_column_specification : timestamp_generation_rule t_as t_row t_start;

// <system time period end column specification> ::= <timestamp generation rule> AS ROW END
system_time_period_end_column_specification : timestamp_generation_rule t_as t_row t_end;

// <timestamp generation rule> ::= GENERATED ALWAYS
timestamp_generation_rule : t_generated t_always;

// <column constraint definition> ::= [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]
column_constraint_definition : constraint_name_definition? column_constraint constraint_characteristics?;

// <column constraint> ::= NOT NULL | <unique specification> | <references specification> | <check constraint definition>
column_constraint : {not_null} t_not t_null | {unique} unique_specification | {references} references_specification | {check} check_constraint_definition;

// <identity column specification> ::= GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ <left paren> <common sequence generator options> <right paren> ]
identity_column_specification : t_generated (t_always | t_by t_default) t_as t_identity (LEFT_PAREN common_sequence_generator_options RIGHT_PAREN)?;

// <generation clause> ::= <generation rule> AS <generation expression>
generation_clause : generation_rule t_as generation_expression;

// <generation rule> ::= GENERATED ALWAYS
generation_rule : t_generated t_always;

// <generation expression> ::= <left paren> <value expression> <right paren>
generation_expression : LEFT_PAREN value_expression RIGHT_PAREN;

// <table PERIOD definition> ::= <system or application time PERIOD specification> <left paren> <PERIOD begin column name> <comma> <PERIOD end column name> <right paren>
table_period_definition : system_or_application_time_period_specification LEFT_PAREN period_begin_column_name COMMA period_end_column_name RIGHT_PAREN;

// <system or application time PERIOD specification> ::= <system time PERIOD specification> | <application time PERIOD specification>
// <system time PERIOD specification> ::= PERIOD FOR SYSTEM_TIME
// <application time PERIOD specification> ::= PERIOD FOR <application time PERIOD name>
// <application time PERIOD name> ::= <identifier>
// <PERIOD begin column name> ::= <column name>
period_begin_column_name : column_name;

// <PERIOD end column name> ::= <column name>
period_end_column_name : column_name;

// <table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]
table_constraint_definition : constraint_name_definition? table_constraint constraint_characteristics?;

// <table constraint> ::= <unique constraint definition> | <referential constraint definition> | <check constraint definition>
table_constraint : {unique} unique_constraint_definition | {ref} referential_constraint_definition | {check} check_constraint_definition;

// <data type> ::= <predefined type> | <row type> | <path-resolved user-defined type name> | <reference type> | <collection type>
data_type : {predefined} predefined_type | {row} row_type | {path} path_resolved_user_defined_type_name | {reference} reference_type | {collection} collection_type;
 
// <predefined type> ::= <character string type> [ CHARACTER SET <character set specification> ] [ <collate clause> ] | <national character string type> [ <collate clause> ] | <binary string type> | <numeric type> | <boolean type> | <datetime type> | <interval type>
predefined_type : {character} character_string_type (t_character t_set character_set_specification)? collate_clause? | {national} national_character_string_type collate_clause?
     | {binary} binary_string_type | {numeric} numeric_type | {boolean} boolean_type | {datetime} datetime_type | {interval} interval_type;

// <character string type> ::= CHARACTER [ <left paren> <character length> <right paren> ] | CHAR [ <left paren> <character length> <right paren> ] | CHARACTER VARYING <left paren> <character length> <right paren> | CHAR VARYING <left paren> <character length> <right paren> | VARCHAR <left paren> <character length> <right paren> | <character large object type>
character_string_type : {character} t_character (LEFT_PAREN character_length RIGHT_PAREN)? | {char} t_char (LEFT_PAREN character_length RIGHT_PAREN)? | {character_varying} t_character t_varying (LEFT_PAREN character_length RIGHT_PAREN) | {char_varying} t_char t_varying (LEFT_PAREN character_length RIGHT_PAREN) | {varchar} t_varchar (LEFT_PAREN character_length RIGHT_PAREN) | {clot} character_large_object_type;

// <character large object type> ::= CHARACTER LARGE OBJECT [ <left paren> <character large object length> <right paren> ] | CHAR LARGE OBJECT [ <left paren> <character large object length> <right paren> ]
//   | CLOB [ <left paren> <character large object length> <right paren> ]
character_large_object_type : {character_large_object} t_character t_large t_object (LEFT_PAREN character_large_object_length RIGHT_PAREN)? | {char_large_object} t_char t_large t_object (LEFT_PAREN character_large_object_length RIGHT_PAREN)? 
   | {clob} t_clob (LEFT_PAREN character_large_object_length RIGHT_PAREN)?; 

// <national character string type> ::= NATIONAL CHARACTER [ <left paren> <character length> <right paren> ] | NATIONAL CHAR [ <left paren> <character length> <right paren> ]
//  | NCHAR [ <left paren> <character length> <right paren> ] | NATIONAL CHARACTER VARYING <left paren> <character length> <right paren> | NATIONAL CHAR VARYING <left paren> <character length> <right paren>
//  | NCHAR VARYING <left paren> <character length> <right paren> | <national character large object type>
national_character_string_type : {national_character} t_national t_character (LEFT_PAREN character_length RIGHT_PAREN)? | {national_char} t_national t_char (LEFT_PAREN character_length RIGHT_PAREN)?
   | {nchar} t_nchar (LEFT_PAREN character_length RIGHT_PAREN)? | {national_character_varying} t_national t_character t_varying LEFT_PAREN character_length RIGHT_PAREN | {national_char_varying} t_national t_char t_varying LEFT_PAREN character_length RIGHT_PAREN
   | {nchar_varying} t_nchar t_varying LEFT_PAREN character_length RIGHT_PAREN | {national_character_large_object_type} national_character_large_object_type;

// <national character large object type> ::= NATIONAL CHARACTER LARGE OBJECT [ <left paren> <character large object length> <right paren> ]
//   | NCHAR LARGE OBJECT [ <left paren> <character large object length> <right paren> ] | NCLOB [ <left paren> <character large object length> <right paren> ]
national_character_large_object_type : {national_character_large_object} t_national t_character t_large t_object (LEFT_PAREN character_large_object_length RIGHT_PAREN)? 
   | {nchar_large_object} t_nchar t_large t_object (LEFT_PAREN character_large_object_length RIGHT_PAREN)? | {nclob} t_nclob (LEFT_PAREN character_large_object_length RIGHT_PAREN)?;

// <binary string type> ::= BINARY [ <left paren> <length> <right paren> ] | BINARY VARYING <left paren> <length> <right paren> | VARBINARY <left paren> <length> <right paren> | <binary large object string type>
binary_string_type : {binary} t_binary (LEFT_PAREN length RIGHT_PAREN)? | {bvarying} t_binary t_varying LEFT_PAREN length RIGHT_PAREN | {varbinary} t_varbinary LEFT_PAREN length RIGHT_PAREN | {blost} binary_large_object_string_type;

// <binary large object string type> ::= BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ] | BLOB [ <left paren> <large object length> <right paren> ]
binary_large_object_string_type : {blobject} t_binary t_large t_object (LEFT_PAREN large_object_length RIGHT_PAREN)? | {blob} t_blob LEFT_PAREN large_object_length RIGHT_PAREN;

// <numeric type> ::= <exact numeric type> | <approximate numeric type>
numeric_type : {exact} exact_numeric_type | {approx} approximate_numeric_type;

// <exact numeric type> ::= NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ] | DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
//  | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ] | SMALLINT | INTEGER | INT | BIGINT
paren_precision : ;
exact_numeric_type : {numeric} t_numeric (LEFT_PAREN precision (COMMA scale)? RIGHT_PAREN)? | {decimal} t_decimal (LEFT_PAREN precision (COMMA scale)? RIGHT_PAREN)?
 | {dec} t_dec (LEFT_PAREN precision (COMMA scale)? RIGHT_PAREN)? | {smallint} t_smallint | {integer} t_integer | {int} t_int | {bigint} t_bigint;

// <approximate numeric type> ::= FLOAT [ <left paren> <precision> <right paren> ] | REAL | DOUBLE PRECISION
approximate_numeric_type : {float} t_float paren_precision? | {real} t_real | {double} t_double t_precision;

// <length> ::= <unsigned integer>
length : unsigned_integer;

// <character length> ::= <length> [ <char length units> ]
character_length : length char_length_units?;

// <large object length> ::= <length> [ <multiplier> ] | <large object length token>
large_object_length : {length} length multiplier? | {token} large_object_length_token;

// <character large object length> ::= <large object length> [ <char length units> ]
character_large_object_length : large_object_length char_length_units?;

// <char length units> ::= CHARACTERS | OCTETS
char_length_units : {characters} t_characters | {octets} t_octets;

// <precision> ::= <unsigned integer>
precision : unsigned_integer;

// <scale> ::= <unsigned integer>
scale : unsigned_integer;

// <boolean type> ::= BOOLEAN
boolean_type : t_boolean;

// <datetime type> ::= DATE | TIME [ <left paren> <time precision> <right paren> ] [ <with or without time zone> ] | TIMESTAMP [ <left paren> <timestamp precision> <right paren> ] [ <with or without time zone> ]
datetime_type : {date} t_date | {time} t_time (LEFT_PAREN time_precision RIGHT_PAREN)? with_or_without_time_zone?  | {timestamp} t_timestamp (LEFT_PAREN time_precision RIGHT_PAREN)? with_or_without_time_zone?;

// <with or without time zone> ::= WITH TIME ZONE | WITHOUT TIME ZONE
with_or_without_time_zone : {with} t_with t_time t_zone | {without} t_without t_time t_zone;

// <time precision> ::= <time fractional seconds precision>
time_precision : time_fractional_seconds_precision;

// <timestamp precision> ::= <time fractional seconds precision>
timestamp_precision : time_fractional_seconds_precision;

// <time fractional seconds precision> ::= <unsigned integer>
time_fractional_seconds_precision : unsigned_integer;

// <interval type> ::= INTERVAL <interval qualifier>
interval_type : t_interval interval_qualifier;

// <row type> ::= ROW <row type body>
row_type : t_row row_type_body;

// <row type body> ::= <left paren> <field definition> [ { <comma> <field definition> }... ] <right paren>
row_type_body : LEFT_PAREN field_definition (COMMA field_definition)* RIGHT_PAREN;

// <reference type> ::= REF <left paren> <referenced type> <right paren> [ <scope clause> ]
reference_type : t_ref LEFT_PAREN referenced_type RIGHT_PAREN scope_clause?;

// <scope clause> ::= SCOPE <table name>
scope_clause : t_scope table_name;

// <referenced type> ::= <path-resolved user-defined type name>
referenced_type : path_resolved_user_defined_type_name;

// <path-resolved user-defined type name> ::= <user-defined type name>
path_resolved_user_defined_type_name : user_defined_type_name;

// <collection type> ::= <array type> | <multiset type>
collection_type : {array} array_type | {multiset} multiset_type;

// <array type> ::= <data type> ARRAY [ <left bracket or trigraph> <maximum cardinality> <right bracket or trigraph> ]
array_type : data_type t_array (left_bracket_or_trigraph maximum_cardinality right_bracket_or_trigraph)?;

// <maximum cardinality> ::= <unsigned integer>
maximum_cardinality : unsigned_integer;

// <multiset type> ::= <data type> MULTISET
multiset_type : data_type t_multiset;

// <default clause> ::= DEFAULT <default option>
default_clause : t_default default_option;

// <default option> ::= <literal> | <datetime value function> | USER | CURRENT_USER | CURRENT_ROLE | SESSION_USER | SYSTEM_USER
//  | CURRENT_CATALOG | CURRENT_SCHEMA | CURRENT_PATH | <implicitly typed value specification>
default_option : {literal} literal | {datetime} datetime_value_function | {user} t_user | {current_user} t_current_user | {current_role} t_current_role | {session_user} t_session_user | {system_user} t_system_user
   | {current_catalog} t_current_catalog | {current_schema} t_current_schema | {current_path} t_current_path | {implicit} implicitly_typed_value_specification;

// <predicate> ::= <comparison predicate> | <between predicate> | <in predicate> | <like predicate> | <similar predicate>
//    | <regex like predicate> | <null predicate> | <quantified comparison predicate> | <exists predicate> | <unique predicate>
//    | <normalized predicate> | <match predicate> | <overlaps predicate> | <distinct predicate> | <member predicate> | <submultiset predicate>
//    | <set predicate> | <type predicate> | <PERIOD predicate>
predicate : {comparison_predicate} comparison_predicate | {between_predicate} between_predicate | {in_predicate} in_predicate | {like_predicate} like_predicate | {similar_predicate} similar_predicate 
    | {regex_like_predicate} regex_like_predicate | {null_predicate} null_predicate | {quantified_comparison_predicate} quantified_comparison_predicate | {exists_predicate} exists_predicate | {unique_predicate} unique_predicate
    | {normalized_predicate} normalized_predicate | {match_predicate} match_predicate |  {overlaps_predicate} overlaps_predicate | {distinct_predicate} distinct_predicate | {member_predicate} member_predicate | {submultiset_predicate} submultiset_predicate
    | {set_predicate} set_predicate | {type_predicate} type_predicate | {period_predicate} period_predicate;

// <comparison predicate> ::= <row value predicand> <comparison predicate part 2>
comparison_predicate : row_value_predicand comparison_predicate_part2;

// <comparison predicate part 2> ::= <comp op> <row value predicand>
comparison_predicate_part2 : comp_op row_value_predicand;

// <comp op> ::= <equals operator> | <not equals operator> | <less than operator> | <greater than operator>
//   | <less than or equals operator> | <greater than or equals operator>
comp_op : {equals} EQUALS_OPERATOR | {not_equals} NOT_EQUALS_OPERATOR | {less_than} LESS_THAN_OPERATOR | {greater_than} GREATER_THAN_OPERATOR
  | {less_than_eq} LESS_THAN_OR_EQUALS_OPERATOR | {greater_than_eq} GREATER_THAN_OR_EQUALS_OPERATOR;

// <between predicate> ::= <row value predicand> <between predicate part 2>
between_predicate : row_value_predicand between_predicate_part2;

// <between predicate part 2> ::= [ NOT ] BETWEEN [ ASYMMETRIC | SYMMETRIC ] <row value predicand> AND <row value predicand>
between_predicate_part2 : t_not? t_between (t_asymmetric | t_symmetric)? row_value_predicand t_and row_value_predicand;

// <in predicate> ::= <row value predicand> <in predicate part 2>
in_predicate : row_value_predicand in_predicate_part2;

// <in predicate part 2> ::= [ NOT ] IN <in predicate value>
in_predicate_part2 : t_not? t_in in_predicate_value;

// <in predicate value> ::= <table subquery> | <left paren> <in value list> <right paren>
in_predicate_value : {query} table_subquery | {list} LEFT_PAREN in_value_list RIGHT_PAREN;

// <in value list> ::= <row value expression> [ { <comma> <row value expression> }... ]
in_value_list : row_value_expression (COMMA row_value_expression)*;

// <like predicate> ::= <character like predicate> | <octet like predicate>
like_predicate : {character_like_predicate} character_like_predicate | {octect_like_predicate} octect_like_predicate;

// <character like predicate> ::= <row value predicand> <character like predicate part 2>
character_like_predicate : row_value_predicand character_like_predicate_part2;

// <character like predicate part 2> ::= [ NOT ] LIKE <character pattern> [ ESCAPE <escape character> ]
character_like_predicate_part2 : t_not? t_like character_pattern (t_escape escape_character)?;

// <character pattern> ::= <character value expression>
character_pattern : character_value_expression;

// <escape character> ::= <character value expression>
escape_character : character_value_expression;

// <octet like predicate> ::= <row value predicand> <octet like predicate part 2>
octect_like_predicate : row_value_predicand octet_like_predicate_part2;

// <octet like predicate part 2> ::= [ NOT ] LIKE <octet pattern> [ ESCAPE <escape octet> ]
octet_like_predicate_part2 : t_not? t_like octet_pattern (t_escape escape_octet)?;

// <octet pattern> ::= <binary value expression>
octet_pattern : binary_value_expression;

// <escape octet> ::= <binary value expression>
escape_octet : binary_value_expression;

// <similar predicate> ::= <row value predicand> <similar predicate part 2>
similar_predicate : row_value_predicand similar_predicate_part2;

// <similar predicate part 2> ::= [ NOT ] SIMILAR TO <similar pattern> [ ESCAPE <escape character> ]
similar_predicate_part2 :  t_not? t_similar t_to similar_pattern (t_escape escape_character)?;

// <similar pattern> ::= <character value expression>
similar_pattern : character_value_expression;

// <regular expression> ::= <regular term> | <regular expression> <vertical bar> <regular term>
// <regular term> ::= <regular factor> | <regular term> <regular factor>
// <regular factor> ::= <regular primary> | <regular primary> <ASTERISK> | <regular primary> <plus sign> | <regular primary> <question mark> | <regular primary> <repeat factor>
// <repeat factor> ::= <left brace> <low value> [ <upper limit> ] <right brace>
// <upper limit> ::= <comma> [ <high value> ]
// <low value> ::= <unsigned integer>
// <high value> ::= <unsigned integer>
// <regular primary> ::= <character specifier> | <PERCENT> | <regular character set> | <left paren> <regular expression> <right paren>
// <character specifier> ::= <non-escaped character> | <escaped character>
// <non-escaped character> ::= !! See the Syntax Rules.
// <escaped character> ::= !! See the Syntax Rules.
// <regular character set> ::= <UNDERSCORE> | <left bracket> <character enumeration>... <right bracket> | <left bracket> <CIRCUMFLEX> <character enumeration>... <right bracket> | <left bracket> <character enumeration include>... <CIRCUMFLEX> <character enumeration exclude>... <right bracket>
// <character enumeration include> ::= <character enumeration>
// <character enumeration exclude> ::= <character enumeration>
// <character enumeration> ::= <character specifier> | <character specifier> <minus sign> <character specifier> | <left bracket> <COLON> <regular character set identifier> <COLON> <right bracket>
// <regular character set identifier> ::= <identifier>

// <regex like predicate> ::= <row value predicand> <regex like predicate part 2>
regex_like_predicate : row_value_predicand regex_like_predicate_part2;

// <regex like predicate part 2> ::=[ NOT ] LIKE_REGEX <XQuery pattern> [ FLAG <XQuery option flag> ]
regex_like_predicate_part2 : t_not? t_like_regex xquery_pattern (t_flag xquery_option_flag)?;

// <null predicate> ::= <row value predicand> <null predicate part 2>
null_predicate : row_value_predicand null_predicate_part2;

// <null predicate part 2> ::= IS [ NOT ] NULL
null_predicate_part2 : t_is t_not? t_null;

// <quantified comparison predicate> ::= <row value predicand> <quantified comparison predicate part 2>
quantified_comparison_predicate : row_value_predicand quantified_comparison_predicate_part2;

// <quantified comparison predicate part 2> ::= <comp op> <quantifier> <table subquery>
quantified_comparison_predicate_part2 : comp_op quantifier table_subquery;

// <quantifier> ::= <all> | <some>
// <all> ::= ALL
quantifier : {all} t_all | {some_or_any} some_or_any;

// <some> ::= SOME | ANY
some_or_any : {some} t_some | {any} t_any;

// <exists predicate> ::= EXISTS <table subquery>
exists_predicate : t_exists table_subquery;

// <unique predicate> ::= UNIQUE <table subquery>
unique_predicate : t_unique table_subquery;

// <normalized predicate> ::= <row value predicand> <normalized predicate part 2>
normalized_predicate : row_value_predicand normalized_predicate_part2;

// <normalized predicate part 2> ::= IS [ NOT ] [ <normal form> ] NORMALIZED
normalized_predicate_part2 : t_is t_not? normal_form? t_normalized;

// <match predicate> ::= <row value predicand> <match predicate part 2>
match_predicate : row_value_predicand match_predicate_part2;

//match predicate part 2> ::= MATCH [ UNIQUE ] [ SIMPLE | PARTIAL | FULL ] <table subquery>
match_predicate_part2 : t_match t_unique? (t_simple | {partial} t_partial | {full} t_full)? table_subquery;

// <overlaps predicate> ::= <overlaps predicate part 1> <overlaps predicate part 2>
overlaps_predicate : overlaps_predicate_part1 overlaps_predicate_part2;

// <overlaps predicate part 1> ::= <row value predicand 1>
overlaps_predicate_part1 : row_value_predicand1;

// <overlaps predicate part 2> ::= OVERLAPS <row value predicand 2>
overlaps_predicate_part2 : t_overlaps row_value_predicand2;

// <row value predicand 1> ::= <row value predicand>
row_value_predicand1 : row_value_predicand;

// <row value predicand 2> ::= <row value predicand>
row_value_predicand2 : row_value_predicand;

// <distinct predicate> ::= <row value predicand 3> <distinct predicate part 2>
distinct_predicate : row_value_predicand3 distinct_predicate_part2;

// <distinct predicate part 2> ::= IS [ NOT ] DISTINCT FROM <row value predicand 4>
distinct_predicate_part2 : t_is t_not? t_distinct t_from row_value_predicand4;

// <row value predicand 3> ::= <row value predicand>
row_value_predicand3 : row_value_predicand;

// <row value predicand 4> ::= <row value predicand>
row_value_predicand4 : row_value_predicand;

// <member predicate> ::= <row value predicand> <member predicate part 2>
member_predicate : row_value_predicand member_predicate_part2;

// <member predicate part 2> ::= [ NOT ] MEMBER [ OF ] <multiset value expression>
member_predicate_part2 : t_not? t_member t_of? multiset_value_expression;

// <submultiset predicate> ::= <row value predicand> <submultiset predicate part 2>
submultiset_predicate : row_value_predicand submultiset_predicate_part2;

// <submultiset predicate part 2> ::= [ NOT ] SUBMULTISET [ OF ] <multiset value expression>
submultiset_predicate_part2 : t_not? t_submultiset t_of? multiset_value_expression;

// <set predicate> ::= <row value predicand> <set predicate part 2>
set_predicate : row_value_predicand set_predicate_part2;

// <set predicate part 2> ::= IS [ NOT ] A SET
set_predicate_part2 : t_is t_not? t_a t_set;

// <type predicate> ::= <row value predicand> <type predicate part 2>
type_predicate : row_value_predicand type_predicate_part2;

// <type predicate part 2> ::= IS [ NOT ] OF <left paren> <type list> <right paren>
type_predicate_part2 : t_is t_not? t_of LEFT_PAREN type_list RIGHT_PAREN;

// <type list> ::= <user-defined type specification> [ { <comma> <user-defined type specification> }... ]
type_list : user_defined_type_specification (COMMA user_defined_type_specification)*;

// <user-defined type specification> ::= <inclusive user-defined type specification> | <exclusive user-defined type specification>
user_defined_type_specification : {inclusive_udt} inclusive_user_defined_type_specification | {exclusive_udt} exclusive_user_defined_type_specification;

// <inclusive user-defined type specification> ::= <path-resolved user-defined type name>
inclusive_user_defined_type_specification : path_resolved_user_defined_type_name;

// <exclusive user-defined type specification> ::= ONLY <path-resolved user-defined type name>
exclusive_user_defined_type_specification : path_resolved_user_defined_type_name;

// <PERIOD predicate> ::= <PERIOD overlaps predicate> | <PERIOD equals predicate> | <PERIOD contains predicate> | <PERIOD precedes predicate>
//  | <PERIOD succeeds predicate> | <PERIOD immediately precedes predicate> | <PERIOD immediately succeeds predicate>
period_predicate : {overlap} period_overlap_predicate | {equals} period_equals_predicate | {contains} period_contains_predicate | {precedes} period_precedes_predicate
    | {succeeds} period_succeeds_predicate | {immed_preceeds} period_immediately_precedes_predicate | {immed_succeeds} period_immediately_succeeds_predicate;

// <PERIOD overlaps predicate> ::= <PERIOD predicand 1> <PERIOD overlaps predicate part 2>
period_overlap_predicate : period_predicand1 period_overlap_predicate_part2;

// <PERIOD overlaps predicate part 2> ::= OVERLAPS <PERIOD predicand 2>
period_overlap_predicate_part2 : t_overlaps period_predicand2;

// <PERIOD predicand 1> ::= <PERIOD predicand>
period_predicand1 : period_predicand;

// <PERIOD predicand 2> ::= <PERIOD predicand>
period_predicand2 : period_predicand;

// <PERIOD predicand> ::= <PERIOD reference> | PERIOD <left paren> <PERIOD start value> <comma> <PERIOD end value> <right paren>
period_predicand : {period_reference} period_reference | {period_def} t_period LEFT_PAREN period_start_value COMMA period_end_value RIGHT_PAREN;

// <PERIOD reference> ::= <basic identifier chain>
period_reference : basic_identifier_chain;

// <PERIOD start value> ::= <datetime value expression>
period_start_value : datetime_value_expression;

// <PERIOD end value> ::= <datetime value expression>
period_end_value : datetime_value_expression;

// <PERIOD equals predicate> ::= <PERIOD predicand 1> <PERIOD equals predicate part 2>
period_equals_predicate : period_predicand1 period_equals_predicate_part2;

// <PERIOD equals predicate part 2> ::= EQUALS <PERIOD predicand 2>
period_equals_predicate_part2 : t_equals period_predicand2;

// <PERIOD contains predicate> ::= <PERIOD predicand 1> <PERIOD contains predicate part 2>
period_contains_predicate : period_predicand1 period_contains_predicate_part2;

// <PERIOD contains predicate part 2> ::= CONTAINS <PERIOD or point-in-time predicand>
period_contains_predicate_part2 : t_contains period_or_point_in_time_predicand;

// <PERIOD or point-in-time predicand> ::= <PERIOD predicand> | <datetime value expression>
period_or_point_in_time_predicand : {PERIOD} period_predicand | {datetime} datetime_value_expression;

// <PERIOD precedes predicate> ::= <PERIOD predicand 1> <PERIOD precedes predicate part 2>
period_precedes_predicate : period_predicand1 period_precedes_predicate_part2;

// <PERIOD precedes predicate part 2> ::= PRECEDES <PERIOD predicand 2>
period_precedes_predicate_part2 : t_precedes period_predicand2;

// <PERIOD succeeds predicate> ::= <PERIOD predicand 1> <PERIOD succeeds predicate part 2>
period_succeeds_predicate : period_predicand1 period_succeeds_predicate_part2;

// <PERIOD succeeds predicate part 2> ::= SUCCEEDS <PERIOD predicand 2>
period_succeeds_predicate_part2 : t_succeeds period_predicand2;

// <PERIOD immediately precedes predicate> ::= <PERIOD predicand 1> <PERIOD immediately precedes predicate part 2>
period_immediately_precedes_predicate : period_predicand1 period_immediately_precedes_predicate_part2;

// <PERIOD immediately precedes predicate part 2> ::= IMMEDIATELY PRECEDES <PERIOD predicand 2>
period_immediately_precedes_predicate_part2 : t_immediately t_precedes period_predicand2;

// <PERIOD immediately succeeds predicate> ::= <PERIOD predicand 1> <PERIOD immediately succeeds predicate part 2>
period_immediately_succeeds_predicate : period_predicand1 period_immediately_succeeds_predicate_part2;

// <PERIOD immediately succeeds predicate part 2> ::= IMMEDIATELY SUCCEEDS <PERIOD predicand 2>
period_immediately_succeeds_predicate_part2 : t_immediately t_succeeds period_predicand2;

// <set function specification> ::= <aggregate function> | <grouping operation>
set_function_specification : {aggregate} aggregate_function | {grouping} grouping_operation;

// <grouping operation> ::= GROUPING <left paren> <column reference> [ { <comma> <column reference> }... ] <right paren>
grouping_operation : t_grouping LEFT_PAREN column_reference (COMMA column_reference)* RIGHT_PAREN;

// <window function> ::= <window function type> OVER <window name or specification>
window_function : window_function_type t_over window_name_or_specification;

// <window function type> ::= <rank function type> <left paren> <right paren> | ROW_NUMBER <left paren> <right paren> | <aggregate function>
//   | <ntile function> | <lead or lag function> | <first or last value function> | <nth value function>
window_function_type : {rank_function} rank_function_type LEFT_PAREN RIGHT_PAREN | {row_number} t_row_number LEFT_PAREN RIGHT_PAREN | {aggregate} aggregate_function 
    | {ntile} ntile_function | {lead_or_lag} lead_or_lag_function | {first_or_last} first_or_last_value_function | {nth_value} nth_value_function;

// <rank function type> ::= RANK | DENSE_RANK | PERCENT_RANK | CUME_DIST
rank_function_type : {rank} t_rank | {dense_rank} t_dense_rank | {percent_rank} t_percent_rank | {cume_dist} t_cume_dist;

// <ntile function> ::= NTILE <left paren> <number of tiles> <right paren>
ntile_function : t_ntile LEFT_PAREN number_of_tiles RIGHT_PAREN;

// <number of tiles> ::= <simple value specification> | <dynamic parameter specification>
number_of_tiles : {simple} simple_value_specification | {dynamic} dynamic_parameter_specification;

// <lead or lag function> ::= <lead or lag> <left paren> <lead or lag extent> [ <comma> <offset> [ <comma> <default expression> ] ] <right paren> [ <null treatment> ]
lead_or_lag_function : lead_or_lag LEFT_PAREN lead_or_lag_extent (COMMA offset (COMMA default_expression)?)? RIGHT_PAREN null_treatment?;

// <lead or lag> ::= LEAD | LAG
lead_or_lag : {lead} t_lead | {lag} t_lag;

// <lead or lag extent> ::= <value expression>
lead_or_lag_extent : value_expression;

// <offset> ::= <exact numeric literal>
offset : exact_numeric_literal;

// <default expression> ::= <value expression>
default_expression : value_expression;

// <null treatment> ::= RESPECT NULLS | IGNORE NULLS
null_treatment : {respect} t_respect t_nulls | {ignore} t_ignore t_nulls;

// <first or last value function> ::= <first or last value> <left paren> <value expression> <right paren> [ <null treatment> ]
first_or_last_value_function : first_or_last_value LEFT_PAREN value_expression RIGHT_PAREN null_treatment?;

// <first or last value> ::= FIRST_VALUE | LAST_VALUE
first_or_last_value : {first} t_first_value | {last} t_last_value;

// <nth value function> ::= NTH_VALUE <left paren> <value expression> <comma> <nth row> <right paren> [ <from first or last> ] [ <null treatment> ]
nth_value_function : t_nth_value LEFT_PAREN value_expression COMMA nth_row RIGHT_PAREN from_first_or_last? null_treatment?;

// <nth row> ::= <simple value specification> | <dynamic parameter specification>
nth_row : {simple_value} simple_value_specification | {dynamic_parameter} dynamic_parameter_specification;

// <from first or last> ::= FROM FIRST | FROM LAST
from_first_or_last : {first} t_from t_first | {last} t_from t_last;

// <window name or specification> ::= <window name> | <in-line window specification>
window_name_or_specification : {window_name} window_name | {inline} in_line_window_specification;

// <in-line window specification> ::= <window specification>
in_line_window_specification : window_specification;

// <nested window function> ::= <nested row number function> | <value_of expression at row>
nested_window_function : {function} nested_row_number_function | {value} value_of_expression_at_row;

// <nested row number function> ::= ROW_NUMBER <left paren> <row marker> <right paren>
nested_row_number_function : t_row_number LEFT_PAREN row_marker RIGHT_PAREN;

// <value_of expression at row> ::= VALUE_OF <left paren> <value expression> AT <row marker expression> [ <comma> <value_of default value> ] <right paren>
value_of_expression_at_row : t_value_of LEFT_PAREN value_expression t_at row_marker_expression (COMMA value_of_default_value)? RIGHT_PAREN;

// <row marker> ::= BEGIN_PARTITION | BEGIN_FRAME | CURRENT_ROW | FRAME_ROW | END_FRAME | END_PARTITION
row_marker : {begin_partition} t_begin_partition | {begin_frame} t_begin_frame | {current_row} t_current_row | {frame_row} t_frame_row | {end_frame} t_end_frame | {end_partition} t_end_partition;

// <row marker expression> ::= <row marker> [ <row marker delta> ]
row_marker_expression : row_marker row_marker_delta?;

// <row marker delta> ::= <plus sign> <row marker offset> | <minus sign> <row marker offset>
row_marker_delta : {plus} PLUS_SIGN row_marker_offset | {minus} MINUS_SIGN row_marker_offset;

// <row marker offset> ::= <simple value specification> | <dynamic parameter specification>
row_marker_offset : {simple_value} simple_value_specification | {dynamic_parameter} dynamic_parameter_specification;

// <value_of default value> ::= <value expression>
value_of_default_value : value_expression;

// <case expression> ::= <case abbreviation> | <case specification>
case_expression : {abbreviation} case_abbreviation | {specification} case_specification;

// <case abbreviation> ::= NULLIF <left paren> <value expression> <comma> <value expression> <right paren>
// | COALESCE <left paren> <value expression> { <comma> <value expression> }... <right paren>
case_abbreviation : {null_if} t_nullif LEFT_PAREN value_expression COMMA value_expression RIGHT_PAREN
   | t_coalesce LEFT_PAREN value_expression (COMMA value_expression)+ RIGHT_PAREN;

// <case specification> ::= <simple case> | <searched case>
case_specification : {simple} simple_case | {searched} searched_case; 

// <simple case> ::= CASE <case operand> <simple when clause>... [ <else clause> ] END
simple_case : t_case case_operand simple_when_clause+ else_clause? t_end;

// <searched case> ::= CASE <searched when clause>... [ <else clause> ] END
searched_case : t_case searched_when_clause+ else_clause? t_end;

// <simple when clause> ::= WHEN <when operand list> THEN <result>
simple_when_clause : t_when when_operand_list t_then result;

// <searched when clause> ::= WHEN <search condition> THEN <result>
searched_when_clause : t_when search_condition t_then result; 

// <else clause> ::= ELSE <result>
else_clause : t_else result;

// <case operand> ::= <row value predicand> | <overlaps predicate part 1>
case_operand : {row_value} row_value_predicand | {overlaps} overlaps_predicate_part1;

// <when operand list> ::= <when operand> [ { <comma> <when operand> }... ]
when_operand_list : when_operand COMMA when_operand*;

// <when operand> ::= <row value predicand> | <comparison predicate part 2> | <between predicate part 2> | <in predicate part 2> | <character like predicate part 2>
//   | <octet like predicate part 2> | <similar predicate part 2> | <regex like predicate part 2> | <null predicate part 2> | <quantified comparison predicate part 2>
//   | <normalized predicate part 2> | <match predicate part 2> | <overlaps predicate part 2> | <distinct predicate part 2> | <member predicate part 2> | <submultiset predicate part 2>
//   | <set predicate part 2> | <type predicate part 2>
when_operand : {row_value} row_value_predicand | {comparison} comparison_predicate_part2 | {between} between_predicate_part2 | {in} in_predicate_part2 | {character} character_like_predicate_part2 |
  | {octet} octet_like_predicate_part2 | {similar} similar_predicate_part2 | {regex} regex_like_predicate_part2 | {null} null_predicate_part2 | {quantified} quantified_comparison_predicate_part2 
  | {normalized} normalized_predicate_part2 | {match} match_predicate_part2 | {overlaps} overlaps_predicate_part2 | {distinct} distinct_predicate_part2 | {member} member_predicate_part2 | {submultiset} submultiset_predicate_part2
  | {set} set_predicate_part2 | {type} type_predicate_part2;

// <result> ::= <result expression> | NULL
result : {result} result_expression | {null} t_null;

// <result expression> ::= <value expression>
result_expression : value_expression;

// <cast specification> ::= CAST <left paren> <cast operand> AS <cast target> <right paren>
cast_specification : t_cast LEFT_PAREN cast_operand t_as cast_target RIGHT_PAREN;

// <cast operand> ::= <value expression> | <implicitly typed value specification>
cast_operand : {value} value_expression | {implicit} implicitly_typed_value_specification;

// <cast target> ::= <domain name> | <data type>
cast_target : {domain_name} domain_name | {data_type} data_type;

// <next value expression> ::= NEXT VALUE FOR <sequence generator name>
next_value_expression : t_next t_value t_for sequence_generator_name;

// <field reference> ::= <value expression primary> <period> <field name>
field_reference : value_expression_primary PERIOD field_name;

// <subtype treatment> ::= TREAT <left paren> <subtype operand> AS <target subtype> <right paren>
subtype_treatment : t_treat LEFT_PAREN subtype_operand t_as target_subtype RIGHT_PAREN;

// <subtype operand> ::= <value expression>
subtype_operand : value_expression;

// <target subtype> ::= <path-resolved user-defined type name> | <reference type>
target_subtype : {user_defined} path_resolved_user_defined_type_name | {reference_type} reference_type;

// <method invocation> ::= <direct invocation> | <generalized invocation>
method_invocation : {direct} direct_invocation | {general} generalized_invocation;

// <direct invocation> ::= <value expression primary> <period> <method name> [ <SQL argument list> ]
direct_invocation : value_expression_primary PERIOD method_name sql_argument_list?;

// <generalized invocation> ::= <left paren> <value expression primary> AS <data type> <right paren> <period> <method name> [ <SQL argument list> ]
generalized_invocation : LEFT_PAREN value_expression_primary t_as data_type RIGHT_PAREN PERIOD method_name sql_argument_list?;

// <method selection> ::= <routine invocation>
// <constructor method selection> ::= <routine invocation>

// <static method invocation> ::= <path-resolved user-defined type name> <double COLON> <method name> [ <SQL argument list> ]
static_method_invocation : path_resolved_user_defined_type_name DOUBLE_COLON method_name sql_argument_list?;

// <static method selection> ::= <routine invocation>
// <new specification> ::= NEW <path-resolved user-defined type name> <SQL argument list>
new_specification : t_new path_resolved_user_defined_type_name method_name sql_argument_list;

// <new invocation> ::= <method invocation> | <routine invocation>
// <attribute or method reference> ::= <value expression primary> <dereference operator> <qualified identifier> [ <SQL argument list> ]
attribute_or_method_reference : value_expression_primary dereference_operator qualified_identifier sql_argument_list;

// <dereference operator> ::= <right arrow>
dereference_operator : RIGHT_ARROW;

// <dereference operation> ::= <reference value expression> <dereference operator> <attribute name>
// <method reference> ::= <value expression primary> <dereference operator> <method name> <SQL argument list>
// <reference resolution> ::= DEREF <left paren> <reference value expression> <right paren>
reference_resolution : t_deref LEFT_PAREN reference_value_expression RIGHT_PAREN;

// <array element reference> ::= <array value expression> <left bracket or trigraph> <numeric value expression> <right bracket or trigraph>
array_element_reference : array_value_expression left_bracket_or_trigraph numeric_value_expression right_bracket_or_trigraph;

// <multiset element reference> ::= ELEMENT <left paren> <multiset value expression> <right paren>
multiset_element_reference : t_element LEFT_PAREN multiset_value_expression RIGHT_PAREN;

// <routine invocation> ::= <routine name> <SQL argument list>
routine_invocation : routine_name sql_argument_list;

// <routine name> ::= [ <schema name> <period> ] <qualified identifier>
routine_name : (schema_name PERIOD)? qualified_identifier;

// <SQL argument list> ::= <left paren> [ <SQL argument> [ { <comma> <SQL argument> }... ] ] <right paren>
sql_argument_list : LEFT_PAREN (sql_argument (COMMA sql_argument)*)? RIGHT_PAREN;

// <SQL argument> ::= <value expression> | <generalized expression> | <target specification> | <contextually typed value specification> | <named argument specification>
sql_argument : {value} value_expression | {general} generalized_expression | {target} target_specification | {context} contextually_typed_value_specification | {named} named_argument_specification;

// <generalized expression> ::= <value expression> AS <path-resolved user-defined type name>
generalized_expression : value_expression t_as path_resolved_user_defined_type_name;

// <named argument specification> ::= <SQL parameter name> <named argument assignment token> <named argument SQL argument>
named_argument_specification : sql_parameter_name NAMED_ARGUMENT_ASSIGNMENT_TOKEN named_argument_sql_argument;

// <named argument SQL argument> ::= <value expression> | <target specification> | <contextually typed value specification>
named_argument_sql_argument : {value} value_expression | {target} target_specification | {context} contextually_typed_value_specification;

// <array value constructor> ::= <array value constructor by enumeration> | <array value constructor by query>
array_value_constructor : {enum} array_value_constructor_by_enumeration | {query} array_value_constructor_by_query;

// <array value constructor by enumeration> ::= ARRAY <left bracket or trigraph> <array element list> <right bracket or trigraph>
array_value_constructor_by_enumeration : t_array left_bracket_or_trigraph array_element_list right_bracket_or_trigraph;

// <array element list> ::= <array element> [ { <comma> <array element> }... ]
array_element_list : array_element (COMMA array_element)*;

// <array element> ::= <value expression>
array_element : value_expression;

// <array value constructor by query> ::= ARRAY <table subquery>
array_value_constructor_by_query : t_array table_subquery;

// <multiset value constructor> ::= <multiset value constructor by enumeration> | <multiset value constructor by query> | <table value constructor by query>
multiset_value_constructor : {enum} multiset_value_constructor_by_enumeration | {query} multiset_value_constructor_by_query | {table} table_value_constructor_by_query;

// <multiset value constructor by enumeration> ::= MULTISET <left bracket or trigraph> <multiset element list> <right bracket or trigraph>
multiset_value_constructor_by_enumeration : t_multiset left_bracket_or_trigraph multiset_element_list right_bracket_or_trigraph;

// <multiset element list> ::= <multiset element> [ { <comma> <multiset element> }... ]
multiset_element_list : multiset_element (COMMA multiset_element)*;

// <multiset element> ::= <value expression>
multiset_element : value_expression;

// <multiset value constructor by query> ::= MULTISET <table subquery>
multiset_value_constructor_by_query : t_multiset table_subquery;

// <table value constructor by query> ::= TABLE <table subquery>
table_value_constructor_by_query : t_table table_subquery;

// <interval qualifier> ::= <start field> TO <end field> | <single datetime field>
interval_qualifier : {range} start_field t_to end_field | {single} single_datetime_field;

// <start field> ::= <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
start_field : non_second_primary_datetime_field (LEFT_PAREN interval_leading_field_precision RIGHT_PAREN)?;

// <end field> ::= <non-second primary datetime field> | SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]
end_field : {primary} non_second_primary_datetime_field | {second} t_second  interval_fractional_seconds_precision?;

// <single datetime field> ::= <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
//   | SECOND [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]
single_datetime_field : non_second_primary_datetime_field (LEFT_PAREN interval_leading_field_precision RIGHT_PAREN)?
   | {second} t_second (LEFT_PAREN interval_leading_field_precision (COMMA interval_fractional_seconds_precision)? RIGHT_PAREN)?;

// <primary datetime field> ::= <non-second primary datetime field> | SECOND
primary_datetime_field : {primary} non_second_primary_datetime_field | {second} t_second;

// <non-second primary datetime field> ::= YEAR | MONTH | DAY | HOUR | MINUTE
non_second_primary_datetime_field : {year} t_year | {month} t_month | {day} t_day | {hour} t_hour | {minute} t_minute;

// <interval fractional seconds precision> ::= <unsigned integer>
interval_fractional_seconds_precision : unsigned_integer;

// <interval leading field precision> ::= <unsigned integer>
interval_leading_field_precision : unsigned_integer;

// <interval value function> ::= <interval absolute value function>
interval_value_function : interval_absolute_value_function;

// <interval absolute value function> ::= ABS <left paren> <interval value expression> <right paren> 
interval_absolute_value_function : t_abs LEFT_PAREN interval_value_expression RIGHT_PAREN;

// <table expression> ::= <from clause> [ <where clause> ] [ <group by clause> ] [ <having clause> ] [ <window clause> ]
table_expression : from_clause where_clause? group_by_clause? having_clause? window_clause?;

// <numeric value function> ::= <position expression> | <regex occurrences function> | <regex position expression> | <extract expression> | <length expression>
//   | <cardinality expression> | <max cardinality expression> | <absolute value expression> | <modulus expression> | <natural logarithm> | <exponential function>
//   | <power function> | <square root> | <floor function> | <ceiling function> | <width bucket function>
numeric_value_function : {pos} position_expression | {regex_occ} regex_occurrences_function | {regex_pos} regex_position_expression | {extract} extract_expression | {len} length_expression
   | {card} cardinality_expression | {max_card} max_cardinality_expression | {abs} absolute_value_expression | {mod} modulus_expression | {logn} natural_logarithm | {exp} exponential_function
   | {pow} power_function | {sqr} square_root | {floor} floor_function | {ceil} ceiling_function | {width} width_bucket_function;

// <position expression> ::= <character position expression> | <binary position expression>
position_expression : {character_position} character_position_expression | {binary_position} binary_position_expression;

// <regex occurrences function> ::= OCCURRENCES_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ FROM <start position> ] [ USING <char length units> ] <right paren>
regex_occurrences_function : t_occurrences_regex LEFT_PAREN xquery_pattern (t_flag xquery_option_flag)? t_in regex_subject_string (t_from start_position)? (t_using char_length_units)? RIGHT_PAREN;

// <XQuery pattern> ::= <character value expression>
xquery_pattern : character_value_expression;

// <XQuery option flag> ::= <character value expression>
xquery_option_flag : character_value_expression;

// <regex subject string> ::= <character value expression>
regex_subject_string : character_value_expression;

// <regex position expression> ::= POSITION_REGEX <left paren> [ <regex position start or after> ] <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ FROM <start position> ] [ USING <char length units> ] [ OCCURRENCE <regex occurrence> ] [ GROUP <regex capture group> ] <right paren>
regex_position_expression : t_position_regex LEFT_PAREN regex_position_start_or_after? xquery_pattern (t_flag xquery_option_flag)? t_in regex_subject_string (t_from start_position)? (t_using char_length_units)? (t_occurrence regex_occurrence)? (t_group regex_capture_group)? RIGHT_PAREN;

// <regex position start or after> ::= START | AFTER
regex_position_start_or_after : {start} t_start | {after} t_after;

// <regex occurrence> ::= <numeric value expression>
regex_occurrence : numeric_value_expression;

// <regex capture group> ::= <numeric value expression>
regex_capture_group : numeric_value_expression;

// <character position expression> ::= POSITION <left paren> <character value expression 1> IN <character value expression 2> [ USING <char length units> ] <right paren>
character_position_expression : t_position LEFT_PAREN character_value_expression1 t_in character_value_expression2 (t_using char_length_units)? RIGHT_PAREN;

// <character value expression 1> ::= <character value expression>
character_value_expression1 : character_value_expression;

//<character value expression 2> ::= <character value expression>
character_value_expression2 : character_value_expression;

// <binary position expression> ::= POSITION <left paren> <binary value expression> IN <binary value expression> <right paren>
binary_position_expression : t_position LEFT_PAREN binary_value_expression t_in binary_value_expression RIGHT_PAREN;

// <length expression> ::= <char length expression> | <octet length expression>
length_expression : {char_length} char_length_expression | {octet_length} octet_length_expression;

// <char length expression> ::= { CHAR_LENGTH | CHARACTER_LENGTH } <left paren> <character value expression> [ USING <char length units> ] <right paren>
char_length_expression : (t_char_length | t_character_length) LEFT_PAREN character_value_expression (t_using char_length_units)? RIGHT_PAREN;

// <octet length expression> ::= OCTET_LENGTH <left paren> <string value expression> <right paren>
octet_length_expression : t_octet_length LEFT_PAREN string_value_expression RIGHT_PAREN;

// <extract expression> ::= EXTRACT <left paren> <extract field> FROM <extract source> <right paren>
extract_expression : t_extract LEFT_PAREN extract_field t_from extract_source RIGHT_PAREN;

// <extract field> ::= <primary datetime field> | <time zone field>
extract_field : {primary} primary_datetime_field | {time_zone} time_zone_field;

// <time zone field> ::= TIMEZONE_HOUR | TIMEZONE_MINUTE
time_zone_field : {hour} t_timezone_hour | {minute} t_timezone_minute;

// <extract source> ::= <datetime value expression> | <interval value expression>
extract_source : {datetime} datetime_value_expression | {interval} interval_value_expression;

// <cardinality expression> ::= CARDINALITY <left paren> <collection value expression> <right paren>
cardinality_expression : t_cardinality LEFT_PAREN collection_value_expression RIGHT_PAREN;

// <max cardinality expression> ::= ARRAY_MAX_CARDINALITY <left paren> <array value expression> <right paren> 
max_cardinality_expression : t_array_max_cardinality LEFT_PAREN array_value_expression RIGHT_PAREN;

// <absolute value expression> ::= ABS <left paren> <numeric value expression> <right paren>
absolute_value_expression : t_abs LEFT_PAREN numeric_value_expression RIGHT_PAREN;

// <modulus expression> ::= MOD <left paren> <numeric value expression dividend> <comma> <numeric value expression divisor><right paren> 
modulus_expression : t_mod LEFT_PAREN numeric_value_expression_dividend COMMA numeric_value_expression_divisor RIGHT_PAREN;

// <numeric value expression dividend> ::= <numeric value expression>
numeric_value_expression_dividend : numeric_value_expression;

// <numeric value expression divisor> ::= <numeric value expression>
numeric_value_expression_divisor : numeric_value_expression;

// <natural logarithm> ::= LN <left paren> <numeric value expression> <right paren>
natural_logarithm : t_ln LEFT_PAREN numeric_value_expression RIGHT_PAREN;

// <exponential function> ::= EXP <left paren> <numeric value expression> <right paren>
exponential_function : t_exp LEFT_PAREN numeric_value_expression RIGHT_PAREN;

// <power function> ::= POWER <left paren> <numeric value expression base> <comma> <numeric value expression exponent> <right paren>
power_function : t_power LEFT_PAREN numeric_value_expression_base COMMA numeric_value_expression_exponent RIGHT_PAREN;

// <numeric value expression base> ::= <numeric value expression>
numeric_value_expression_base : numeric_value_expression;

// <numeric value expression exponent> ::= <numeric value expression>
numeric_value_expression_exponent : numeric_value_expression;

// <square root> ::= SQRT <left paren> <numeric value expression> <right paren>
square_root : t_sqrt LEFT_PAREN numeric_value_expression RIGHT_PAREN;

// <floor function> ::= FLOOR <left paren> <numeric value expression> <right paren>
floor_function : t_floor LEFT_PAREN numeric_value_expression RIGHT_PAREN;

// <ceiling function> ::= { CEIL | CEILING } <left paren> <numeric value expression> <right paren>
ceiling_function : (t_ceil | t_ceiling) LEFT_PAREN numeric_value_expression RIGHT_PAREN;

// <width bucket function> ::= WIDTH_BUCKET <left paren> <width bucket operand> <comma> <width bucket bound 1> <comma> <width bucket bound 2> <comma> <width bucket count> <right paren> 
width_bucket_function : t_width_bucket LEFT_PAREN width_bucket_operand COMMA width_bucket_bound1 COMMA width_bucket_bound2 COMMA width_bucket_count RIGHT_PAREN;

// <width bucket operand> ::= <numeric value expression>
width_bucket_operand : numeric_value_expression;

// <width bucket bound 1> ::= <numeric value expression>
width_bucket_bound1 : numeric_value_expression;

// <width bucket bound 2> ::= <numeric value expression>
width_bucket_bound2 : numeric_value_expression;

// <width bucket count> ::= <numeric value expression>
width_bucket_count : numeric_value_expression;

// <collate clause> ::= COLLATE <collation name>
collate_clause : t_collate collation_name;

// <string value function> ::= <character value function> | <binary value function>
string_value_function : {character} character_value_function | {binary} binary_value_function;

// <character value function> ::= <character substring function> | <regular expression substring function> | <regex substring function>
//   | <fold> | <transcoding> | <character transliteration> | <regex transliteration> | <trim function> | <character overlay function>
//   | <normalize function> | <specific type method>
character_value_function : {character_substring} character_substring_function | {regular_substring} regular_expession_substring_function | {regex_substring} regex_substring_function
  | {fold} fold | {transcoding} transcoding | {char_trans} character_transliteration | {regex_trans} regex_transliteration | {trim} trim_function | {overlay} character_overlay_function
  | {normalize} normalize_function | {specific} specific_type_method;

// <character substring function> ::= SUBSTRING <left paren> <character value expression> FROM <start position> [ FOR <string length> ] [ USING <char length units> ] <right paren>
character_substring_function : t_substring LEFT_PAREN character_value_expression t_from start_position (t_for string_length)? (t_using char_length_units)? RIGHT_PAREN;

// <regular expression substring function> ::= SUBSTRING <left paren> <character value expression> SIMILAR <character value expression> ESCAPE <escape character> <right paren>
regular_expession_substring_function : t_substring LEFT_PAREN character_value_expression t_similar character_value_expression t_escape escape_character RIGHT_PAREN;

// <regex substring function> ::= SUBSTRING_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ FROM <start position> ] [ USING <char length units> ] [ OCCURRENCE <regex occurrence> ] [ GROUP <regex capture group> ] <right paren>
regex_substring_function : t_substring_regex LEFT_PAREN xquery_pattern (t_flag xquery_option_flag)? t_in regex_subject_string (t_from start_position)? (t_using char_length_units)? (t_occurrence regex_occurrence)? (t_group regex_capture_group)? RIGHT_PAREN;

// <fold> ::= { UPPER | LOWER } <left paren> <character value expression> <right paren>
fold : (t_upper | t_lower) LEFT_PAREN character_value_expression RIGHT_PAREN;

// <transcoding> ::= CONVERT <left paren> <character value expression> USING <transcoding name> <right paren>
transcoding : t_convert LEFT_PAREN character_value_expression t_using transcoding_name RIGHT_PAREN;

// <character transliteration> ::= TRANSLATE <left paren> <character value expression> USING <transliteration name> <right paren>
character_transliteration : t_translate LEFT_PAREN character_value_expression t_using transliteration_name RIGHT_PAREN;

// <regex transliteration> ::= TRANSLATE_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ WITH <XQuery replacement string> ] [ FROM <start position> ] [ USING <char length units> ] [ OCCURRENCE <regex transliteration occurrence> ] <right paren>
regex_transliteration : t_translate_regex LEFT_PAREN xquery_pattern (t_flag xquery_option_flag)? t_in regex_subject_string (t_with xquery_replacement_string)? (t_from start_position)? (t_using char_length_units)? (t_occurrence regex_transliteration_occurrence)?  RIGHT_PAREN;

// <XQuery replacement string> ::= <character value expression>
xquery_replacement_string : character_value_expression;

// <regex transliteration occurrence> ::= <regex occurrence> | ALL
regex_transliteration_occurrence : {regex} regex_occurrence | {all} t_all;

// <trim function> ::= TRIM <left paren> <trim operands> <right paren>
trim_function : t_trim LEFT_PAREN trim_operands RIGHT_PAREN;

// <trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>
trim_operands : (trim_specification? trim_character? t_from)? trim_source;

// <trim source> ::= <character value expression>
trim_source : character_value_expression;

// <trim specification> ::= LEADING | TRAILING | BOTH
trim_specification : {leading} t_leading | {trailing} t_trailing | {both} t_both;

// <trim character> ::= <character value expression>
trim_character : character_value_expression;

// <character overlay function> ::= OVERLAY <left paren> <character value expression> PLACING <character value expression> FROM <start position> [ FOR <string length> ] [ USING <char length units> ] <right paren>
character_overlay_function : t_overlay LEFT_PAREN character_value_expression t_placing character_value_expression t_from start_position (t_for string_length)? (t_using char_length_units)? RIGHT_PAREN;

// <normalize function> ::= NORMALIZE <left paren> <character value expression> [ <comma> <normal form> [ <comma> <normalize function result length> ] ] <right paren>
normalize_function : t_normalize LEFT_PAREN character_value_expression (COMMA normal_form (COMMA normalize_function_result_length)?)? RIGHT_PAREN;

// <normal form> ::= NFC | NFD | NFKC | NFKD
normal_form : {nfc} t_nfc | {nfd} t_nfd | {nfkc} t_nfkc | {nfkd} t_nfkd;

// <normalize function result length> ::= <character length> | <character large object length>
normalize_function_result_length : {character} character_length | {clob} character_large_object_length;

// <specific type method> ::= <user-defined type value expression> <period> SPECIFICTYPE [ <left paren> <right paren> ]
specific_type_method : user_defined_type_value_expression PERIOD t_specifictype (LEFT_PAREN RIGHT_PAREN)?;

// <binary value function> ::= <binary substring function> | <binary trim function> | <binary overlay function>
binary_value_function : {substring} binary_substring_function | {trim} binary_trim_function | {overlay} binary_overlay_function;

// <binary substring function> ::= SUBSTRING <left paren> <binary value expression> FROM <start position> [ FOR <string length> ] <right paren>
binary_substring_function : t_substring LEFT_PAREN binary_value_expression t_from start_position (t_for string_length)? RIGHT_PAREN;

// <binary trim function> ::= TRIM <left paren> <binary trim operands> <right paren>
binary_trim_function : t_trim LEFT_PAREN binary_trim_operands RIGHT_PAREN;

// <binary trim operands> ::= [ [ <trim specification> ] [ <trim octet> ] FROM ] <binary trim source>
binary_trim_operands : (trim_specification? trim_octet? t_from)? binary_trim_source;

// <binary trim source> ::= <binary value expression>
binary_trim_source : binary_value_expression;

// <trim octet> ::= <binary value expression>
trim_octet : binary_value_expression;

// <binary overlay function> ::= OVERLAY <left paren> <binary value expression> PLACING <binary value expression> FROM <start position> [ FOR <string length> ] <right paren>
binary_overlay_function : t_overlay LEFT_PAREN binary_value_expression t_placing binary_value_expression t_from start_position (t_for string_length)? RIGHT_PAREN;

// <start position> ::= <numeric value expression>
start_position : numeric_value_expression;

// <string length> ::= <numeric value expression>
string_length : numeric_value_expression;

// <array value function> ::= <trim array function>
array_value_function : trim_array_function;

// <trim array function> ::= TRIM_ARRAY <left paren> <array value expression> <comma> <numeric value expression> <right paren>iden
trim_array_function : t_trim_array LEFT_PAREN array_value_expression COMMA numeric_value_expression RIGHT_PAREN;

// <multiset value function> ::= <multiset set function>
multiset_value_function : multiset_set_function;

// <multiset set function> ::= SET <left paren> <multiset value expression> <right paren>
multiset_set_function : t_set LEFT_PAREN multiset_value_expression RIGHT_PAREN;

// <identifier chain> ::= <identifier> [ { <period> <identifier> }... ]
identifier_chain : identifier (PERIOD identifier)*;

// <basic identifier chain> ::= <identifier chain>
basic_identifier_chain : identifier_chain;

// <embedded variable name> ::= <COLON><host identifier>
embedded_variable_name : COLON host_identifier;

// <host identifier> ::= <Ada host identifier> | <C host identifier> | <COBOL host identifier> | <Fortran host identifier> | <MUMPS host identifier> | <Pascal host identifier> | <PL/I host identifier>
host_identifier : {ada} t_ada | {c} t_c | {cobol} t_cobol | {fortran} t_fortran
   | {mumps} t_mumps | {pascal} t_pascal | {pli} t_pli;

// <constraint name definition> ::= CONSTRAINT <constraint name>
constraint_name_definition : t_constraint constraint_name;

// <constraint characteristics> ::= <constraint check time> [ [ NOT ] DEFERRABLE ] [ <constraint enforcement> ] | [ NOT ] DEFERRABLE [ <constraint check time> ] [ <constraint enforcement> ] | <constraint enforcement>
constraint_characteristics : {check} constraint_check_time (t_not? t_deferrable)? constraint_enforcement? 
   | {not} t_not? t_deferrable constraint_check_time? constraint_enforcement?  | {enforce} constraint_enforcement;

// <constraint check time> ::= INITIALLY DEFERRED | INITIALLY IMMEDIATE
constraint_check_time : {deferred} t_initially t_deferred | {immediate} t_initially t_immediate;

// <constraint enforcement> ::= [ NOT ] ENFORCED
constraint_enforcement : t_not? t_enforced;

// <unique constraint definition> ::= <unique specification> <left paren> <unique column list> [ <comma> <without overlap specification> ] <right paren> | UNIQUE ( VALUE )
unique_constraint_definition : {spec} unique_specification LEFT_PAREN unique_column_list (COMMA without_overlap_specification)? RIGHT_PAREN | {unique} t_unique LEFT_PAREN t_value RIGHT_PAREN;

// <unique specification> ::= UNIQUE | PRIMARY KEY
unique_specification : {unique} t_unique | {pk} t_primary t_key;

// <unique column list> ::= <column name list>
unique_column_list : column_name_list;

// <without overlap specification> ::= <application time PERIOD name> WITHOUT OVERLAPS
without_overlap_specification : application_time_period_name t_without t_overlaps;

// <referential constraint definition> ::= FOREIGN KEY <left paren> <referencing column list> [ <comma> <referencing period specification> ] <right paren> <references specification>
referential_constraint_definition : t_foreign t_key LEFT_PAREN referencing_column_list (COMMA referencing_period_specification)? RIGHT_PAREN references_specification;

// <references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]
references_specification : t_references referenced_table_and_columns (t_match match_type)? referential_triggered_action?;
match_match_type : ;

// <match type> ::= FULL | PARTIAL | SIMPLE
match_type : {full} t_full | {partial} t_partial | {simple} t_simple;

// <referencing column list> ::= <column name list>
referencing_column_list : column_name_list;

// <referencing PERIOD specification> ::= PERIOD <application time PERIOD name>
referencing_period_specification : t_period application_time_period_name;

// <referenced table and columns> ::= <table name> [ <left paren> <referenced column list> [ <comma> <referenced period specification> ] <right paren> ]
referenced_table_and_columns : table_name (LEFT_PAREN referenced_column_list (COMMA referenced_period_specification)? RIGHT_PAREN)?;

// <referenced column list> ::= <column name list>
referenced_column_list : column_name_list;

// <referenced PERIOD specification> ::= PERIOD <application time PERIOD name>
referenced_period_specification : t_period application_time_period_name;

// <referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]
referential_triggered_action : {update} update_rule delete_rule? | {delete} delete_rule update_rule?;

// <update rule> ::= ON UPDATE <referential action>
update_rule : t_on t_update referential_action;

// <delete rule> ::= ON DELETE <referential action>
delete_rule : t_on t_delete referential_action;

// <referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION
referential_action : {cascade} t_cascade | {set_null} t_set t_null | {set_default} t_set t_default | {restrict} t_restrict | {no_action} t_no t_action; 

// <check constraint definition> ::= CHECK <left paren> <search condition> <right paren>
check_constraint_definition : t_check LEFT_PAREN search_condition RIGHT_PAREN;

// <sequence generator definition> ::= CREATE SEQUENCE <sequence generator name> [ <sequence generator options> ]
// <sequence generator options> ::= <sequence generator option> ...
// <sequence generator option> ::= <sequence generator data type option> | <common sequence generator options>
// <common sequence generator options> ::= <common sequence generator option> ...
common_sequence_generator_options : common_sequence_generator_option+;

// <common sequence generator option> ::= <sequence generator start with option> | <basic sequence generator option>
common_sequence_generator_option : {start_with} sequence_generator_start_with_option | {basic} basic_sequence_generator_option;
// <basic sequence generator option> ::= <sequence generator increment by option> | <sequence generator maxvalue option> | <sequence generator minvalue option>
//  | <sequence generator cycle option>
basic_sequence_generator_option : {increment} sequence_generator_increment_by_option | {max_value} sequence_generator_maxvalue_option | {min_value} sequence_generator_minvalue_option
   | {cycle} sequence_generator_cycle_option;

// <sequence generator data type option> ::= AS <data type>
sequence_generator_data_type_option : t_as data_type;

// <sequence generator start with option> ::= START WITH <sequence generator start value>
sequence_generator_start_with_option : t_start t_with sequence_generator_start_value;

// <sequence generator start value> ::= <signed numeric literal>
sequence_generator_start_value : signed_numeric_literal;

// <sequence generator increment by option> ::= INCREMENT BY <sequence generator increment>
sequence_generator_increment_by_option : t_increment t_by sequence_generator_increment;

// <sequence generator increment> ::= <signed numeric literal>
sequence_generator_increment : signed_numeric_literal;

// <sequence generator maxvalue option> ::= MAXVALUE <sequence generator max value> | NO MAXVALUE
sequence_generator_maxvalue_option : {maxvalue} t_maxvalue sequence_generator_max_value | {no_maxvalue} t_no t_maxvalue; 

// sequence generator max value> ::= <signed numeric literal>
sequence_generator_max_value : signed_numeric_literal;

// <sequence generator minvalue option> ::= MINVALUE <sequence generator min value> | NO MINVALUE
sequence_generator_minvalue_option : {minvalue} t_minvalue sequence_generator_min_value | {no_minvalue} t_no t_minvalue; 

// <sequence generator min value> ::= <signed numeric literal>
sequence_generator_min_value : signed_numeric_literal;

// <sequence generator cycle option> ::= CYCLE | NO CYCLE
sequence_generator_cycle_option : {cycle} t_cycle | {no_cycle} t_no t_cycle;

// <field definition> ::= <field name> <data type>
field_definition : field_name data_type;

// <aggregate function> ::= COUNT <left paren> <ASTERISK> <right paren> [ <filter clause> ] | <general set function> [ <filter clause> ]
//    | <binary set function> [ <filter clause> ] | <ordered set function> [ <filter clause> ] | <array aggregate function> [ <filter clause> ]
aggregate_function : t_count LEFT_PAREN ASTERISK RIGHT_PAREN filter_clause? | general_set_function filter_clause?
   | binary_set_function filter_clause? | ordered_set_function filter_clause? | array_aggregate_function filter_clause?;

// <general set function> ::=<set function type> <left paren> [ <set quantifier> ] <value expression> <right paren>
general_set_function : set_function_type LEFT_PAREN set_quantifier? value_expression RIGHT_PAREN;

// <set function type> ::=<computational operation>
set_function_type : computational_operation;

// <computational operation> ::= AVG | MAX | MIN | SUM | EVERY | ANY | SOME | COUNT | STDDEV_POP | STDDEV_SAMP | VAR_SAMP | VAR_POP | COLLECT | FUSION | INTERSECTION
computational_operation : {avg} t_avg | {max} t_max | {min} t_min | {sum} t_sum | {every} t_every | {any} t_any | {some} t_some | t_count | {stddev_pop} t_stddev_pop
 | {stddev_samp} t_stddev_samp | {var_samp} t_var_samp | {var_pop} t_var_pop | {collect} t_collect | {fusion} t_fusion | {intersection} t_intersection;

// <set quantifier> ::= DISTINCT | ALL
set_quantifier : {distinct} t_distinct | {all} t_all;

// <filter clause> ::= FILTER <left paren> WHERE <search condition> <right paren>
filter_clause : t_filter LEFT_PAREN t_where search_condition RIGHT_PAREN;

// <binary set function> ::= <binary set function type> <left paren> <dependent variable expression> <comma> <independent variable expression> <right paren>
binary_set_function : binary_set_function_type LEFT_PAREN dependent_variable_expression COMMA independent_variable_expression RIGHT_PAREN;

// <binary set function type> ::= COVAR_POP | COVAR_SAMP | CORR | REGR_SLOPE | REGR_INTERCEPT | REGR_COUNT | REGR_R2 | REGR_AVGX | REGR_AVGY | REGR_SXX | REGR_SYY | REGR_SXY
binary_set_function_type : {covar_pop} t_covar_pop | {covar_samp} t_covar_samp | {corr} t_corr | {regr_slope} t_regr_slope | {regr_intercept} t_regr_intercept
 | {regr_count} t_regr_count | {regr_r2} t_regr_r2 | {regr_avgx} t_regr_avgx | {regr_avgy} t_regr_avgy | {regr_sxx} t_regr_sxx | {regr_syy} t_regr_syy | {regr_sxy} t_regr_sxy  ;

// <dependent variable expression> ::= <numeric value expression>
dependent_variable_expression : numeric_value_expression;

// <independent variable expression> ::= <numeric value expression>
independent_variable_expression : numeric_value_expression;

// <ordered set function> ::= <hypothetical set function> | <inverse distribution function>
ordered_set_function : {hypothetical} hypothetical_set_function | {inverse} inverse_distribution_function;

// <hypothetical set function> ::= <rank function type> <left paren> <hypothetical set function value expression list> <right paren> <within group specification>
hypothetical_set_function : rank_function_type LEFT_PAREN hypothetical_set_function_value_expression_list RIGHT_PAREN within_group_specificaton;

// <within group specification> ::= WITHIN GROUP <left paren> ORDER BY <sort specification list> <right paren>
within_group_specificaton : t_within t_group LEFT_PAREN t_order t_by sort_specification_list RIGHT_PAREN;

// <hypothetical set function value expression list> ::= <value expression> [ { <comma> <value expression> }... ]
hypothetical_set_function_value_expression_list : value_expression (COMMA value_expression)*;

// <inverse distribution function> ::= <inverse distribution function type> <left paren> <inverse distribution function argument> <right paren> <within group specification>
inverse_distribution_function : inverse_distribution_function_type LEFT_PAREN inverse_distribution_function_argument RIGHT_PAREN within_group_specificaton;

// <inverse distribution function argument> ::= <numeric value expression>
inverse_distribution_function_argument : numeric_value_expression;

// <inverse distribution function type> ::= PERCENTILE_CONT | PERCENTILE_DISC
inverse_distribution_function_type : {cont} t_percentile_cont | {disc} t_percentile_disc;

// <array aggregate function> ::= ARRAY_AGG <left paren> <value expression> [ ORDER BY <sort specification list> ] <right paren>
array_aggregate_function : t_array_agg LEFT_PAREN value_expression (t_order t_by sort_specification_list)? RIGHT_PAREN;

// <window clause> ::= WINDOW <window definition list>
window_clause : t_window window_definition_list;

// <window definition list> ::= <window definition> [ { <comma> <window definition> }... ]
window_definition_list : window_definition (COMMA window_definition)*;

// <window definition> ::= <new window name> AS <window specification>
window_definition : new_window_name t_as window_specification;

// <new window name> ::= <window name>
new_window_name : window_name;

// <window specification> ::= <left paren> <window specification details> <right paren>
window_specification : LEFT_PAREN window_specification_details RIGHT_PAREN;

// <window specification details> ::= [ <existing window name> ] [ <window partition clause> ] [ <window order clause> ] [ <window frame clause> ]
window_specification_details : existing_window_name? window_partition_clause? window_order_clause? window_frame_clause?;

// <existing window name> ::= <window name>
existing_window_name : window_name;

// <window partition clause> ::= PARTITION BY <window partition column reference list>
window_partition_clause : t_partition t_by window_partition_column_reference_list;

// <window partition column reference list> ::= <window partition column reference> [ { <comma> <window partition column reference> }... ]
window_partition_column_reference_list : window_partition_column_reference (COMMA window_partition_column_reference)*;

// <window partition column reference> ::= <column reference> [ <collate clause> ]
window_partition_column_reference : column_reference collate_clause?;

// <window order clause> ::= ORDER BY <sort specification list>
window_order_clause : t_order t_by sort_specification_list;

// <window frame clause> ::= <window frame units> <window frame extent> [ <window frame exclusion> ]
window_frame_clause : window_frame_units window_frame_extent window_frame_exclusion?;

// <window frame units> ::= ROWS | RANGE | GROUPS
window_frame_units : {rows} t_rows | {range} t_range | {groups} t_groups;

// <window frame extent> ::= <window frame start> | <window frame between>
window_frame_extent : {start} window_frame_start | {between} window_frame_between;

// <window frame start> ::= UNBOUNDED PRECEDING | <window frame preceding> | CURRENT ROW
window_frame_start : {unbounded} t_unbounded t_preceding | {window} window_frame_preceding | {current_row} t_current t_row;

// <window frame preceding> ::= <unsigned value specification> PRECEDING
window_frame_preceding : unsigned_value_specification t_preceding;

// <window frame between> ::= BETWEEN <window frame bound 1> AND <window frame bound 2>
window_frame_between : t_between window_frame_bound1 t_and window_frame_bound2;

// <window frame bound 1> ::= <window frame bound>
window_frame_bound1 : window_frame_bound;

// <window frame bound 2> ::= <window frame bound>
window_frame_bound2 : window_frame_bound;

// <window frame bound> ::= <window frame start> | UNBOUNDED FOLLOWING | <window frame following> 
window_frame_bound : {window_start} window_frame_start | {unbounded} t_unbounded t_following | {window_following} window_frame_following;

// <window frame following> ::= <unsigned value specification> FOLLOWING
window_frame_following : unsigned_value_specification t_following;

// <window frame exclusion> ::= EXCLUDE CURRENT ROW | EXCLUDE GROUP | EXCLUDE TIES | EXCLUDE NO OTHERS
window_frame_exclusion : {current_row} t_exclude t_current t_row | {group} t_exclude t_group | {ties} t_exclude t_ties | {no_others} t_exclude t_no t_others; 

// <from clause> ::= FROM <table reference list>
from_clause : t_from table_reference_list;

// <table reference list> ::= <table reference> [ { <comma> <table reference> }... ]
table_reference_list : table_reference (COMMA table_reference)*;

// <group by clause> ::= GROUP BY [ <set quantifier> ] <grouping element list>
group_by_clause : t_group t_by set_quantifier? grouping_element_list;

// <grouping element list> ::= <grouping element> [ { <comma> <grouping element> }... ]
grouping_element_list : grouping_element (COMMA grouping_element)*;

// <grouping element> ::= <ordinary grouping set> | <rollup list> | <cube list> | <grouping sets specification> | <empty grouping set>
grouping_element : {ordinary} ordinary_grouping_set | {rollup} rollup_list | {cube} cube_list | {spec} grouping_sets_specification | {empty} empty_grouping_set; 

// <ordinary grouping set> ::= <grouping column reference> | <left paren> <grouping column reference list> <right paren>
ordinary_grouping_set : {single} grouping_column_reference | {list} LEFT_PAREN grouping_column_reference_list RIGHT_PAREN;

// <grouping column reference> ::= <column reference> [ <collate clause> ]
grouping_column_reference : column_reference collate_clause;

// <grouping column reference list> ::= <grouping column reference> [ { <comma> <grouping column reference> }... ]
grouping_column_reference_list : grouping_column_reference (COMMA grouping_column_reference)*;
addl_grouping_column_reference : ;

// <rollup list> ::= ROLLUP <left paren> <ordinary grouping set list> <right paren>
rollup_list : t_rollup LEFT_PAREN ordinary_grouping_set_list RIGHT_PAREN;

// <ordinary grouping set list> ::= <ordinary grouping set> [ { <comma> <ordinary grouping set> }... ]
ordinary_grouping_set_list : ordinary_grouping_set (COMMA ordinary_grouping_set)*;

// <cube list> ::= CUBE <left paren> <ordinary grouping set list> <right paren>
cube_list : t_cube LEFT_PAREN ordinary_grouping_set_list RIGHT_PAREN;

// <grouping sets specification> ::= GROUPING SETS <left paren> <grouping set list> <right paren>
grouping_sets_specification : t_grouping t_sets LEFT_PAREN grouping_set_list RIGHT_PAREN;

// <grouping set list> ::= <grouping set> [ { <comma> <grouping set> }... ]
grouping_set_list : grouping_set (COMMA grouping_set)*;

// <grouping set> ::= <ordinary grouping set> | <rollup list> | <cube list> | <grouping sets specification> | <empty grouping set>
grouping_set : {ordinary} ordinary_grouping_set | {rollup} rollup_list | {cube} cube_list | {spec} grouping_sets_specification | {empty_grouping_set} empty_grouping_set; 

// <empty grouping set> ::= <left paren> <right paren>
empty_grouping_set : LEFT_PAREN RIGHT_PAREN;

// <having clause> ::= HAVING <search condition>
having_clause : t_having search_condition;
