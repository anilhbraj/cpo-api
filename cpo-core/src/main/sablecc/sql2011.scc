/* 
	filename   : cposql.scc
	created on : Jul 24, 2012
	description:
*/

/* define package-prefix */
Package org.synchronoss.cpo.parser;

Helpers

// SQL is case insensitive so we need to make it so we need to build the keywords from 
// case insensitive helpers

a = 'a' | 'A';
b = 'b' | 'B';
c = 'c' | 'C';
d = 'd' | 'D';
e = 'e' | 'E';
f = 'f' | 'F';
g = 'g' | 'G';
h = 'h' | 'H';
i = 'i' | 'I';
j = 'j' | 'J';
k = 'k' | 'K';
l = 'l' | 'L';
m = 'm' | 'M';
n = 'n' | 'N';
o = 'o' | 'O';
p = 'p' | 'P';
q = 'q' | 'Q';
r = 'r' | 'R';
s = 's' | 'S';
t = 't' | 'T';
u = 'u' | 'U';
v = 'v' | 'V';
w = 'w' | 'W';
x = 'x' | 'X';
y = 'y' | 'Y';
z = 'z' | 'Z';

unicode_cc = [0x0000..0x001F];

unicode_cf = 0x00AD | [0x0600..0x0604] | 0x06DD | 0x070F | [0x200B..0x200F] | [0x202A..0x202E] | [0x2060..0x2064] | [0x206A..0x206F] | 0xFEFF | [0xFFF9..0xFFFB] | 0x110BD | [0x1D173..0x1D17A] | 0xE0001;

unicode_co = 0xE000 | 0xF8FF | 0xF0000 | 0xFFFFD | 0x100000;

unicode_cs = 0xD800 | [0xDB7F..0xDB80] | [0xDBFF..0xDC00];

unicode_ll = [0x0061..0x007A] | 0x00B5 | [0x00DF..0x00F6] | [0x00F8..0x00FF] | 0x0101 | 0x0103 | 0x0105 | 0x0107 | 0x0109 | 0x010B | 0x010D | 0x010F | 0x0111 | 0x0113 | 0x0115 | 0x0117 | 0x0119 | 0x011B | 0x011D | 0x011F | 0x0121 | 0x0123 | 0x0125 | 0x0127 | 0x0129 | 0x012B | 0x012D | 0x012F | 0x0131 | 0x0133 | 0x0135 | [0x0137..0x0138] | 0x013A | 0x013C | 0x013E | 0x0140 | 0x0142 | 0x0144 | 0x0146 | [0x0148..0x0149] | 0x014B | 0x014D | 0x014F | 0x0151 | 0x0153 | 0x0155 | 0x0157 | 0x0159 | 0x015B | 0x015D | 0x015F | 0x0161 | 0x0163 | 0x0165 | 0x0167 | 0x0169 | 0x016B | 0x016D | 0x016F | 0x0171 | 0x0173 | 0x0175 | 0x0177 | 0x017A | 0x017C | [0x017E..0x0180] | 0x0183 | 0x0185 | 0x0188 | [0x018C..0x018D] | 0x0192 | 0x0195 | [0x0199..0x019B] | 0x019E | 0x01A1 | 0x01A3 | 0x01A5 | 0x01A8 | [0x01AA..0x01AB] | 0x01AD | 0x01B0 | 0x01B4 | 0x01B6 | [0x01B9..0x01BA] | [0x01BD..0x01BF] | 0x01C6 | 0x01C9 | 0x01CC | 0x01CE | 0x01D0 | 0x01D2 | 0x01D4 | 0x01D6 | 0x01D8 | 0x01DA | [0x01DC..0x01DD] | 0x01DF | 0x01E1 | 0x01E3 | 0x01E5 | 0x01E7 | 0x01E9 | 0x01EB | 0x01ED | [0x01EF..0x01F0] | 0x01F3 | 0x01F5 | 0x01F9 | 0x01FB | 0x01FD | 0x01FF | 0x0201 | 0x0203 | 0x0205 | 0x0207 | 0x0209 | 0x020B | 0x020D | 0x020F | 0x0211 | 0x0213 | 0x0215 | 0x0217 | 0x0219 | 0x021B | 0x021D | 0x021F | 0x0221 | 0x0223 | 0x0225 | 0x0227 | 0x0229 | 0x022B | 0x022D | 0x022F | 0x0231 | [0x0233..0x0239] | 0x023C | [0x023F..0x0240] | 0x0242 | 0x0247 | 0x0249 | 0x024B | 0x024D | [0x024F..0x0293] | [0x0295..0x02AF] | 0x0371 | 0x0373 | 0x0377 | [0x037B..0x037D] | 0x0390 | [0x03AC..0x03CE] | [0x03D0..0x03D1] | [0x03D5..0x03D7] | 0x03D9 | 0x03DB | 0x03DD | 0x03DF | 0x03E1 | 0x03E3 | 0x03E5 | 0x03E7 | 0x03E9 | 0x03EB | 0x03ED | [0x03EF..0x03F3] | 0x03F5 | 0x03F8 | [0x03FB..0x03FC] | [0x0430..0x045F] | 0x0461 | 0x0463 | 0x0465 | 0x0467 | 0x0469 | 0x046B | 0x046D | 0x046F | 0x0471 | 0x0473 | 0x0475 | 0x0477 | 0x0479 | 0x047B | 0x047D | 0x047F | 0x0481 | 0x048B | 0x048D | 0x048F | 0x0491 | 0x0493 | 0x0495 | 0x0497 | 0x0499 | 0x049B | 0x049D | 0x049F | 0x04A1 | 0x04A3 | 0x04A5 | 0x04A7 | 0x04A9 | 0x04AB | 0x04AD | 0x04AF | 0x04B1 | 0x04B3 | 0x04B5 | 0x04B7 | 0x04B9 | 0x04BB | 0x04BD | 0x04BF | 0x04C2 | 0x04C4 | 0x04C6 | 0x04C8 | 0x04CA | 0x04CC | [0x04CE..0x04CF] | 0x04D1 | 0x04D3 | 0x04D5 | 0x04D7 | 0x04D9 | 0x04DB | 0x04DD | 0x04DF | 0x04E1 | 0x04E3 | 0x04E5 | 0x04E7 | 0x04E9 | 0x04EB | 0x04ED | 0x04EF | 0x04F1 | 0x04F3 | 0x04F5 | 0x04F7 | 0x04F9 | 0x04FB | 0x04FD | 0x04FF | 0x0501 | 0x0503 | 0x0505 | 0x0507 | 0x0509 | 0x050B | 0x050D | 0x050F | 0x0511 | 0x0513 | 0x0515 | 0x0517 | 0x0519 | 0x051B | 0x051D | 0x051F | 0x0521 | 0x0523 | 0x0525 | 0x0527 | [0x0561..0x0587] | [0x1D00..0x1D2B] | [0x1D6B..0x1D77] | [0x1D79..0x1D9A] | 0x1E01 | 0x1E03 | 0x1E05 | 0x1E07 | 0x1E09 | 0x1E0B | 0x1E0D | 0x1E0F | 0x1E11 | 0x1E13 | 0x1E15 | 0x1E17 | 0x1E19 | 0x1E1B | 0x1E1D | 0x1E1F | 0x1E21 | 0x1E23 | 0x1E25 | 0x1E27 | 0x1E29 | 0x1E2B | 0x1E2D | 0x1E2F | 0x1E31 | 0x1E33 | 0x1E35 | 0x1E37 | 0x1E39 | 0x1E3B | 0x1E3D | 0x1E3F | 0x1E41 | 0x1E43 | 0x1E45 | 0x1E47 | 0x1E49 | 0x1E4B | 0x1E4D | 0x1E4F | 0x1E51 | 0x1E53 | 0x1E55 | 0x1E57 | 0x1E59 | 0x1E5B | 0x1E5D | 0x1E5F | 0x1E61 | 0x1E63 | 0x1E65 | 0x1E67 | 0x1E69 | 0x1E6B | 0x1E6D | 0x1E6F | 0x1E71 | 0x1E73 | 0x1E75 | 0x1E77 | 0x1E79 | 0x1E7B | 0x1E7D | 0x1E7F | 0x1E81 | 0x1E83 | 0x1E85 | 0x1E87 | 0x1E89 | 0x1E8B | 0x1E8D | 0x1E8F | 0x1E91 | 0x1E93 | [0x1E95..0x1E9D] | 0x1E9F | 0x1EA1 | 0x1EA3 | 0x1EA5 | 0x1EA7 | 0x1EA9 | 0x1EAB | 0x1EAD | 0x1EAF | 0x1EB1 | 0x1EB3 | 0x1EB5 | 0x1EB7 | 0x1EB9 | 0x1EBB | 0x1EBD | 0x1EBF | 0x1EC1 | 0x1EC3 | 0x1EC5 | 0x1EC7 | 0x1EC9 | 0x1ECB | 0x1ECD | 0x1ECF | 0x1ED1 | 0x1ED3 | 0x1ED5 | 0x1ED7 | 0x1ED9 | 0x1EDB | 0x1EDD | 0x1EDF | 0x1EE1 | 0x1EE3 | 0x1EE5 | 0x1EE7 | 0x1EE9 | 0x1EEB | 0x1EED | 0x1EEF | 0x1EF1 | 0x1EF3 | 0x1EF5 | 0x1EF7 | 0x1EF9 | 0x1EFB | 0x1EFD | [0x1EFF..0x1F07] | [0x1F10..0x1F15] | [0x1F20..0x1F27] | [0x1F30..0x1F37] | [0x1F40..0x1F45] | [0x1F50..0x1F57] | [0x1F60..0x1F67] | [0x1F70..0x1F7D] | [0x1F80..0x1F87] | [0x1F90..0x1F97] | [0x1FA0..0x1FA7] | [0x1FB0..0x1FB4] | [0x1FB6..0x1FB7] | 0x1FBE | [0x1FC2..0x1FC4] | [0x1FC6..0x1FC7] | [0x1FD0..0x1FD3] | [0x1FD6..0x1FD7] | [0x1FE0..0x1FE7] | [0x1FF2..0x1FF4] | [0x1FF6..0x1FF7] | 0x210A | [0x210E..0x210F] | 0x2113 | 0x212F | 0x2134 | 0x2139 | [0x213C..0x213D] | [0x2146..0x2149] | 0x214E | 0x2184 | [0x2C30..0x2C5E] | 0x2C61 | [0x2C65..0x2C66] | 0x2C68 | 0x2C6A | 0x2C6C | 0x2C71 | [0x2C73..0x2C74] | [0x2C76..0x2C7B] | 0x2C81 | 0x2C83 | 0x2C85 | 0x2C87 | 0x2C89 | 0x2C8B | 0x2C8D | 0x2C8F | 0x2C91 | 0x2C93 | 0x2C95 | 0x2C97 | 0x2C99 | 0x2C9B | 0x2C9D | 0x2C9F | 0x2CA1 | 0x2CA3 | 0x2CA5 | 0x2CA7 | 0x2CA9 | 0x2CAB | 0x2CAD | 0x2CAF | 0x2CB1 | 0x2CB3 | 0x2CB5 | 0x2CB7 | 0x2CB9 | 0x2CBB | 0x2CBD | 0x2CBF | 0x2CC1 | 0x2CC3 | 0x2CC5 | 0x2CC7 | 0x2CC9 | 0x2CCB | 0x2CCD | 0x2CCF | 0x2CD1 | 0x2CD3 | 0x2CD5 | 0x2CD7 | 0x2CD9 | 0x2CDB | 0x2CDD | 0x2CDF | 0x2CE1 | [0x2CE3..0x2CE4] | 0x2CEC | 0x2CEE | 0x2CF3 | [0x2D00..0x2D25] | 0x2D27 | 0x2D2D | 0xA641 | 0xA643 | 0xA645 | 0xA647 | 0xA649 | 0xA64B | 0xA64D | 0xA64F | 0xA651 | 0xA653 | 0xA655 | 0xA657 | 0xA659 | 0xA65B | 0xA65D | 0xA65F | 0xA661 | 0xA663 | 0xA665 | 0xA667 | 0xA669 | 0xA66B | 0xA66D | 0xA681 | 0xA683 | 0xA685 | 0xA687 | 0xA689 | 0xA68B | 0xA68D | 0xA68F | 0xA691 | 0xA693 | 0xA695 | 0xA697 | 0xA723 | 0xA725 | 0xA727 | 0xA729 | 0xA72B | 0xA72D | [0xA72F..0xA731] | 0xA733 | 0xA735 | 0xA737 | 0xA739 | 0xA73B | 0xA73D | 0xA73F | 0xA741 | 0xA743 | 0xA745 | 0xA747 | 0xA749 | 0xA74B | 0xA74D | 0xA74F | 0xA751 | 0xA753 | 0xA755 | 0xA757 | 0xA759 | 0xA75B | 0xA75D | 0xA75F | 0xA761 | 0xA763 | 0xA765 | 0xA767 | 0xA769 | 0xA76B | 0xA76D | 0xA76F | [0xA771..0xA778] | 0xA77A | 0xA77C | 0xA77F | 0xA781 | 0xA783 | 0xA785 | 0xA787 | 0xA78C | 0xA78E | 0xA791 | 0xA793 | 0xA7A1 | 0xA7A3 | 0xA7A5 | 0xA7A7 | 0xA7A9 | 0xA7FA | [0xFB00..0xFB06] | [0xFB13..0xFB17] | [0xFF41..0xFF5A] | [0x10428..0x1044F] | [0x1D41A..0x1D433] | [0x1D44E..0x1D454] | [0x1D456..0x1D467] | [0x1D482..0x1D49B] | [0x1D4B6..0x1D4B9] | 0x1D4BB | [0x1D4BD..0x1D4C3] | [0x1D4C5..0x1D4CF] | [0x1D4EA..0x1D503] | [0x1D51E..0x1D537] | [0x1D552..0x1D56B] | [0x1D586..0x1D59F] | [0x1D5BA..0x1D5D3] | [0x1D5EE..0x1D607] | [0x1D622..0x1D63B] | [0x1D656..0x1D66F] | [0x1D68A..0x1D6A5] | [0x1D6C2..0x1D6DA] | [0x1D6DC..0x1D6E1] | [0x1D6FC..0x1D714] | [0x1D716..0x1D71B] | [0x1D736..0x1D74E] | [0x1D750..0x1D755] | [0x1D770..0x1D788] | [0x1D78A..0x1D78F] | [0x1D7AA..0x1D7C2] | [0x1D7C4..0x1D7C9];

unicode_lm = [0x02B0..0x02C1] | [0x02C6..0x02D1] | [0x02E0..0x02E4] | 0x02EC | 0x02EE | 0x0374 | 0x037A | 0x0559 | 0x0640 | [0x06E5..0x06E6] | [0x07F4..0x07F5] | 0x07FA | 0x081A | 0x0824 | 0x0828 | 0x0971 | 0x0E46 | 0x0EC6 | 0x10FC | 0x17D7 | 0x1843 | 0x1AA7 | [0x1C78..0x1C7D] | [0x1D2C..0x1D6A] | 0x1D78 | [0x1D9B..0x1DBF] | 0x2071 | 0x207F | [0x2090..0x209C] | [0x2C7C..0x2C7D] | 0x2D6F | 0x2E2F | 0x3005 | [0x3031..0x3035] | 0x303B | [0x309D..0x309E] | [0x30FC..0x30FE] | 0xA015 | [0xA4F8..0xA4FD] | 0xA60C | 0xA67F | [0xA717..0xA71F] | 0xA770 | 0xA788 | [0xA7F8..0xA7F9] | 0xA9CF | 0xAA70 | 0xAADD | [0xAAF3..0xAAF4] | 0xFF70 | [0xFF9E..0xFF9F];

unicode_lo = 0x00AA | 0x00BA | 0x01BB | [0x01C0..0x01C3] | 0x0294 | [0x05D0..0x05EA] | [0x05F0..0x05F2] | [0x0620..0x063F] | [0x0641..0x064A] | [0x066E..0x066F] | [0x0671..0x06D3] | 0x06D5 | [0x06EE..0x06EF] | [0x06FA..0x06FC] | 0x06FF | 0x0710 | [0x0712..0x072F] | [0x074D..0x07A5] | 0x07B1 | [0x07CA..0x07EA] | [0x0800..0x0815] | [0x0840..0x0858] | 0x08A0 | [0x08A2..0x08AC] | [0x0904..0x0939] | 0x093D | 0x0950 | [0x0958..0x0961] | [0x0972..0x0977] | [0x0979..0x097F] | [0x0985..0x098C] | [0x098F..0x0990] | [0x0993..0x09A8] | [0x09AA..0x09B0] | 0x09B2 | [0x09B6..0x09B9] | 0x09BD | 0x09CE | [0x09DC..0x09DD] | [0x09DF..0x09E1] | [0x09F0..0x09F1] | [0x0A05..0x0A0A] | [0x0A0F..0x0A10] | [0x0A13..0x0A28] | [0x0A2A..0x0A30] | [0x0A32..0x0A33] | [0x0A35..0x0A36] | [0x0A38..0x0A39] | [0x0A59..0x0A5C] | 0x0A5E | [0x0A72..0x0A74] | [0x0A85..0x0A8D] | [0x0A8F..0x0A91] | [0x0A93..0x0AA8] | [0x0AAA..0x0AB0] | [0x0AB2..0x0AB3] | [0x0AB5..0x0AB9] | 0x0ABD | 0x0AD0 | [0x0AE0..0x0AE1] | [0x0B05..0x0B0C] | [0x0B0F..0x0B10] | [0x0B13..0x0B28] | [0x0B2A..0x0B30] | [0x0B32..0x0B33] | [0x0B35..0x0B39] | 0x0B3D | [0x0B5C..0x0B5D] | [0x0B5F..0x0B61] | 0x0B71 | 0x0B83 | [0x0B85..0x0B8A] | [0x0B8E..0x0B90] | [0x0B92..0x0B95] | [0x0B99..0x0B9A] | 0x0B9C | [0x0B9E..0x0B9F] | [0x0BA3..0x0BA4] | [0x0BA8..0x0BAA] | [0x0BAE..0x0BB9] | 0x0BD0 | [0x0C05..0x0C0C] | [0x0C0E..0x0C10] | [0x0C12..0x0C28] | [0x0C2A..0x0C33] | [0x0C35..0x0C39] | 0x0C3D | [0x0C58..0x0C59] | [0x0C60..0x0C61] | [0x0C85..0x0C8C] | [0x0C8E..0x0C90] | [0x0C92..0x0CA8] | [0x0CAA..0x0CB3] | [0x0CB5..0x0CB9] | 0x0CBD | 0x0CDE | [0x0CE0..0x0CE1] | [0x0CF1..0x0CF2] | [0x0D05..0x0D0C] | [0x0D0E..0x0D10] | [0x0D12..0x0D3A] | 0x0D3D | 0x0D4E | [0x0D60..0x0D61] | [0x0D7A..0x0D7F] | [0x0D85..0x0D96] | [0x0D9A..0x0DB1] | [0x0DB3..0x0DBB] | 0x0DBD | [0x0DC0..0x0DC6] | [0x0E01..0x0E30] | [0x0E32..0x0E33] | [0x0E40..0x0E45] | [0x0E81..0x0E82] | 0x0E84 | [0x0E87..0x0E88] | 0x0E8A | 0x0E8D | [0x0E94..0x0E97] | [0x0E99..0x0E9F] | [0x0EA1..0x0EA3] | 0x0EA5 | 0x0EA7 | [0x0EAA..0x0EAB] | [0x0EAD..0x0EB0] | [0x0EB2..0x0EB3] | 0x0EBD | [0x0EC0..0x0EC4] | [0x0EDC..0x0EDF] | 0x0F00 | [0x0F40..0x0F47] | [0x0F49..0x0F6C] | [0x0F88..0x0F8C] | [0x1000..0x102A] | 0x103F | [0x1050..0x1055] | [0x105A..0x105D] | 0x1061 | [0x1065..0x1066] | [0x106E..0x1070] | [0x1075..0x1081] | 0x108E | [0x10D0..0x10FA] | [0x10FD..0x1248] | [0x124A..0x124D] | [0x1250..0x1256] | 0x1258 | [0x125A..0x125D] | [0x1260..0x1288] | [0x128A..0x128D] | [0x1290..0x12B0] | [0x12B2..0x12B5] | [0x12B8..0x12BE] | 0x12C0 | [0x12C2..0x12C5] | [0x12C8..0x12D6] | [0x12D8..0x1310] | [0x1312..0x1315] | [0x1318..0x135A] | [0x1380..0x138F] | [0x13A0..0x13F4] | [0x1401..0x166C] | [0x166F..0x167F] | [0x1681..0x169A] | [0x16A0..0x16EA] | [0x1700..0x170C] | [0x170E..0x1711] | [0x1720..0x1731] | [0x1740..0x1751] | [0x1760..0x176C] | [0x176E..0x1770] | [0x1780..0x17B3] | 0x17DC | [0x1820..0x1842] | [0x1844..0x1877] | [0x1880..0x18A8] | 0x18AA | [0x18B0..0x18F5] | [0x1900..0x191C] | [0x1950..0x196D] | [0x1970..0x1974] | [0x1980..0x19AB] | [0x19C1..0x19C7] | [0x1A00..0x1A16] | [0x1A20..0x1A54] | [0x1B05..0x1B33] | [0x1B45..0x1B4B] | [0x1B83..0x1BA0] | [0x1BAE..0x1BAF] | [0x1BBA..0x1BE5] | [0x1C00..0x1C23] | [0x1C4D..0x1C4F] | [0x1C5A..0x1C77] | [0x1CE9..0x1CEC] | [0x1CEE..0x1CF1] | [0x1CF5..0x1CF6] | [0x2135..0x2138] | [0x2D30..0x2D67] | [0x2D80..0x2D96] | [0x2DA0..0x2DA6] | [0x2DA8..0x2DAE] | [0x2DB0..0x2DB6] | [0x2DB8..0x2DBE] | [0x2DC0..0x2DC6] | [0x2DC8..0x2DCE] | [0x2DD0..0x2DD6] | [0x2DD8..0x2DDE] | 0x3006 | 0x303C | [0x3041..0x3096] | 0x309F | [0x30A1..0x30FA] | 0x30FF | [0x3105..0x312D] | [0x3131..0x318E] | [0x31A0..0x31BA] | [0x31F0..0x31FF] | 0x3400 | 0x4DB5 | 0x4E00 | 0x9FCC | [0xA000..0xA014] | [0xA016..0xA48C] | [0xA4D0..0xA4F7] | [0xA500..0xA60B] | [0xA610..0xA61F] | [0xA62A..0xA62B] | 0xA66E | [0xA6A0..0xA6E5] | [0xA7FB..0xA801] | [0xA803..0xA805] | [0xA807..0xA80A] | [0xA80C..0xA822] | [0xA840..0xA873] | [0xA882..0xA8B3] | [0xA8F2..0xA8F7] | 0xA8FB | [0xA90A..0xA925] | [0xA930..0xA946] | [0xA960..0xA97C] | [0xA984..0xA9B2] | [0xAA00..0xAA28] | [0xAA40..0xAA42] | [0xAA44..0xAA4B] | [0xAA60..0xAA6F] | [0xAA71..0xAA76] | 0xAA7A | [0xAA80..0xAAAF] | 0xAAB1 | [0xAAB5..0xAAB6] | [0xAAB9..0xAABD] | 0xAAC0 | 0xAAC2 | [0xAADB..0xAADC] | [0xAAE0..0xAAEA] | 0xAAF2 | [0xAB01..0xAB06] | [0xAB09..0xAB0E] | [0xAB11..0xAB16] | [0xAB20..0xAB26] | [0xAB28..0xAB2E] | [0xABC0..0xABE2] | 0xAC00 | 0xD7A3 | [0xD7B0..0xD7C6] | [0xD7CB..0xD7FB] | [0xF900..0xFA6D] | [0xFA70..0xFAD9] | 0xFB1D | [0xFB1F..0xFB28] | [0xFB2A..0xFB36] | [0xFB38..0xFB3C] | 0xFB3E | [0xFB40..0xFB41] | [0xFB43..0xFB44] | [0xFB46..0xFBB1] | [0xFBD3..0xFD3D] | [0xFD50..0xFD8F] | [0xFD92..0xFDC7] | [0xFDF0..0xFDFB] | [0xFE70..0xFE74] | [0xFE76..0xFEFC] | [0xFF66..0xFF6F] | [0xFF71..0xFF9D] | [0xFFA0..0xFFBE] | [0xFFC2..0xFFC7] | [0xFFCA..0xFFCF] | [0xFFD2..0xFFD7] | [0xFFDA..0xFFDC] | [0x10000..0x1000B] | [0x1000D..0x10026] | [0x10028..0x1003A] | [0x1003C..0x1003D] | [0x1003F..0x1004D] | [0x10050..0x1005D] | [0x10080..0x100FA] | [0x10280..0x1029C] | [0x102A0..0x102D0] | [0x10300..0x1031E] | [0x10330..0x10340] | [0x10342..0x10349] | [0x10380..0x1039D] | [0x103A0..0x103C3] | [0x103C8..0x103CF] | [0x10450..0x1049D] | [0x10800..0x10805] | 0x10808 | [0x1080A..0x10835] | [0x10837..0x10838] | 0x1083C | [0x1083F..0x10855] | [0x10900..0x10915] | [0x10920..0x10939] | [0x10980..0x109B7] | [0x109BE..0x109BF] | 0x10A00 | [0x10A10..0x10A13] | [0x10A15..0x10A17] | [0x10A19..0x10A33] | [0x10A60..0x10A7C] | [0x10B00..0x10B35] | [0x10B40..0x10B55] | [0x10B60..0x10B72] | [0x10C00..0x10C48] | [0x11003..0x11037] | [0x11083..0x110AF] | [0x110D0..0x110E8] | [0x11103..0x11126] | [0x11183..0x111B2] | [0x111C1..0x111C4] | [0x11680..0x116AA] | [0x12000..0x1236E] | [0x13000..0x1342E] | [0x16800..0x16A38] | [0x16F00..0x16F44] | 0x16F50 | [0x1B000..0x1B001] | [0x1EE00..0x1EE03] | [0x1EE05..0x1EE1F] | [0x1EE21..0x1EE22] | 0x1EE24 | 0x1EE27 | [0x1EE29..0x1EE32] | [0x1EE34..0x1EE37] | 0x1EE39 | 0x1EE3B | 0x1EE42 | 0x1EE47 | 0x1EE49 | 0x1EE4B | [0x1EE4D..0x1EE4F] | [0x1EE51..0x1EE52] | 0x1EE54 | 0x1EE57 | 0x1EE59 | 0x1EE5B | 0x1EE5D | 0x1EE5F | [0x1EE61..0x1EE62] | 0x1EE64 | [0x1EE67..0x1EE6A] | [0x1EE6C..0x1EE72] | [0x1EE74..0x1EE77] | [0x1EE79..0x1EE7C] | 0x1EE7E | [0x1EE80..0x1EE89] | [0x1EE8B..0x1EE9B] | [0x1EEA1..0x1EEA3] | [0x1EEA5..0x1EEA9] | [0x1EEAB..0x1EEBB] | 0x20000 | 0x2A6D6 | 0x2A700 | 0x2B734 | 0x2B740 | 0x2B81D;

unicode_lt = 0x01C5 | 0x01C8 | 0x01CB | 0x01F2 | [0x1F88..0x1F8F] | [0x1F98..0x1F9F] | [0x1FA8..0x1FAF] | 0x1FBC | 0x1FCC;

unicode_lu = [0x0041..0x005A] | [0x00C0..0x00D6] | [0x00D8..0x00DE] | 0x0100 | 0x0102 | 0x0104 | 0x0106 | 0x0108 | 0x010A | 0x010C | 0x010E | 0x0110 | 0x0112 | 0x0114 | 0x0116 | 0x0118 | 0x011A | 0x011C | 0x011E | 0x0120 | 0x0122 | 0x0124 | 0x0126 | 0x0128 | 0x012A | 0x012C | 0x012E | 0x0130 | 0x0132 | 0x0134 | 0x0136 | 0x0139 | 0x013B | 0x013D | 0x013F | 0x0141 | 0x0143 | 0x0145 | 0x0147 | 0x014A | 0x014C | 0x014E | 0x0150 | 0x0152 | 0x0154 | 0x0156 | 0x0158 | 0x015A | 0x015C | 0x015E | 0x0160 | 0x0162 | 0x0164 | 0x0166 | 0x0168 | 0x016A | 0x016C | 0x016E | 0x0170 | 0x0172 | 0x0174 | 0x0176 | [0x0178..0x0179] | 0x017B | 0x017D | [0x0181..0x0182] | 0x0184 | [0x0186..0x0187] | [0x0189..0x018B] | [0x018E..0x0191] | [0x0193..0x0194] | [0x0196..0x0198] | [0x019C..0x019D] | [0x019F..0x01A0] | 0x01A2 | 0x01A4 | [0x01A6..0x01A7] | 0x01A9 | 0x01AC | [0x01AE..0x01AF] | [0x01B1..0x01B3] | 0x01B5 | [0x01B7..0x01B8] | 0x01BC | 0x01C4 | 0x01C7 | 0x01CA | 0x01CD | 0x01CF | 0x01D1 | 0x01D3 | 0x01D5 | 0x01D7 | 0x01D9 | 0x01DB | 0x01DE | 0x01E0 | 0x01E2 | 0x01E4 | 0x01E6 | 0x01E8 | 0x01EA | 0x01EC | 0x01EE | 0x01F1 | 0x01F4 | [0x01F6..0x01F8] | 0x01FA | 0x01FC | 0x01FE | 0x0200 | 0x0202 | 0x0204 | 0x0206 | 0x0208 | 0x020A | 0x020C | 0x020E | 0x0210 | 0x0212 | 0x0214 | 0x0216 | 0x0218 | 0x021A | 0x021C | 0x021E | 0x0220 | 0x0222 | 0x0224 | 0x0226 | 0x0228 | 0x022A | 0x022C | 0x022E | 0x0230 | 0x0232 | [0x023A..0x023B] | [0x023D..0x023E] | 0x0241 | [0x0243..0x0246] | 0x0248 | 0x024A | 0x024C | 0x024E | 0x0370 | 0x0372 | 0x0376 | 0x0386 | [0x0388..0x038A] | 0x038C | [0x038E..0x038F] | [0x0391..0x03A1] | [0x03A3..0x03AB] | 0x03CF | [0x03D2..0x03D4] | 0x03D8 | 0x03DA | 0x03DC | 0x03DE | 0x03E0 | 0x03E2 | 0x03E4 | 0x03E6 | 0x03E8 | 0x03EA | 0x03EC | 0x03EE | 0x03F4 | 0x03F7 | [0x03F9..0x03FA] | [0x03FD..0x042F] | 0x0460 | 0x0462 | 0x0464 | 0x0466 | 0x0468 | 0x046A | 0x046C | 0x046E | 0x0470 | 0x0472 | 0x0474 | 0x0476 | 0x0478 | 0x047A | 0x047C | 0x047E | 0x0480 | 0x048A | 0x048C | 0x048E | 0x0490 | 0x0492 | 0x0494 | 0x0496 | 0x0498 | 0x049A | 0x049C | 0x049E | 0x04A0 | 0x04A2 | 0x04A4 | 0x04A6 | 0x04A8 | 0x04AA | 0x04AC | 0x04AE | 0x04B0 | 0x04B2 | 0x04B4 | 0x04B6 | 0x04B8 | 0x04BA | 0x04BC | 0x04BE | [0x04C0..0x04C1] | 0x04C3 | 0x04C5 | 0x04C7 | 0x04C9 | 0x04CB | 0x04CD | 0x04D0 | 0x04D2 | 0x04D4 | 0x04D6 | 0x04D8 | 0x04DA | 0x04DC | 0x04DE | 0x04E0 | 0x04E2 | 0x04E4 | 0x04E6 | 0x04E8 | 0x04EA | 0x04EC | 0x04EE | 0x04F0 | 0x04F2 | 0x04F4 | 0x04F6 | 0x04F8 | 0x04FA | 0x04FC | 0x04FE | 0x0500 | 0x0502 | 0x0504 | 0x0506 | 0x0508 | 0x050A | 0x050C | 0x050E | 0x0510 | 0x0512 | 0x0514 | 0x0516 | 0x0518 | 0x051A | 0x051C | 0x051E | 0x0520 | 0x0522 | 0x0524 | 0x0526 | [0x0531..0x0556] | [0x10A0..0x10C5] | 0x10C7 | 0x10CD | 0x1E00 | 0x1E02 | 0x1E04 | 0x1E06 | 0x1E08 | 0x1E0A | 0x1E0C | 0x1E0E | 0x1E10 | 0x1E12 | 0x1E14 | 0x1E16 | 0x1E18 | 0x1E1A | 0x1E1C | 0x1E1E | 0x1E20 | 0x1E22 | 0x1E24 | 0x1E26 | 0x1E28 | 0x1E2A | 0x1E2C | 0x1E2E | 0x1E30 | 0x1E32 | 0x1E34 | 0x1E36 | 0x1E38 | 0x1E3A | 0x1E3C | 0x1E3E | 0x1E40 | 0x1E42 | 0x1E44 | 0x1E46 | 0x1E48 | 0x1E4A | 0x1E4C | 0x1E4E | 0x1E50 | 0x1E52 | 0x1E54 | 0x1E56 | 0x1E58 | 0x1E5A | 0x1E5C | 0x1E5E | 0x1E60 | 0x1E62 | 0x1E64 | 0x1E66 | 0x1E68 | 0x1E6A | 0x1E6C | 0x1E6E | 0x1E70 | 0x1E72 | 0x1E74 | 0x1E76 | 0x1E78 | 0x1E7A | 0x1E7C | 0x1E7E | 0x1E80 | 0x1E82 | 0x1E84 | 0x1E86 | 0x1E88 | 0x1E8A | 0x1E8C | 0x1E8E | 0x1E90 | 0x1E92 | 0x1E94 | 0x1E9E | 0x1EA0 | 0x1EA2 | 0x1EA4 | 0x1EA6 | 0x1EA8 | 0x1EAA | 0x1EAC | 0x1EAE | 0x1EB0 | 0x1EB2 | 0x1EB4 | 0x1EB6 | 0x1EB8 | 0x1EBA | 0x1EBC | 0x1EBE | 0x1EC0 | 0x1EC2 | 0x1EC4 | 0x1EC6 | 0x1EC8 | 0x1ECA | 0x1ECC | 0x1ECE | 0x1ED0 | 0x1ED2 | 0x1ED4 | 0x1ED6 | 0x1ED8 | 0x1EDA | 0x1EDC | 0x1EDE | 0x1EE0 | 0x1EE2 | 0x1EE4 | 0x1EE6 | 0x1EE8 | 0x1EEA | 0x1EEC | 0x1EEE | 0x1EF0 | 0x1EF2 | 0x1EF4 | 0x1EF6 | 0x1EF8 | 0x1EFA | 0x1EFC | 0x1EFE | [0x1F08..0x1F0F] | [0x1F18..0x1F1D] | [0x1F28..0x1F2F] | [0x1F38..0x1F3F] | [0x1F48..0x1F4D] | 0x1F59 | 0x1F5B | 0x1F5D | 0x1F5F | [0x1F68..0x1F6F] | [0x1FB8..0x1FBB] | [0x1FC8..0x1FCB] | [0x1FD8..0x1FDB] | [0x1FE8..0x1FEC] | [0x1FF8..0x1FFB] | 0x2102 | 0x2107 | [0x210B..0x210D] | [0x2110..0x2112] | 0x2115 | [0x2119..0x211D] | 0x2124 | 0x2126 | 0x2128 | [0x212A..0x212D] | [0x2130..0x2133] | [0x213E..0x213F] | 0x2145 | 0x2183 | [0x2C00..0x2C2E] | 0x2C60 | [0x2C62..0x2C64] | 0x2C67 | 0x2C69 | 0x2C6B | [0x2C6D..0x2C70] | 0x2C72 | 0x2C75 | [0x2C7E..0x2C80] | 0x2C82 | 0x2C84 | 0x2C86 | 0x2C88 | 0x2C8A | 0x2C8C | 0x2C8E | 0x2C90 | 0x2C92 | 0x2C94 | 0x2C96 | 0x2C98 | 0x2C9A | 0x2C9C | 0x2C9E | 0x2CA0 | 0x2CA2 | 0x2CA4 | 0x2CA6 | 0x2CA8 | 0x2CAA | 0x2CAC | 0x2CAE | 0x2CB0 | 0x2CB2 | 0x2CB4 | 0x2CB6 | 0x2CB8 | 0x2CBA | 0x2CBC | 0x2CBE | 0x2CC0 | 0x2CC2 | 0x2CC4 | 0x2CC6 | 0x2CC8 | 0x2CCA | 0x2CCC | 0x2CCE | 0x2CD0 | 0x2CD2 | 0x2CD4 | 0x2CD6 | 0x2CD8 | 0x2CDA | 0x2CDC | 0x2CDE | 0x2CE0 | 0x2CE2 | 0x2CEB | 0x2CED | 0x2CF2 | 0xA640 | 0xA642 | 0xA644 | 0xA646 | 0xA648 | 0xA64A | 0xA64C | 0xA64E | 0xA650 | 0xA652 | 0xA654 | 0xA656 | 0xA658 | 0xA65A | 0xA65C | 0xA65E | 0xA660 | 0xA662 | 0xA664 | 0xA666 | 0xA668 | 0xA66A | 0xA66C | 0xA680 | 0xA682 | 0xA684 | 0xA686 | 0xA688 | 0xA68A | 0xA68C | 0xA68E | 0xA690 | 0xA692 | 0xA694 | 0xA696 | 0xA722 | 0xA724 | 0xA726 | 0xA728 | 0xA72A | 0xA72C | 0xA72E | 0xA732 | 0xA734 | 0xA736 | 0xA738 | 0xA73A | 0xA73C | 0xA73E | 0xA740 | 0xA742 | 0xA744 | 0xA746 | 0xA748 | 0xA74A | 0xA74C | 0xA74E | 0xA750 | 0xA752 | 0xA754 | 0xA756 | 0xA758 | 0xA75A | 0xA75C | 0xA75E | 0xA760 | 0xA762 | 0xA764 | 0xA766 | 0xA768 | 0xA76A | 0xA76C | 0xA76E | 0xA779 | 0xA77B | [0xA77D..0xA77E] | 0xA780 | 0xA782 | 0xA784 | 0xA786 | 0xA78B | 0xA78D | 0xA790 | 0xA792 | 0xA7A0 | 0xA7A2 | 0xA7A4 | 0xA7A6 | 0xA7A8 | 0xA7AA | [0xFF21..0xFF3A] | [0x10400..0x10427] | [0x1D400..0x1D419] | [0x1D434..0x1D44D] | [0x1D468..0x1D481] | 0x1D49C | [0x1D49E..0x1D49F] | 0x1D4A2 | [0x1D4A5..0x1D4A6] | [0x1D4A9..0x1D4AC] | [0x1D4AE..0x1D4B5] | [0x1D4D0..0x1D4E9] | [0x1D504..0x1D505] | [0x1D507..0x1D50A] | [0x1D50D..0x1D514] | [0x1D516..0x1D51C] | [0x1D538..0x1D539] | [0x1D53B..0x1D53E] | [0x1D540..0x1D544] | 0x1D546 | [0x1D54A..0x1D550] | [0x1D56C..0x1D585] | [0x1D5A0..0x1D5B9] | [0x1D5D4..0x1D5ED] | [0x1D608..0x1D621] | [0x1D63C..0x1D655] | [0x1D670..0x1D689] | [0x1D6A8..0x1D6C0] | [0x1D6E2..0x1D6FA] | [0x1D71C..0x1D734] | [0x1D756..0x1D76E] | [0x1D790..0x1D7A8];

unicode_mc = 0x0903 | 0x093B | [0x093E..0x0940] | [0x0949..0x094C] | [0x094E..0x094F] | [0x0982..0x0983] | [0x09BE..0x09C0] | [0x09C7..0x09C8] | [0x09CB..0x09CC] | 0x09D7 | 0x0A03 | [0x0A3E..0x0A40] | 0x0A83 | [0x0ABE..0x0AC0] | 0x0AC9 | [0x0ACB..0x0ACC] | [0x0B02..0x0B03] | 0x0B3E | 0x0B40 | [0x0B47..0x0B48] | [0x0B4B..0x0B4C] | 0x0B57 | [0x0BBE..0x0BBF] | [0x0BC1..0x0BC2] | [0x0BC6..0x0BC8] | [0x0BCA..0x0BCC] | 0x0BD7 | [0x0C01..0x0C03] | [0x0C41..0x0C44] | [0x0C82..0x0C83] | 0x0CBE | [0x0CC0..0x0CC4] | [0x0CC7..0x0CC8] | [0x0CCA..0x0CCB] | [0x0CD5..0x0CD6] | [0x0D02..0x0D03] | [0x0D3E..0x0D40] | [0x0D46..0x0D48] | [0x0D4A..0x0D4C] | 0x0D57 | [0x0D82..0x0D83] | [0x0DCF..0x0DD1] | [0x0DD8..0x0DDF] | [0x0DF2..0x0DF3] | [0x0F3E..0x0F3F] | 0x0F7F | [0x102B..0x102C] | 0x1031 | 0x1038 | [0x103B..0x103C] | [0x1056..0x1057] | [0x1062..0x1064] | [0x1067..0x106D] | [0x1083..0x1084] | [0x1087..0x108C] | 0x108F | [0x109A..0x109C] | 0x17B6 | [0x17BE..0x17C5] | [0x17C7..0x17C8] | [0x1923..0x1926] | [0x1929..0x192B] | [0x1930..0x1931] | [0x1933..0x1938] | [0x19B0..0x19C0] | [0x19C8..0x19C9] | [0x1A19..0x1A1B] | 0x1A55 | 0x1A57 | 0x1A61 | [0x1A63..0x1A64] | [0x1A6D..0x1A72] | 0x1B04 | 0x1B35 | 0x1B3B | [0x1B3D..0x1B41] | [0x1B43..0x1B44] | 0x1B82 | 0x1BA1 | [0x1BA6..0x1BA7] | 0x1BAA | [0x1BAC..0x1BAD] | 0x1BE7 | [0x1BEA..0x1BEC] | 0x1BEE | [0x1BF2..0x1BF3] | [0x1C24..0x1C2B] | [0x1C34..0x1C35] | 0x1CE1 | [0x1CF2..0x1CF3] | [0x302E..0x302F] | [0xA823..0xA824] | 0xA827 | [0xA880..0xA881] | [0xA8B4..0xA8C3] | [0xA952..0xA953] | 0xA983 | [0xA9B4..0xA9B5] | [0xA9BA..0xA9BB] | [0xA9BD..0xA9C0] | [0xAA2F..0xAA30] | [0xAA33..0xAA34] | 0xAA4D | 0xAA7B | 0xAAEB | [0xAAEE..0xAAEF] | 0xAAF5 | [0xABE3..0xABE4] | [0xABE6..0xABE7] | [0xABE9..0xABEA] | 0xABEC | 0x11000 | 0x11002 | 0x11082 | [0x110B0..0x110B2] | [0x110B7..0x110B8] | 0x1112C | 0x11182 | [0x111B3..0x111B5] | [0x111BF..0x111C0] | 0x116AC | [0x116AE..0x116AF] | 0x116B6 | [0x16F51..0x16F7E] | [0x1D165..0x1D166];

unicode_me = [0x0488..0x0489] | [0x20DD..0x20E0] | [0x20E2..0x20E4];

unicode_mn = [0x0300..0x036F] | [0x0483..0x0487] | [0x0591..0x05BD] | 0x05BF | [0x05C1..0x05C2] | [0x05C4..0x05C5] | 0x05C7 | [0x0610..0x061A] | [0x064B..0x065F] | 0x0670 | [0x06D6..0x06DC] | [0x06DF..0x06E4] | [0x06E7..0x06E8] | [0x06EA..0x06ED] | 0x0711 | [0x0730..0x074A] | [0x07A6..0x07B0] | [0x07EB..0x07F3] | [0x0816..0x0819] | [0x081B..0x0823] | [0x0825..0x0827] | [0x0829..0x082D] | [0x0859..0x085B] | [0x08E4..0x08FE] | [0x0900..0x0902] | 0x093A | 0x093C | [0x0941..0x0948] | 0x094D | [0x0951..0x0957] | [0x0962..0x0963] | 0x0981 | 0x09BC | [0x09C1..0x09C4] | 0x09CD | [0x09E2..0x09E3] | [0x0A01..0x0A02] | 0x0A3C | [0x0A41..0x0A42] | [0x0A47..0x0A48] | [0x0A4B..0x0A4D] | 0x0A51 | [0x0A70..0x0A71] | 0x0A75 | [0x0A81..0x0A82] | 0x0ABC | [0x0AC1..0x0AC5] | [0x0AC7..0x0AC8] | 0x0ACD | [0x0AE2..0x0AE3] | 0x0B01 | 0x0B3C | 0x0B3F | [0x0B41..0x0B44] | 0x0B4D | 0x0B56 | [0x0B62..0x0B63] | 0x0B82 | 0x0BC0 | 0x0BCD | [0x0C3E..0x0C40] | [0x0C46..0x0C48] | [0x0C4A..0x0C4D] | [0x0C55..0x0C56] | [0x0C62..0x0C63] | 0x0CBC | 0x0CBF | 0x0CC6 | [0x0CCC..0x0CCD] | [0x0CE2..0x0CE3] | [0x0D41..0x0D44] | 0x0D4D | [0x0D62..0x0D63] | 0x0DCA | [0x0DD2..0x0DD4] | 0x0DD6 | 0x0E31 | [0x0E34..0x0E3A] | [0x0E47..0x0E4E] | 0x0EB1 | [0x0EB4..0x0EB9] | [0x0EBB..0x0EBC] | [0x0EC8..0x0ECD] | [0x0F18..0x0F19] | 0x0F35 | 0x0F37 | 0x0F39 | [0x0F71..0x0F7E] | [0x0F80..0x0F84] | [0x0F86..0x0F87] | [0x0F8D..0x0F97] | [0x0F99..0x0FBC] | 0x0FC6 | [0x102D..0x1030] | [0x1032..0x1037] | [0x1039..0x103A] | [0x103D..0x103E] | [0x1058..0x1059] | [0x105E..0x1060] | [0x1071..0x1074] | 0x1082 | [0x1085..0x1086] | 0x108D | 0x109D | [0x135D..0x135F] | [0x1712..0x1714] | [0x1732..0x1734] | [0x1752..0x1753] | [0x1772..0x1773] | [0x17B4..0x17B5] | [0x17B7..0x17BD] | 0x17C6 | [0x17C9..0x17D3] | 0x17DD | [0x180B..0x180D] | 0x18A9 | [0x1920..0x1922] | [0x1927..0x1928] | 0x1932 | [0x1939..0x193B] | [0x1A17..0x1A18] | 0x1A56 | [0x1A58..0x1A5E] | 0x1A60 | 0x1A62 | [0x1A65..0x1A6C] | [0x1A73..0x1A7C] | 0x1A7F | [0x1B00..0x1B03] | 0x1B34 | [0x1B36..0x1B3A] | 0x1B3C | 0x1B42 | [0x1B6B..0x1B73] | [0x1B80..0x1B81] | [0x1BA2..0x1BA5] | [0x1BA8..0x1BA9] | 0x1BAB | 0x1BE6 | [0x1BE8..0x1BE9] | 0x1BED | [0x1BEF..0x1BF1] | [0x1C2C..0x1C33] | [0x1C36..0x1C37] | [0x1CD0..0x1CD2] | [0x1CD4..0x1CE0] | [0x1CE2..0x1CE8] | 0x1CED | 0x1CF4 | [0x1DC0..0x1DE6] | [0x1DFC..0x1DFF] | [0x20D0..0x20DC] | 0x20E1 | [0x20E5..0x20F0] | [0x2CEF..0x2CF1] | 0x2D7F | [0x2DE0..0x2DFF] | [0x302A..0x302D] | [0x3099..0x309A] | 0xA66F | [0xA674..0xA67D] | 0xA69F | [0xA6F0..0xA6F1] | 0xA802 | 0xA806 | 0xA80B | [0xA825..0xA826] | 0xA8C4 | [0xA8E0..0xA8F1] | [0xA926..0xA92D] | [0xA947..0xA951] | [0xA980..0xA982] | 0xA9B3 | [0xA9B6..0xA9B9] | 0xA9BC | [0xAA29..0xAA2E] | [0xAA31..0xAA32] | [0xAA35..0xAA36] | 0xAA43 | 0xAA4C | 0xAAB0 | [0xAAB2..0xAAB4] | [0xAAB7..0xAAB8] | [0xAABE..0xAABF] | 0xAAC1 | [0xAAEC..0xAAED] | 0xAAF6 | 0xABE5 | 0xABE8 | 0xABED | 0xFB1E | [0xFE00..0xFE0F] | [0xFE20..0xFE26] | 0x101FD | [0x10A01..0x10A03] | [0x10A05..0x10A06] | [0x10A0C..0x10A0F] | [0x10A38..0x10A3A] | 0x10A3F | 0x11001 | [0x11038..0x11046] | [0x11080..0x11081] | [0x110B3..0x110B6] | [0x110B9..0x110BA] | [0x11100..0x11102] | [0x11127..0x1112B] | [0x1112D..0x11134] | [0x11180..0x11181] | [0x111B6..0x111BE] | 0x116AB | 0x116AD | [0x116B0..0x116B5] | 0x116B7 | [0x16F8F..0x16F92] | [0x1D167..0x1D169] | [0x1D17B..0x1D182] | [0x1D185..0x1D18B] | [0x1D1AA..0x1D1AD] | [0x1D242..0x1D244];

unicode_nd = [0x0030..0x0039] | [0x0660..0x0669] | [0x06F0..0x06F9] | [0x07C0..0x07C9] | [0x0966..0x096F] | [0x09E6..0x09EF] | [0x0A66..0x0A6F] | [0x0AE6..0x0AEF] | [0x0B66..0x0B6F] | [0x0BE6..0x0BEF] | [0x0C66..0x0C6F] | [0x0CE6..0x0CEF] | [0x0D66..0x0D6F] | [0x0E50..0x0E59] | [0x0ED0..0x0ED9] | [0x0F20..0x0F29] | [0x1040..0x1049] | [0x1090..0x1099] | [0x17E0..0x17E9] | [0x1810..0x1819] | [0x1946..0x194F] | [0x19D0..0x19D9] | [0x1A80..0x1A89] | [0x1A90..0x1A99] | [0x1B50..0x1B59] | [0x1BB0..0x1BB9] | [0x1C40..0x1C49] | [0x1C50..0x1C59] | [0xA620..0xA629] | [0xA8D0..0xA8D9] | [0xA900..0xA909] | [0xA9D0..0xA9D9] | [0xAA50..0xAA59] | [0xABF0..0xABF9] | [0xFF10..0xFF19] | [0x104A0..0x104A9] | [0x11066..0x1106F] | [0x110F0..0x110F9] | [0x11136..0x1113F] | [0x111D0..0x111D9] | [0x116C0..0x116C9];

unicode_nl = [0x16EE..0x16F0] | [0x2160..0x2182] | [0x2185..0x2188] | 0x3007 | [0x3021..0x3029] | [0x3038..0x303A] | [0xA6E6..0xA6EF] | [0x10140..0x10174] | 0x10341 | 0x1034A | [0x103D1..0x103D5];

unicode_no = [0x00B2..0x00B3] | 0x00B9 | [0x00BC..0x00BE] | [0x09F4..0x09F9] | [0x0B72..0x0B77] | [0x0BF0..0x0BF2] | [0x0C78..0x0C7E] | [0x0D70..0x0D75] | [0x0F2A..0x0F33] | [0x1369..0x137C] | [0x17F0..0x17F9] | 0x19DA | 0x2070 | [0x2074..0x2079] | [0x2080..0x2089] | [0x2150..0x215F] | 0x2189 | [0x2460..0x249B] | [0x24EA..0x24FF] | [0x2776..0x2793] | 0x2CFD | [0x3192..0x3195] | [0x3220..0x3229] | [0x3248..0x324F] | [0x3251..0x325F] | [0x3280..0x3289] | [0x32B1..0x32BF] | [0xA830..0xA835] | [0x10107..0x10133] | [0x10175..0x10178] | 0x1018A | [0x10320..0x10323] | [0x10858..0x1085F] | [0x10916..0x1091B] | [0x10A40..0x10A47] | [0x10A7D..0x10A7E] | [0x10B58..0x10B5F] | [0x10B78..0x10B7F] | [0x10E60..0x10E7E] | [0x11052..0x11065] | [0x1D360..0x1D371];

unicode_pc = 0x005F | [0x203F..0x2040] | 0x2054 | [0xFE33..0xFE34] | [0xFE4D..0xFE4F];

unicode_pd = 0x002D | 0x058A | 0x05BE | 0x1400 | 0x1806 | [0x2010..0x2015] | 0x2E17 | 0x2E1A | [0x2E3A..0x2E3B] | 0x301C | 0x3030 | 0x30A0 | [0xFE31..0xFE32] | 0xFE58 | 0xFE63;

unicode_pe = 0x0029 | 0x005D | 0x007D | 0x0F3B | 0x0F3D | 0x169C | 0x2046 | 0x207E | 0x208E | 0x232A | 0x2769 | 0x276B | 0x276D | 0x276F | 0x2771 | 0x2773 | 0x2775 | 0x27C6 | 0x27E7 | 0x27E9 | 0x27EB | 0x27ED | 0x27EF | 0x2984 | 0x2986 | 0x2988 | 0x298A | 0x298C | 0x298E | 0x2990 | 0x2992 | 0x2994 | 0x2996 | 0x2998 | 0x29D9 | 0x29DB | 0x29FD | 0x2E23 | 0x2E25 | 0x2E27 | 0x2E29 | 0x3009 | 0x300B | 0x300D | 0x300F | 0x3011 | 0x3015 | 0x3017 | 0x3019 | 0x301B | [0x301E..0x301F] | 0xFD3F | 0xFE18 | 0xFE36 | 0xFE38 | 0xFE3A | 0xFE3C | 0xFE3E | 0xFE40 | 0xFE42 | 0xFE44 | 0xFE48 | 0xFE5A | 0xFE5C | 0xFE5E | 0xFF09 | 0xFF3D | 0xFF5D | 0xFF60;

unicode_pf = 0x00BB | 0x2019 | 0x201D | 0x203A | 0x2E03 | 0x2E05 | 0x2E0A | 0x2E0D | 0x2E1D;

unicode_pi = 0x00AB | 0x2018 | [0x201B..0x201C] | 0x201F | 0x2039 | 0x2E02 | 0x2E04 | 0x2E09 | 0x2E0C | 0x2E1C;

// 0x0022 and 0x0027 are removed so that we can have any - ''' or any - '"'
unicode_po = 0x0021 | 0x0023 | 0x0025 | 0x0026 | 0x002A | 0x002C | [0x002E..0x002F] | [0x003A..0x003B] | [0x003F..0x0040] | 0x005C | 0x00A1 | 0x00A7 | [0x00B6..0x00B7] | 0x00BF | 0x037E | 0x0387 | [0x055A..0x055F] | 0x0589 | 0x05C0 | 0x05C3 | 0x05C6 | [0x05F3..0x05F4] | [0x0609..0x060A] | [0x060C..0x060D] | 0x061B | [0x061E..0x061F] | [0x066A..0x066D] | 0x06D4 | [0x0700..0x070D] | [0x07F7..0x07F9] | [0x0830..0x083E] | 0x085E | [0x0964..0x0965] | 0x0970 | 0x0AF0 | 0x0DF4 | 0x0E4F | [0x0E5A..0x0E5B] | [0x0F04..0x0F12] | 0x0F14 | 0x0F85 | [0x0FD0..0x0FD4] | [0x0FD9..0x0FDA] | [0x104A..0x104F] | 0x10FB | [0x1360..0x1368] | [0x166D..0x166E] | [0x16EB..0x16ED] | [0x1735..0x1736] | [0x17D4..0x17D6] | [0x17D8..0x17DA] | [0x1800..0x1805] | [0x1807..0x180A] | [0x1944..0x1945] | [0x1A1E..0x1A1F] | [0x1AA0..0x1AA6] | [0x1AA8..0x1AAD] | [0x1B5A..0x1B60] | [0x1BFC..0x1BFF] | [0x1C3B..0x1C3F] | [0x1C7E..0x1C7F] | [0x1CC0..0x1CC7] | 0x1CD3 | [0x2016..0x2017] | [0x2020..0x2027] | [0x2030..0x2038] | [0x203B..0x203E] | [0x2041..0x2043] | [0x2047..0x2051] | 0x2053 | [0x2055..0x205E] | [0x2CF9..0x2CFC] | [0x2CFE..0x2CFF] | 0x2D70 | [0x2E00..0x2E01] | [0x2E06..0x2E08] | 0x2E0B | [0x2E0E..0x2E16] | [0x2E18..0x2E19] | 0x2E1B | [0x2E1E..0x2E1F] | [0x2E2A..0x2E2E] | [0x2E30..0x2E39] | [0x3001..0x3003] | 0x303D | 0x30FB | [0xA4FE..0xA4FF] | [0xA60D..0xA60F] | 0xA673 | 0xA67E | [0xA6F2..0xA6F7] | [0xA874..0xA877] | [0xA8CE..0xA8CF] | [0xA8F8..0xA8FA] | [0xA92E..0xA92F] | 0xA95F | [0xA9C1..0xA9CD] | [0xA9DE..0xA9DF] | [0xAA5C..0xAA5F] | [0xAADE..0xAADF] | [0xAAF0..0xAAF1] | 0xABEB | [0xFE10..0xFE16] | 0xFE19 | 0xFE30 | [0xFE45..0xFE46] | [0xFE49..0xFE4C] | [0xFE50..0xFE52] | [0xFE54..0xFE57] | [0xFE5F..0xFE61] | 0xFE68 | [0xFE6A..0xFE6B] | [0xFF01..0xFF03] | [0xFF05..0xFF07] | 0xFF0A | 0xFF0C | [0xFF0E..0xFF0F] | [0xFF1A..0xFF1B] | [0xFF1F..0xFF20] | 0xFF3C | 0xFF61 | [0xFF64..0xFF65] | [0x10100..0x10102] | 0x1039F | 0x103D0 | 0x10857 | 0x1091F | 0x1093F | [0x10A50..0x10A58] | 0x10A7F | [0x10B39..0x10B3F] | [0x11047..0x1104D] | [0x110BB..0x110BC] | [0x110BE..0x110C1] | [0x11140..0x11143] | [0x111C5..0x111C8];

unicode_ps = 0x0028 | 0x005B | 0x007B | 0x0F3A | 0x0F3C | 0x169B | 0x201A | 0x201E | 0x2045 | 0x207D | 0x208D | 0x2329 | 0x2768 | 0x276A | 0x276C | 0x276E | 0x2770 | 0x2772 | 0x2774 | 0x27C5 | 0x27E6 | 0x27E8 | 0x27EA | 0x27EC | 0x27EE | 0x2983 | 0x2985 | 0x2987 | 0x2989 | 0x298B | 0x298D | 0x298F | 0x2991 | 0x2993 | 0x2995 | 0x2997 | 0x29D8 | 0x29DA | 0x29FC | 0x2E22 | 0x2E24 | 0x2E26 | 0x2E28 | 0x3008 | 0x300A | 0x300C | 0x300E | 0x3010 | 0x3014 | 0x3016 | 0x3018 | 0x301A | 0x301D | 0xFD3E | 0xFE17 | 0xFE35 | 0xFE37 | 0xFE39 | 0xFE3B | 0xFE3D | 0xFE3F | 0xFE41 | 0xFE43 | 0xFE47 | 0xFE59 | 0xFE5B | 0xFE5D | 0xFF08 | 0xFF3B | 0xFF5B | 0xFF5F;

unicode_sc = 0x0024 | [0x00A2..0x00A5] | 0x058F | 0x060B | [0x09F2..0x09F3] | 0x09FB | 0x0AF1 | 0x0BF9 | 0x0E3F | 0x17DB | [0x20A0..0x20B9] | 0xA838 | 0xFDFC | 0xFE69 | 0xFF04 | [0xFFE0..0xFFE1];

unicode_sk = 0x005E | 0x0060 | 0x00A8 | 0x00AF | 0x00B4 | 0x00B8 | [0x02C2..0x02C5] | [0x02D2..0x02DF] | [0x02E5..0x02EB] | 0x02ED | [0x02EF..0x02FF] | 0x0375 | [0x0384..0x0385] | 0x1FBD | [0x1FBF..0x1FC1] | [0x1FCD..0x1FCF] | [0x1FDD..0x1FDF] | [0x1FED..0x1FEF] | [0x1FFD..0x1FFE] | [0x309B..0x309C] | [0xA700..0xA716] | [0xA720..0xA721] | [0xA789..0xA78A] | [0xFBB2..0xFBC1] | 0xFF3E | 0xFF40;

unicode_sm = 0x002B | [0x003C..0x003E] | 0x007C | 0x007E | 0x00AC | 0x00B1 | 0x00D7 | 0x00F7 | 0x03F6 | [0x0606..0x0608] | 0x2044 | 0x2052 | [0x207A..0x207C] | [0x208A..0x208C] | 0x2118 | [0x2140..0x2144] | 0x214B | [0x2190..0x2194] | [0x219A..0x219B] | 0x21A0 | 0x21A3 | 0x21A6 | 0x21AE | [0x21CE..0x21CF] | 0x21D2 | 0x21D4 | [0x21F4..0x22FF] | [0x2308..0x230B] | [0x2320..0x2321] | 0x237C | [0x239B..0x23B3] | [0x23DC..0x23E1] | 0x25B7 | 0x25C1 | [0x25F8..0x25FF] | 0x266F | [0x27C0..0x27C4] | [0x27C7..0x27E5] | [0x27F0..0x27FF] | [0x2900..0x2982] | [0x2999..0x29D7] | [0x29DC..0x29FB] | [0x29FE..0x2AFF] | [0x2B30..0x2B44] | [0x2B47..0x2B4C] | 0xFB29 | 0xFE62 | [0xFE64..0xFE66] | 0xFF0B | [0xFF1C..0xFF1E] | 0xFF5C | 0xFF5E | 0xFFE2 | [0xFFE9..0xFFEC] | 0x1D6C1 | 0x1D6DB | 0x1D6FB | 0x1D715 | 0x1D735 | 0x1D74F | 0x1D76F | 0x1D789 | 0x1D7A9 | 0x1D7C3;

unicode_so = 0x00A6 | 0x00A9 | 0x00AE | 0x00B0 | 0x0482 | [0x060E..0x060F] | 0x06DE | 0x06E9 | [0x06FD..0x06FE] | 0x07F6 | 0x09FA | 0x0B70 | [0x0BF3..0x0BF8] | 0x0BFA | 0x0C7F | 0x0D79 | [0x0F01..0x0F03] | 0x0F13 | [0x0F15..0x0F17] | [0x0F1A..0x0F1F] | 0x0F34 | 0x0F36 | 0x0F38 | [0x0FBE..0x0FC5] | [0x0FC7..0x0FCC] | [0x0FCE..0x0FCF] | [0x0FD5..0x0FD8] | [0x109E..0x109F] | [0x1390..0x1399] | 0x1940 | [0x19DE..0x19FF] | [0x1B61..0x1B6A] | [0x1B74..0x1B7C] | [0x2100..0x2101] | [0x2103..0x2106] | [0x2108..0x2109] | 0x2114 | [0x2116..0x2117] | [0x211E..0x2123] | 0x2125 | 0x2127 | 0x2129 | 0x212E | [0x213A..0x213B] | 0x214A | [0x214C..0x214D] | 0x214F | [0x2195..0x2199] | [0x219C..0x219F] | [0x21A1..0x21A2] | [0x21A4..0x21A5] | [0x21A7..0x21AD] | [0x21AF..0x21CD] | [0x21D0..0x21D1] | 0x21D3 | [0x21D5..0x21F3] | [0x2300..0x2307] | [0x230C..0x231F] | [0x2322..0x2328] | [0x232B..0x237B] | [0x237D..0x239A] | [0x23B4..0x23DB] | [0x23E2..0x23F3] | [0x2400..0x2426] | [0x2440..0x244A] | [0x249C..0x24E9] | [0x2500..0x25B6] | [0x25B8..0x25C0] | [0x25C2..0x25F7] | [0x2600..0x266E] | [0x2670..0x26FF] | [0x2701..0x2767] | [0x2794..0x27BF] | [0x2800..0x28FF] | [0x2B00..0x2B2F] | [0x2B45..0x2B46] | [0x2B50..0x2B59] | [0x2CE5..0x2CEA] | [0x2E80..0x2E99] | [0x2E9B..0x2EF3] | [0x2F00..0x2FD5] | [0x2FF0..0x2FFB] | 0x3004 | [0x3012..0x3013] | 0x3020 | [0x3036..0x3037] | [0x303E..0x303F] | [0x3190..0x3191] | [0x3196..0x319F] | [0x31C0..0x31E3] | [0x3200..0x321E] | [0x322A..0x3247] | 0x3250 | [0x3260..0x327F] | [0x328A..0x32B0] | [0x32C0..0x32FE] | [0x3300..0x33FF] | [0x4DC0..0x4DFF] | [0xA490..0xA4C6] | [0xA828..0xA82B] | [0xA836..0xA837] | 0xA839 | [0xAA77..0xAA79] | 0xFDFD | 0xFFE4 | 0xFFE8 | [0xFFED..0xFFEE] | [0xFFFC..0xFFFD] | [0x10137..0x1013F] | [0x10179..0x10189] | [0x10190..0x1019B] | [0x101D0..0x101FC] | [0x1D000..0x1D0F5] | [0x1D100..0x1D126] | [0x1D129..0x1D164] | [0x1D16A..0x1D16C] | [0x1D183..0x1D184] | [0x1D18C..0x1D1A9] | [0x1D1AE..0x1D1DD] | [0x1D200..0x1D241] | 0x1D245 | [0x1D300..0x1D356] | [0x1F000..0x1F02B] | [0x1F030..0x1F093] | [0x1F0A0..0x1F0AE] | [0x1F0B1..0x1F0BE] | [0x1F0C1..0x1F0CF] | [0x1F0D1..0x1F0DF] | [0x1F110..0x1F12E] | [0x1F130..0x1F16B] | [0x1F170..0x1F19A] | [0x1F1E6..0x1F202] | [0x1F210..0x1F23A] | [0x1F240..0x1F248] | [0x1F250..0x1F251] | [0x1F300..0x1F320] | [0x1F330..0x1F335] | [0x1F337..0x1F37C] | [0x1F380..0x1F393] | [0x1F3A0..0x1F3C4] | [0x1F3C6..0x1F3CA] | [0x1F3E0..0x1F3F0] | [0x1F400..0x1F43E] | 0x1F440 | [0x1F442..0x1F4F7] | [0x1F4F9..0x1F4FC] | [0x1F500..0x1F53D] | [0x1F540..0x1F543] | [0x1F550..0x1F567] | [0x1F5FB..0x1F640] | [0x1F645..0x1F64F] | [0x1F680..0x1F6C5];

unicode_zl = 0x2028;

unicode_zp = 0x2029;

unicode_zs = 0x0020 | 0x00A0 | 0x1680 | 0x180E | [0x2000..0x200A] | 0x202F | 0x205F;

unicode_all = unicode_cc | unicode_cf | unicode_co | unicode_cs | unicode_ll | unicode_lm | unicode_lo | unicode_lt | unicode_lu
  | unicode_mc | unicode_me | unicode_mn | unicode_nd | unicode_nl | unicode_no | unicode_pc | unicode_pd | unicode_pe | unicode_pf |
  | unicode_pi | unicode_po | unicode_ps | unicode_sc | unicode_sk | unicode_sm | unicode_so | unicode_zl | unicode_zp | unicode_zs;

Tokens

// Hex digits
a = a;
b = b;
c = c;
d = d;
e = e;
f = f;

// needed for defining literals.
u = u;
n = n;
x = x;

// <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 
digit = ['0'..'9'];

white_space = ( unicode_zs | unicode_zl | unicode_zp | [0x00a..0x00d] | 0x0085 )+;

newline = ( 0x00a | 0x00d | 0x0085 )+;

// <simple Latin upper case letter> ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
simple_latin_upper_case_letter = ['A'..'Z'];

// <simple Latin lower case letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
simple_latin_lower_case_letter = ['a'..'z'];
underscore = '_';
minus_sign = '-';
space = ' ';
space1 = ' ';
double_quote_open = '"';
double_quote_close = '"';
percent = '%';
ampersand = '&';
quote_open = ''';
quote_close = ''';
left_paren = '(';
right_paren = ')';
asterisk = '*';
plus_sign = '+';
comma = ',';
period = '.';
period1 = '.';
solidus = '/';
reverse_solidus = '\';
colon = ':';
colon1 = ':';
semicolon = ';';
less_than_operator = '<';
equals_operator = '=';
greater_than_operator = '>';
question_mark = '?';
left_bracket = '[';
left_bracket_trigraph = '??(';
right_bracket = ']';
right_bracket_trigraph = '??)';
circumflex = '^';
vertical_bar = '|';
left_brace = '{';
right_brace = '}';
not_equals_operator = '<>';
greater_than_or_equals_operator = '>=';
less_than_or_equals_operator = '<=';
concatenation_operator = '||';
right_arrow = '->';
double_colon = '::';
double_period = '..';
named_argument_assignment_token = '=>';
bracketed_comment_introducer = '/*';
bracketed_comment_terminator = '*/';
doublequote_symbol = '""';
kilo = 'K';
mega = 'M';
giga = 'G';
tera = 'T';
peta = 'P';

//  <simple comment introducer> ::= <minus sign><minus sign>
simple_comment_introducer = '--';

// <nonquote character> ::= !! See the Syntax Rules.
nonquote_character = unicode_all | 0x0022;

//  <nondoublequote character> ::= !! See the Syntax Rules.
nondoublequote_character = unicode_all | 0x0027;

//  <Unicode escape character> ::= !! See the Syntax Rules.
unicode_escape_character = unicode_cc | unicode_cf | unicode_co | unicode_cs | unicode_lm | unicode_lo | unicode_lt | unicode_mc
  | unicode_me | unicode_mn | unicode_nd | unicode_no | unicode_pc | unicode_pd | unicode_pe | unicode_pf | unicode_pi | unicode_po
  | unicode_ps | unicode_sc | unicode_sk | unicode_sm | unicode_so;

// <identifier start> ::= !! See the Syntax Rules.
identifier_start = unicode_lu | unicode_ll | unicode_lt | unicode_lm | unicode_lo | unicode_nl;

// <identifier extend> ::= !! See the Syntax Rules.
identifier_extend = unicode_lu | unicode_ll | unicode_lt | unicode_lm | unicode_lo | unicode_nl | unicode_mn | unicode_mc | unicode_nd | unicode_pc | unicode_cf;

// non-reserved words
t_a = a;
t_absolute = a b s o l u t e ;
t_action = a c t i o n ;
t_ada = a d a ;
t_add = a d d ;
t_admin = a d m i n ;
t_after = a f t e r ;
t_always = a l w a y s ;
t_asc = a s c ;
t_assertion = a s s e r t i o n ;
t_assignment = a s s i g n m e n t ;
t_attribute = a t t r i b u t e ;
t_attributes = a t t r i b u t e s ;
t_before = b e f o r e ;
t_bernoulli = b e r n o u l l i ;
t_breadth = b r e a d t h ;
t_c = c;
t_cascade = c a s c a d e ;
t_catalog = c a t a l o g ;
t_catalog_name = c a t a l o g '_' n a m e ;
t_chain = c h a i n ;
t_character_set_catalog = c h a r a c t e r '_' s e t '_' c a t a l o g ;
t_character_set_name = c h a r a c t e r '_' s e t '_' n a m e ;
t_character_set_schema = c h a r a c t e r '_' s e t '_' s c h e m a ;
t_characteristics = c h a r a c t e r i s t i c s ;
t_characters = c h a r a c t e r s ;
t_class_origin = c l a s s '_' o r i g i n ;
t_cobol = c o b o l ;
t_collation = c o l l a t i o n ;
t_collation_catalog = c o l l a t i o n '_' c a t a l o g ;
t_collation_name = c o l l a t i o n '_' n a m e ;
t_collation_schema = c o l l a t i o n '_' s c h e m a ;
t_column_name = c o l u m n '_' n a m e ;
t_command_function = c o m m a n d '_' f u n c t i o n ;
t_command_function_code = c o m m a n d '_' f u n c t i o n '_' c o d e ;
t_committed = c o m m i t t e d ;
t_condition_number = c o n d i t i o n '_' n u m b e r ;
t_connection = c o n n e c t i o n ;
t_connection_name = c o n n e c t i o n '_' n a m e ;
t_constraint_catalog = c o n s t r a i n t '_' c a t a l o g ;
t_constraint_name = c o n s t r a i n t '_' n a m e ;
t_constraint_schema = c o n s t r a i n t '_' s c h e m a ;
t_constraints = c o n s t r a i n t s ;
t_constructor = c o n s t r u c t o r ;
t_continue = c o n t i n u e ;
t_cursor_name = c u r s o r '_' n a m e ;
t_data = d a t a ;
t_datetime_interval_code = d a t e t i m e '_' i n t e r v a l '_' c o d e ;
t_datetime_interval_precision = d a t e t i m e '_' i n t e r v a l '_' p r e c i s i o n ;
t_defaults = d e f a u l t s ;
t_deferrable = d e f e r r a b l e ;
t_deferred = d e f e r r e d ;
t_defined = d e f i n e d ;
t_definer = d e f i n e r ;
t_degree = d e g r e e ;
t_depth = d e p t h ;
t_derived = d e r i v e d ;
t_desc = d e s c ;
t_descriptor = d e s c r i p t o r ;
t_diagnostics = d i a g n o s t i c s ;
t_dispatch = d i s p a t c h ;
t_domain = d o m a i n ;
t_dynamic_function = d y n a m i c '_' f u n c t i o n ;
t_dynamic_function_code = d y n a m i c '_' f u n c t i o n '_' c o d e ;
t_enforced = e n f o r c e d ;
t_exclude = e x c l u d e ;
t_excluding = e x c l u d i n g ;
t_expression = e x p r e s s i o n ;
t_final = f i n a l ;
t_first = f i r s t ; 
t_flag = f l a g ;
t_following = f o l l o w i n g ;
t_fortran = f o r t r a n ;
t_found = f o u n d ;
t_general = g e n e r a l ;
t_generated = g e n e r a t e d ;
t_g = g;
t_go = g o ;
t_goto = g o t o ;
t_granted = g r a n t e d ;
t_hierarchy = h i e r a r c h y ;
t_ignore = i g n o r e ;
t_immediate = i m m e d i a t e ;
t_immediately = i m m e d i a t e l y ;
t_implementation = i m p l e m e n t a t i o n ;
t_including = i n c l u d i n g ;
t_increment = i n c r e m e n t ;
t_initially = i n i t i a l l y ;
t_input = i n p u t ;
t_instance = i n s t a n c e ;
t_instantiable = i n s t a n t i a b l e ;
t_instead = i n s t e a d ;
t_invoker = i n v o k e r ; 
t_isolation = i s o l a t i o n ;
t_k = k;
t_key = k e y ;
t_key_member = k e y '_' m e m b e r ;
t_key_type = k e y '_' t y p e ;
t_last = l a s t ;
t_length = l e n g t h ;
t_level = l e v e l ;
t_locator = l o c a t o r ;
t_m = m; 
t_map = m a p ; 
t_matched = m a t c h e d ;
t_maxvalue = m a x v a l u e ;
t_message_length = m e s s a g e '_' l e n g t h ;
t_message_octet_length = m e s s a g e '_' o c t e t '_' l e n g t h ;
t_message_text = m e s s a g e '_' t e x t ;
t_minvalue = m i n v a l u e ;
t_more = m o r e ;
t_mumps = m u m p s ;
t_name = n a m e ;
t_names = n a m e s ;
t_nesting = n e s t i n g ;
t_next = n e x t ;
t_nfc = n f c ;
t_nfd = n f d ;
t_nfkc = n f k c ;
t_nfkd = n f k d ;
t_normalized = n o r m a l i z e d ;
t_nullable = n u l l a b l e ;
t_nulls = n u l l s ;
t_number = n u m b e r ;
t_object = o b j e c t ;
t_octets = o c t e t s ;
t_option = o p t i o n ;
t_options = o p t i o n s ;
t_ordering = o r d e r i n g ;
t_ordinality = o r d i n a l i t y ;
t_others = o t h e r s ; 
t_output = o u t p u t ;
t_overriding = o v e r r i d i n g ;
t_p = p;
t_pad = p a d ;
t_parameter_mode = p a r a m e t e r '_' m o d e ;
t_parameter_name = p a r a m e t e r '_' n a m e ;
t_parameter_ordinal_position = p a r a m e t e r '_' o r d i n a l '_' p o s i t i o n ;
t_parameter_specific_catalog = p a r a m e t e r '_' s p e c i f i c '_' c a t a l o g ;
t_parameter_specific_name = p a r a m e t e r '_' s p e c i f i c '_' n a m e ;
t_parameter_specific_schema = p a r a m e t e r '_' s p e c i f i c '_' s c h e m a ;
t_partial = p a r t i a l ;
t_pascal = p a s c a l ;
t_path = p a t h ;
t_placing = p l a c i n g ;
t_pli = p l i ;
t_preceding = p r e c e d i n g ;
t_preserve = p r e s e r v e ;
t_prior = p r i o r ;
t_privileges = p r i v i l e g e s ;
t_public = p u b l i c ;
t_read = r e a d ;
t_relative = r e l a t i v e ;
t_repeatable = r e p e a t a b l e ;
t_respect = r e s p e c t ;
t_restart = r e s t a r t ;
t_restrict = r e s t r i c t ;
t_returned_cardinality = r e t u r n e d '_' c a r d i n a l i t y ;
t_returned_length = r e t u r n e d '_' l e n g t h ;
t_returned_octet_length = r e t u r n e d '_' o c t e t '_' l e n g t h ;
t_returned_sqlstate = r e t u r n e d '_' s q l s t a t e ;
t_role = r o l e ;
t_routine = r o u t i n e ;
t_routine_catalog = r o u t i n e '_' c a t a l o g ;
t_routine_name = r o u t i n e '_' n a m e ;
t_routine_schema = r o u t i n e '_' s c h e m a ;
t_row_count = r o w '_' c o u n t ;
t_scale = s c a l e ;
t_schema = s c h e m a ;
t_schema_name = s c h e m a '_' n a m e ;
t_scope_catalog = s c o p e '_' c a t a l o g ;
t_scope_name = s c o p e '_' n a m e ;
t_scope_schema = s c o p e '_' s c h e m a ;
t_section = s e c t i o n ; 
t_security = s e c u r i t y ;
t_self = s e l f ;
t_sequence = s e q u e n c e ;
t_serializable = s e r i a l i z a b l e ;
t_server_name = s e r v e r '_' n a m e ;
t_session = s e s s i o n ;
t_sets = s e t s ;
t_simple = s i m p l e ;
t_size = s i z e ;
t_source = s o u r c e ;
t_space = s p a c e ;
t_specific_name = s p e c i f i c '_' n a m e ;
t_state = s t a t e ;
t_statement = s t a t e m e n t ;
t_structure = s t r u c t u r e ;
t_style = s t y l e ;
t_subclass_origin = s u b c l a s s '_' o r i g i n ;
t_t = t;
t_table_name = t a b l e '_' n a m e ;
t_temporary = t e m p o r a r y ;
t_ties = t i e s ;
t_top_level_count = t o p '_' l e v e l '_' c o u n t ;
t_transaction = t r a n s a c t i o n ; 
t_transaction_active = t r a n s a c t i o n '_' a c t i v e ;
t_transactions_committed = t r a n s a c t i o n s '_' c o m m i t t e d ;
t_transactions_rolled_back = t r a n s a c t i o n s '_' r o l l e d '_' b a c k ;
t_transform = t r a n s f o r m ;
t_transforms = t r a n s f o r m s ;
t_trigger_catalog = t r i g g e r '_' c a t a l o g ;
t_trigger_name = t r i g g e r '_' n a m e ;
t_trigger_schema = t r i g g e r '_' s c h e m a ;
t_type = t y p e ;
t_unbounded = u n b o u n d e d ;
t_uncommitted = u n c o m m i t t e d ;
t_under = u n d e r ;
t_unnamed = u n n a m e d ;
t_usage = u s a g e ;
t_user_defined_type_catalog = u s e r '_' d e f i n e d '_' t y p e '_' c a t a l o g ;
t_user_defined_type_code = u s e r '_' d e f i n e d '_' t y p e '_' c o d e ;
t_user_defined_type_name = u s e r '_' d e f i n e d '_' t y p e '_' n a m e ;
t_user_defined_type_schema = u s e r '_' d e f i n e d '_' t y p e '_' s c h e m a ;
t_utf8 = u t f '8';
t_utf16 = u t f '1' '6';
t_view = v i e w ;
t_work = w o r k ;
t_write = w r i t e ;
t_zone = z o n e ;

// reserved words
t_abs = a b s ;
t_all = a l l ;
t_allocate = a l l o c a t e ;
t_alter = a l t e r ;
t_and = a n d ;
t_any = a n y ;
t_are = a r e ;
t_array = a r r a y ;
t_array_agg = a r r a y '_' a g g ; 
t_array_max_cardinality = a r r a y '_' m a x '_' c a r d i n a l i t y ;
t_as = a s ;
t_asensitive = a s e n s i t i v e ;
t_asymmetric = a s y m m e t r i c ;
t_at = a t ;
t_atomic = a t o m i c ;
t_authorization = a u t h o r i z a t i o n ;
t_avg = a v g ;
t_begin = b e g i n ;
t_begin_frame = b e g i n '_' f r a m e ;
t_begin_partition = b e g i n '_' p a r t i t i o n ;
t_between = b e t w e e n ;
t_bigint = b i g i n t ;
t_binary = b i n a r y ;
t_blob = b l o b ;
t_boolean = b o o l e a n ;
t_both = b o t h ; 
t_by = b y ;
t_call = c a l l ;
t_called = c a l l e d ;
t_cardinality = c a r d i n a l i t y ;
t_cascaded = c a s c a d e d ;
t_case = c a s e ;
t_cast = c a s t;
t_ceil = c e i l ;
t_ceiling = c e i l i n g ;
t_char = c h a r ;
t_char_length = c h a r '_' l e n g t h ;
t_character = c h a r a c t e r ;
t_character_length = c h a r a c t e r '_' l e n g t h ;
t_check = c h e c k ;
t_clob = c l o b ;
t_close = c l o s e ; 
t_coalesce = c o a l e s c e ;
t_collate = c o l l a t e ;
t_collect = c o l l e c t ;
t_column = c o l u m n ;
t_commit = c o m m i t ;
t_condition = c o n d i t i o n ;
t_connect = c o n n e c t ;
t_constraint = c o n s t r a i n t ;
t_contains = c o n t a i n s ;
t_convert = c o n v e r t ;
t_corr = c o r r ; 
t_corresponding = c o r r e s p o n d i n g ;
t_count = c o u n t ;
t_covar_pop = c o v a r '_' p o p ; 
t_covar_samp = c o v a r '_' s a m p ;
t_create = c r e a t e ;
t_cross = c r o s s ;
t_cube = c u b e ;
t_cume_dist = c u m e '_' d i s t ;
t_current = c u r r e n t ;
t_current_catalog = c u r r e n t '_' c a t a l o g ;
t_current_date = c u r r e n t '_' d a t e ;
t_current_default_transform_group = c u r r e n t '_' d e f a u l t '_' t r a n s f o r m '_' g r o u p ;
t_current_path = c u r r e n t '_' p a t h ;
t_current_role = c u r r e n t '_' r o l e ;
t_current_row = c u r r e n t '_' r o w ;
t_current_schema = c u r r e n t '_' s c h e m a ;
t_current_time = c u r r e n t '_' t i m e ;
t_current_timestamp = c u r r e n t '_' t i m e s t a m p ;
t_current_transform_group_for_type = c u r r e n t '_' t r a n s f o r m '_' g r o u p '_' f o r '_' t y p e ;
t_current_user = c u r r e n t '_' u s e r ;
t_cursor = c u r s o r ;
t_cycle = c y c l e ;
t_date = d a t e ;
t_day = d a y ;
t_deallocate = d e a l l o c a t e ;
t_dec = d e c ;
t_decimal = d e c i m a l ; 
t_declare = d e c l a r e ;
t_default = d e f a u l t ;
t_delete = d e l e t e ;
t_dense_rank = d e n s e '_' r a n k ;
t_deref = d e r e f ;
t_describe = d e s c r i b e ;
t_deterministic = d e t e r m i n i s t i c ;
t_disconnect = d i s c o n n e c t ;
t_distinct = d i s t i n c t ; 
t_double = d o u b l e ;
t_drop = d r o p ;
t_dynamic = d y n a m i c ;
t_each = e a c h ;
t_element = e l e m e n t ;
t_else = e l s e ;
t_end = e n d ;
t_end_frame = e n d '_' f r a m e ;
t_end_partition = e n d '_' p a r t i t i o n ;
t_end_exec = e n d '-' e x e c ;
t_equals = e q u a l s ;
t_escape = e s c a p e ;
t_every = e v e r y ;
t_except = e x c e p t ; 
t_exec = e x e c ;
t_execute = e x e c u t e ;
t_exists = e x i s t s ;
t_exp = e x p ;
t_external = e x t e r n a l ;
t_extract = e x t r a c t ;
t_false = f a l s e ;
t_fetch = f e t c h ;
t_filter = f i l t e r ;
t_first_value = f i r s t '_' v a l u e ;
t_float = f l o a t ;
t_floor = f l o o r ;
t_for = f o r ;
t_foreign = f o r e i g n ;
t_frame_row = f r a m e '_' r o w ;
t_free = f r e e ;
t_from = f r o m ;
t_full = f u l l ;
t_function = f u n c t i o n ;
t_fusion = f u s i o n ;
t_get = g e t ;
t_global = g l o b a l ; 
t_grant = g r a n t ;
t_group = g r o u p ;
t_grouping = g r o u p i n g ;
t_groups = g r o u p s ;
t_having = h a v i n g ;
t_hold = h o l d ;
t_hour = h o u r ;
t_identity = i d e n t i t y ;
t_in = i n ;
t_indicator = i n d i c a t o r ;
t_inner = i n n e r ;
t_inout = i n o u t ;
t_insensitive = i n s e n s i t i v e ;
t_insert = i n s e r t ;
t_int = i n t ;
t_integer = i n t e g e r ;
t_intersect = i n t e r s e c t ;
t_intersection = i n t e r s e c t i o n ; 
t_interval = i n t e r v a l ; 
t_into = i n t o ;
t_is = i s ;
t_join = j o i n ; 
t_lag = l a g ;
t_language = l a n g u a g e ;
t_large = l a r g e ;
t_last_value = l a s t '_' v a l u e ;
t_lateral = l a t e r a l ;
t_lead = l e a d ;
t_leading = l e a d i n g ;
t_left = l e f t ;
t_like = l i k e ;
t_like_regex = l i k e '_' r e g e x ;
t_ln = l n ;
t_local = l o c a l ;
t_localtime = l o c a l t i m e ;
t_localtimestamp = l o c a l t i m e s t a m p ;
t_lower = l o w e r ;
t_match = m a t c h ;
t_max = m a x ;
t_member = m e m b e r ;
t_merge = m e r g e ;
t_method = m e t h o d ;
t_min = m i n ;
t_minute = m i n u t e ;
t_mod = m o d ;
t_modifies = m o d i f i e s ;
t_module = m o d u l e ;
t_month = m o n t h ;
t_multiset = m u l t i s e t ;
t_national = n a t i o n a l ;
t_natural = n a t u r a l ;
t_nchar = n c h a r ;
t_nclob = n c l o b ;
t_new = n e w ;
t_no = n o ;
t_none = n o n e ;
t_normalize = n o r m a l i z e ;
t_not = n o t ;
t_nth_value = n t h '_' v a l u e ;
t_ntile = n t i l e ;
t_null = n u l l ;
t_nullif = n u l l i f ;
t_numeric = n u m e r i c ;
t_octet_length = o c t e t '_' l e n g t h ;
t_occurrence = o c c u r r e n c e ;
t_occurrences_regex = o c c u r r e n c e s '_' r e g e x ;
t_of = o f ; 
t_offset = o f f s e t ;
t_old = o l d ;
t_on = o n ;
t_only = o n l y ;
t_open = o p e n ;
t_or = o r ; 
t_order = o r d e r ;
t_out = o u t ;
t_outer = o u t e r ;
t_over = o v e r ;
t_overlaps = o v e r l a p s ;
t_overlay = o v e r l a  y ;
t_parameter = p a r a m e t e r ;
t_partition = p a r t i t i o n ;
t_percent = p e r c e n t ;
t_percent_rank = p e r c e n t '_' r a n k ;
t_percentile_cont = p e r c e n t i l e '_' c o n t ;
t_percentile_disc = p e r c e n t i l e '_' d i s c ;
t_period = p e r i o d ;
t_portion = p o r t i o n ;
t_position = p o s i t i o n ;
t_position_regex = p o s i t i o n '_' r e g e x ;
t_power = p o w e r ;
t_precedes = p r e c e d e s ;
t_precision = p r e c i s i o n ;
t_prepare = p r e p a r e ;
t_primary = p r i m a r y ;
t_procedure = p r o c e d u r e ;
t_range = r a n g e ;
t_rank = r a n k ;
t_reads = r e a d s ;
t_real = r e a l ;
t_recursive = r e c u r s i v e ;
t_ref = r e f ;
t_references = r e f e r e n c e s ;
t_referencing = r e f e r e n c i n g ;
t_regr_avgx = r e g r '_' a v g x ;
t_regr_avgy = r e g r '_' a v g y ;
t_regr_count = r e g r '_' c o u n t ;
t_regr_intercept = r e g r '_' i n t e r c e p t ;
t_regr_r2 = r e g r '_' r 2 ;
t_regr_slope = r e g r '_' s l o p e ;
t_regr_sxx = r e g r '_' s x x ;
t_regr_sxy = r e g r '_' s x y ;
t_regr_syy = r e g r '_' s y y ;
t_release = r e l e a s e ;
t_result = r e s u l t ;
t_return = r e t u r n ;
t_returns = r e t u r n s ;
t_revoke = r e v o k e ;
t_right = r i g h t ;
t_rollback = r o l l b a c k ;
t_rollup = r o l l u p ;
t_row = r o w ;
t_row_number = r o w '_' n u m b e r ;
t_rows = r o w s ;
t_savepoint = s a v e p o i n t ;
t_scope = s c o p e ;
t_scroll = s c r o l l ;
t_search = s e a r c h ;
t_second = s e c o n d ;
t_select = s e l e c t ;
t_sensitive = s e n s i t i v e ;
t_session_user = s e s s i o n '_' u s e r ;
t_set = s e t ; 
t_similar = s i m i l a r ; 
t_smallint = s m a l l i n t ;
t_some = s o m e ;
t_specific = s p e c i f i c ;
t_specifictype = s p e c i f i c t y p e ;
t_sql = s q l ;
t_sqlexception = s q l e x c e p t i o n ;
t_sqlstate = s q l s t a t e ;
t_sqlwarning = s q l w a r n i n g ;
t_sqrt = s q r t ;
t_start = s t a r t ;
t_static = s t a t i c ;
t_stddev_pop = s t d d e v '_' p o p ;
t_stddev_samp = s t d d e v '_' s a m p ;
t_submultiset = s u b m u l t i s e t ;
t_substring = s u b s t r i n g ;
t_substring_regex = s u b s t r i n g '_' r e g e x ;
t_succeeds = s u c c e e d s ;
t_sum = s u m ;
t_symmetric = s y m m e t r i c ;
t_system = s y s t e m ;
t_system_time = s y s t e m '_' t i m e ;
t_system_user = s y s t e m '_' u s e r ;
t_table = t a b l e ;
t_tablesample = t a b l e s a m p l e ;
t_then = t h e n ;
t_time = t i m e ;
t_timestamp = t i m e s t a m p ;
t_timezone_hour = t i m e z o n e '_' h o u r ;
t_timezone_minute = t i m e z o n e '_' m i n u t e ;
t_to = t o ;
t_trailing = t r a i l i n g ;
t_translate = t r a n s l a t e ;
t_translate_regex = t r a n s l a t e '_' r e g e x ;
t_translation = t r a n s l a t i o n ;
t_treat = t r e a t ;
t_trigger = t r i g g e r ;
t_truncate = t r u n c a t e ;
t_trim = t r i m ;
t_trim_array = t r i m '_' a r r a y ;
t_true = t r u e ;
t_uescape = u e s c a p e ;
t_union = u n i o n ;
t_unique = u n i q u e ;
t_unknown = u n k n o w n ;
t_unnest = u n n e s t ;
t_update = u p d a t e ;
t_upper = u p p e r ;
t_user = u s e r ;
t_using = u s i n g ;
t_value = v a l u e ;
t_values = v a l u e s ;
t_value_of = v a l u e '_' o f ;
t_var_pop = v a r '_' p o p ;
t_var_samp = v a r '_' s a m p ;
t_varbinary = v a r b i n a r y ;
t_varchar = v a r c h a r ;
t_varying = v a r y i n g ;
t_versioning = v e r s i o n i n g ;
t_when = w h e n ;
t_whenever = w h e n e v e r ;
t_where = w h e r e ;
t_width_bucket = w i d t h '_' b u c k e t ;
t_window = w i n d o w ;
t_with = w i t h ;
t_within = w i t h i n ;
t_without = w i t h o u t ;
t_year = y e a r ;

Productions

direct_sql_statements = direct_sql_statement+;

// <direct SQL statement> ::= <directly executable statement> <semicolon>
direct_sql_statement = directly_executable_statement semicolon;

// <directly executable statement> ::= <direct SQL data statement> | <SQL schema statement> | <SQL transaction statement> | <SQL connection statement> | <SQL session statement> | <direct implementation-defined statement>
// TODO: look at enabling the schema, transaction, connection, and session sql as well.
directly_executable_statement = {direct} direct_sql_data_statement; // | {schema} sql_schema_statment | {transaction} sql_transaction_statement | {connection} sql_connection_statement | {session} sql_session_statement;

// <direct SQL data statement> ::= <delete statement: searched> | <direct select statement: multiple rows> | <insert statement> | <update statement: searched> | <truncate table statement> | <merge statement> | <temporary table declaration>
direct_sql_data_statement = {delete} delete_statement_searched
     | {select} direct_select_statement_multiple | {insert} insert_statement | {update} update_statement_searched | {truncate} truncate_table_statement
     | {merge} merge_statement | {temp_table} temporary_table_declaration;

// <delete statement: searched> ::= DELETE FROM <target table> [ FOR PORTION OF <application time period name> FROM <point in time 1> TO <point in time 2> ] [ [ AS ] <correlation name> ] [ WHERE <search condition> ]
point_in_time_range = t_for t_portion t_of application_time_period_name t_from point_in_time1 t_to point_in_time2;
as_correlation = t_as? correlation_name;
where_clause = t_where search_condition;
delete_statement_searched = t_delete t_from target_table point_in_time_range? as_correlation? where_clause?;

// <truncate table statement> ::= TRUNCATE TABLE <target table> [ <identity column restart option> ]
truncate_table_statement = t_truncate t_table target_table identity_column_restart_option?;

// <identity column restart option> ::= CONTINUE IDENTITY | RESTART IDENTITY
identity_column_restart_option = {continue} t_continue t_identity | {restart} t_restart t_identity;

// <insert statement> ::= INSERT INTO <insertion target> <insert columns and source>
insert_statement = t_insert t_into insertion_target insert_columns_and_source;

// <insertion target> ::= <table name>
insertion_target = table_name;

// <insert columns and source> ::= <from subquery> | <from constructor> | <from default>
insert_columns_and_source = {subquery} from_subquery | {constructor} from_constructor | {default} from_default;

// <from subquery> ::= [ <left paren> <insert column list> <right paren> ] [ <override clause> ] <query expression>
paren_insert_column_list = left_paren insert_column_list right_paren;
from_subquery = paren_insert_column_list? override_clause? query_expression; 

// <from constructor> ::= [ <left paren> <insert column list> <right paren> ] [ <override clause> ] <contextually typed table value constructor>
from_constructor = paren_insert_column_list? override_clause? contextually_typed_table_value_constructor;

// <override clause> ::= OVERRIDING USER VALUE | OVERRIDING SYSTEM VALUE 
override_clause = {user} t_overriding t_user t_value | {system} t_overriding t_system t_value;

// <from default> ::= DEFAULT VALUES
from_default = t_default t_values;

// <insert column list> ::= <column name list>
insert_column_list = column_name_list;

// <merge statement> ::= MERGE INTO <target table> [ [ AS ] <merge correlation name> ] USING <table reference> ON <search condition> <merge operation specification>
// <merge correlation name> ::= <correlation name>
merge_statement = t_merge t_into target_table as_correlation? t_using table_reference t_on search_condition merge_operation_specification;

// <merge operation specification> ::= <merge when clause>...
merge_operation_specification = merge_when_clause+;

// <merge when clause> ::= <merge when matched clause> | <merge when not matched clause>
merge_when_clause = {match} merge_when_matched_clause | {no_match} merge_when_not_matched_clause;

// <merge when matched clause> ::= WHEN MATCHED [ AND <search condition> ] THEN <merge update or delete specification>
and_search = t_and search_condition;
merge_when_matched_clause = t_when t_matched and_search? t_then merge_update_or_delete_specification;

// <merge update or delete specification> ::= <merge update specification> | <merge delete specification>
merge_update_or_delete_specification = {update} merge_update_specification | {delete} merge_delete_specification;

// <merge when not matched clause> ::= WHEN NOT MATCHED [ AND <search condition> ] THEN <merge insert specification>
merge_when_not_matched_clause = t_when t_not t_matched and_search? t_then merge_insert_specification;

// <merge update specification> ::= UPDATE SET <set clause list>
merge_update_specification = t_update t_set set_clause_list;

// <merge delete specification> ::= DELETE
merge_delete_specification = t_delete;

// <merge insert specification> ::= INSERT [ <left paren> <insert column list> <right paren> ] [ <override clause> ] VALUES <merge insert value list>
merge_insert_specification = t_insert paren_insert_column_list? override_clause? t_values merge_insert_value_list;

// <merge insert value list> ::= <left paren> <merge insert value element> [ { <comma> <merge insert value element> }... ] <right paren>
addl_elements = comma merge_insert_value_element;
merge_insert_value_list = left_paren merge_insert_value_element addl_elements* right_paren;

// <merge insert value element> ::= <value expression> | <contextually typed value specification>
merge_insert_value_element = {exp} value_expression | {spec} contextually_typed_value_specification;

// <update statement: searched> ::= UPDATE <target table> [ FOR PORTION OF <application time period name> FROM <point in time 1> TO <point in time 2> ] [ [ AS ] <correlation name> ] SET <set clause list> [ WHERE <search condition> ]
update_statement_searched = t_update target_table point_in_time_range? as_correlation? t_set set_clause_list t_where search_condition;

// <set clause list> ::= <set clause> [ { <comma> <set clause> }... ]
addl_set_clause = comma set_clause;
set_clause_list = set_clause addl_set_clause*;

// <set clause> ::= <multiple column assignment> | <set target> <equals operator> <update source>
set_clause = {multi} multiple_column_assignment  | {target} set_target equals_operator update_source;

// <set target> ::= <update target> | <mutated set clause>
set_target = {update} update_target | {mutated} mutated_set_clause;

// <multiple column assignment> ::= <set target list> <equals operator> <assigned row> 
multiple_column_assignment = set_target_list equals_operator assigned_row;

// <set target list> ::= <left paren> <set target> [ { <comma> <set target> }... ] <right paren>
addl_set_target = comma set_target;
set_target_list = left_paren set_target addl_set_target? right_paren;

// <assigned row> ::= <contextually typed row value expression>
assigned_row = contextually_typed_row_value_expression;

// <update target> ::= <object column> | <object column> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
update_target = {unbracketed} object_column | {bracketed} object_column left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph;

// <object column> ::= <column name>
object_column = column_name;

// <mutated set clause> ::= <mutated target> <period> <method name>
mutated_set_clause = mutated_target period method_name;

// <mutated target> ::= <object column> | <mutated set clause>
mutated_target = {object} object_column | {mutated} mutated_set_clause;

// <update source> ::= <value expression> | <contextually typed value specification>
update_source = {exp} value_expression | {spec} contextually_typed_value_specification;

// <temporary table declaration> ::= DECLARE LOCAL TEMPORARY TABLE <table name> <table element list> [ ON COMMIT <table commit action> ROWS ]
on_commit = t_on t_commit table_commit_action t_rows;
temporary_table_declaration = t_declare t_local t_temporary t_table table_name table_element_list on_commit?;

// <direct select statement: multiple rows> ::= <cursor specification>
direct_select_statement_multiple = cursor_specification;

// <search condition> ::= <boolean value expression>
search_condition = boolean_value_expression;

// <boolean value expression> ::= <boolean term> | <boolean value expression> OR <boolean term>
boolean_value_expression = {term} boolean_term | {exp_or_term} boolean_value_expression t_or boolean_term;

// <boolean term> ::= <boolean factor> | <boolean term> AND <boolean factor>
boolean_term = {factor} boolean_factor | {term_and_factor} boolean_term t_and boolean_factor;

// <boolean factor> ::= [ NOT ] <boolean test>
boolean_factor = t_not? boolean_test;

// <boolean test> ::= <boolean primary> [ IS [ NOT ] <truth value> ]
is_not_truth = t_is t_not? truth_value;
boolean_test = boolean_primary is_not_truth?;

// <truth value> ::= TRUE | FALSE | UNKNOWN
truth_value = {true} t_true | {false} t_false | {unknown} t_unknown;

// <boolean primary> ::= <predicate> | <boolean predicand>
//LALR boolean_primary = {predicate} predicate | {predicand} boolean_predicand;
boolean_primary = {predicate} predicate | {paren} left_paren boolean_value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <boolean predicand> ::= <parenthesized boolean value expression> | <nonparenthesized value expression primary>
//LALR boolean_predicand = {paren} parenthesized_boolean_value_expression | {nonparen} nonparenthesized_value_expression_primary;
// boolean_predicand = {paren} left_paren boolean_value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <parenthesized boolean value expression> ::= <left paren> <boolean value expression> <right paren>
parenthesized_boolean_value_expression = left_paren boolean_value_expression right_paren;

// <target table> ::= <table name> | ONLY <left paren> <table name> <right paren>
target_table = {table} table_name | {only} t_only left_paren table_name right_paren;

// <datetime value expression> ::= <datetime term> | <interval value expression> <plus sign> <datetime term>
//   | <datetime value expression> <plus sign> <interval term> | <datetime value expression> <minus sign> <interval term>
datetime_value_expression = {term} datetime_term | {interval} interval_value_expression plus_sign datetime_term | {value_plus} datetime_value_expression plus_sign interval_term | {value_minus} datetime_value_expression minus_sign interval_term;

// <datetime term> ::= <datetime factor>
datetime_term = datetime_factor;

// <datetime factor> ::= <datetime primary> [ <time zone> ]
//LALR datetime_factor = datetime_primary time_zone?;
datetime_factor = {paren} left_paren value_expression right_paren time_zone? | {nonparen} nonparenthesized_value_expression_primary time_zone? | {function} datetime_value_function time_zone?;

// <datetime primary> ::= <value expression primary> | <datetime value function>
datetime_primary = {expression} value_expression_primary | {function} datetime_value_function;

// <time zone> ::= AT <time zone specifier>
time_zone = t_at time_zone_specifier;

// <time zone specifier> ::= LOCAL | TIME ZONE <interval primary>
time_zone_specifier = {local} t_local | {time_zone} t_time t_zone interval_primary;

// <cursor specification> ::= <query expression> [ <updatability clause> ]
cursor_specification = query_expression updatability_clause?;

// <updatability clause> ::= FOR { READ ONLY | UPDATE [ OF <column name list> ] }
of_column_name_list = t_of column_name_list;
read_only_or_update = {read_only} t_read t_only | {update} t_update of_column_name_list?;
updatability_clause = t_for read_only_or_update;

// <query expression> ::= [ <with clause> ] <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ]
query_expression = with_clause? query_expression_body order_by_clause? result_offset_clause? fetch_first_clause?;

// <with clause> ::= WITH [ RECURSIVE ] <with list>
with_clause = t_with t_recursive? with_list;

// <with list> ::= <with list element> [ { <comma> <with list element> }... ]
addl_with = comma with_list_element;
with_list = with_list_element addl_with*;

// <with list element> ::= <query name> [ <left paren> <with column list> <right paren> ] AS <table subquery> [ <search or cycle clause> ]
paren_with_column_list = left_paren with_column_list right_paren;
with_list_element = query_name paren_with_column_list? t_as table_subquery search_or_cycle_clause?;

// <with column list> ::= <column name list>
with_column_list = column_name_list;

all_or_distinct = {all} t_all | {distinct} t_distinct;

// <query expression body> ::= <query term> | <query expression body> UNION [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
//   | <query expression body> EXCEPT [ ALL | DISTINCT ] [ <corresponding spec> ] <query term>
query_expression_body = {term} query_term |  {union} query_expression_body t_union all_or_distinct? corresponding_spec? query_term
   |  {except} query_expression_body t_except all_or_distinct? corresponding_spec? query_term;

// <query term> ::= <query primary> | <query term> INTERSECT [ ALL | DISTINCT ] [ <corresponding spec> ] <query primary>
query_term = {primary} query_primary | {intersect} query_term t_intersect all_or_distinct? corresponding_spec? query_primary;

// <query primary> ::= <simple table> | <left paren> <query expression body> [ <order by clause> ] [ <result offset clause> ] [ <fetch first clause> ] <right paren>
query_primary = {simple} simple_table |  {not_simple} left_paren query_expression_body order_by_clause? result_offset_clause? fetch_first_clause? right_paren;

// <simple table> ::= <query specification> | <table value constructor> | <explicit table>
simple_table = {query} query_specification | {table} table_value_constructor | {explicit} explicit_table;

// <explicit table> ::= TABLE <table or query name>
explicit_table = t_table table_or_query_name;

// <corresponding spec> ::= CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]
by_column_list = t_by left_paren corresponding_column_list right_paren;
corresponding_spec = t_corresponding by_column_list?;

// <corresponding column list> ::= <column name list>
corresponding_column_list = column_name_list;

// <order by clause> ::= ORDER BY <sort specification list>
order_by_clause = t_order t_by sort_specification_list;

row_or_rows = {row} t_row | {rows} t_rows;
first_or_next = {first} t_first | {next} t_next;
only_or_with_ties = {only} t_only | {ties} t_with t_ties;

// <result offset clause> ::= OFFSET <offset row count> { ROW | ROWS }
result_offset_clause = t_offset offset_row_count row_or_rows;

// <fetch first clause> ::= FETCH { FIRST | NEXT } [ <fetch first quantity> ] { ROW | ROWS } { ONLY | WITH TIES }
fetch_first_clause = t_fetch first_or_next fetch_first_quantity? row_or_rows only_or_with_ties;

// <fetch first quantity> ::= <fetch first row count> | <fetch first percentage>
fetch_first_quantity = {count} fetch_first_row_count | {percent} fetch_first_percentage;

// <offset row count> ::= <simple value specification>
offset_row_count = simple_value_specification;

// <fetch first row count> ::= <simple value specification>
fetch_first_row_count = simple_value_specification;

// <fetch first percentage> ::= <simple value specification> PERCENT
fetch_first_percentage = simple_value_specification percent;

// <table reference> ::= <table factor> | <joined table>
table_reference = {factor} table_factor | {joined} joined_table;

// <table factor> ::= <table primary> [ <sample clause> ]
table_factor = table_primary sample_clause?;

// <sample clause> ::= TABLESAMPLE <sample method> <left paren> <sample percentage> <right paren> [ <repeatable clause> ]
sample_clause = t_tablesample sample_method left_paren sample_percentage right_paren repeatable_clause?;

// <sample method> ::= BERNOULLI | SYSTEM
sample_method = {bernoulli} t_bernoulli | {system} t_system;

// <repeatable clause> ::= REPEATABLE <left paren> <repeat argument> <right paren>
repeatable_clause = t_repeatable left_paren repeat_argument right_paren;

// <sample percentage> ::= <numeric value expression>
sample_percentage = numeric_value_expression;

// <repeat argument> ::= <numeric value expression>
repeat_argument = numeric_value_expression;

// <table primary> ::= <table or query name> [ <query system time period specification> ] [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
//   | <derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <lateral derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <collection derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <table function derived table> [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]
//   | <only spec> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
//   | <data change delta table> [ [ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ] ]
//   | <parenthesized joined table>
paren_derived_column_list = left_paren derived_column_list right_paren;
as_paren_derived_column_list = t_as? correlation_name paren_derived_column_list?;
table_primary = {table_or_query} table_or_query_name query_system_time_period_specification as_paren_derived_column_list?
   | {derived} derived_table as_paren_derived_column_list
   | {lateral} lateral_derived_table as_paren_derived_column_list
   | {collection} collection_derived_table as_paren_derived_column_list
   | {function} table_function_derived_table as_paren_derived_column_list
   | {only_spec} only_spec as_paren_derived_column_list?
   | {data_change} data_change_delta_table as_paren_derived_column_list?
   | {join} parenthesized_joined_table;


// <query system time period specification> ::= FOR SYSTEM_TIME AS OF <point in time 1>
//   | FOR SYSTEM_TIME BETWEEN [ ASYMMETRIC | SYMMETRIC ] <point in time 1> AND <point in time 2>
//   | FOR SYSTEM_TIME FROM <point in time 1> TO <point in time 2>
asymmetric_or_symmetric = {asym} t_asymmetric | {sym} t_symmetric;
query_system_time_period_specification = {since} t_for t_system_time t_as t_of point_in_time1
   | {between} t_for t_system t_time t_between asymmetric_or_symmetric point_in_time1 t_and point_in_time2
   | {from} t_for t_system t_time t_from point_in_time1 t_to  point_in_time2;

// <point in time 1> ::= <point in time>
point_in_time1 = point_in_time;

// <point in time 2> ::= <point in time>
point_in_time2 = point_in_time;

// <point in time> ::= <datetime value expression>
point_in_time = datetime_value_expression;

// <only spec> ::= ONLY <left paren> <table or query name> <right paren>
only_spec = t_only left_paren table_or_query_name right_paren;

// <lateral derived table> ::= LATERAL <table subquery>
lateral_derived_table = t_lateral table_subquery;

// <collection derived table> ::= UNNEST <left paren> <collection value expression> [ { <comma> <collection value expression> }... ] <right paren> [ WITH ORDINALITY ]
with_ordinality = t_with t_ordinality;
addl_collection_value_expression = comma collection_value_expression;
collection_derived_table = t_unnest left_paren collection_value_expression addl_collection_value_expression* right_paren with_ordinality?;

// <table function derived table> ::= TABLE <left paren> <collection value expression> <right paren>
table_function_derived_table = t_table left_paren collection_value_expression right_paren;

// <derived table> ::= <table subquery>
derived_table = table_subquery;

// <table or query name> ::= <table name> | <transition table name> | <query name>
table_or_query_name = {table} table_name | {transition} transition_table_name | query_name;

// <derived column list> ::= <column name list>
derived_column_list = column_name_list;

// <column name list> ::= <column name> [ { <comma> <column name> }... ]
addl_column_name = comma column_name;
column_name_list = column_name addl_column_name*;

// <data change delta table> ::= <result option> TABLE <left paren> <data change statement> <right paren>
data_change_delta_table = result_option t_table left_paren data_change_statement right_paren;

// <data change statement> ::= <delete statement: searched> | <insert statement> | <merge statement> | <update statement: searched>
data_change_statement = {delete} delete_statement_searched | {insert} insert_statement | {merge} merge_statement | {update} update_statement_searched;

// <result option> ::= FINAL | NEW | OLD
result_option = {final} t_final | {new} t_new | {old} t_old;

// <parenthesized joined table> ::= <left paren> <parenthesized joined table> <right paren> | <left paren> <joined table> <right paren>
parenthesized_joined_table = {paren} left_paren parenthesized_joined_table right_paren | {joined} left_paren joined_table right_paren;

// <value expression> ::= <common value expression> | <boolean value expression> | <row value expression>
value_expression = {common} common_value_expression | {boolean} boolean_value_expression | {row} row_value_expression;

// <common value expression> ::= <numeric value expression> | <string value expression> | <datetime value expression>
//   | <interval value expression> | <user-defined type value expression> | <reference value expression> | <collection value expression>
common_value_expression = {numeric} numeric_value_expression | {string} string_value_expression | {datetime} datetime_value_expression
    | {interval} interval_value_expression | {user} user_defined_type_value_expression | {reference} reference_value_expression | {collection} collection_value_expression;

// <user-defined type value expression> ::= <value expression primary>
//LALR user_defined_type_value_expression = value_expression_primary;
user_defined_type_value_expression = {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <reference value expression> ::= <value expression primary>
//LALR reference_value_expression = value_expression_primary;
reference_value_expression = {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <collection value expression> ::= <array value expression> | <multiset value expression>
collection_value_expression = {array} array_value_expression | {multiset} multiset_value_expression;

// <contextually typed value specification> ::= <implicitly typed value specification> | <default specification>
contextually_typed_value_specification = {implicit} implicitly_typed_value_specification | {default} default_specification;

// <implicitly typed value specification> ::= <null specification> | <empty specification>
implicitly_typed_value_specification = {null} null_specification | {empty} empty_specification;

// <null specification> ::= NULL
null_specification = t_null;

// <empty specification> ::= ARRAY <left bracket or trigraph> <right bracket or trigraph> | MULTISET <left bracket or trigraph> <right bracket or trigraph>
empty_specification = {array} t_array left_bracket_or_trigraph right_bracket_or_trigraph | {multiset} t_multiset left_bracket_or_trigraph right_bracket_or_trigraph;

// <default specification> ::= DEFAULT
default_specification = t_default;

// <row value expression> ::= <row value special case> | <explicit row value constructor>
row_value_expression = {special} row_value_special_case | {explicit} explicit_row_value_constructor;

// <table row value expression> ::= <row value special case> | <row value constructor>
table_row_value_expression = {special} row_value_special_case | {constructor} row_value_constructor;

// <contextually typed row value expression> ::= <row value special case> | <contextually typed row value constructor>
contextually_typed_row_value_expression = {row} row_value_special_case | {context} contextually_typed_row_value_constructor;

// <row value predicand> ::= <row value special case> | <row value constructor predicand>
row_value_predicand = {row_value_special_case} row_value_special_case | {row_value_constructor_predicand} row_value_constructor_predicand;

// <row value special case> ::= <nonparenthesized value expression primary>
row_value_special_case = nonparenthesized_value_expression_primary;

// <value specification> ::= <literal> | <general value specification>
// <unsigned value specification> ::= <unsigned literal> | <general value specification>
unsigned_value_specification = {literal} unsigned_literal | {general} general_value_specification;

// <general value specification> ::= <host parameter specification> | <SQL parameter reference> | <dynamic parameter specification>
//   | <embedded variable specification> | <current collation specification> | CURRENT_CATALOG | CURRENT_DEFAULT_TRANSFORM_GROUP | CURRENT_PATH
//   | CURRENT_ROLE | CURRENT_SCHEMA | CURRENT_TRANSFORM_GROUP_FOR_TYPE <path-resolved user-defined type name> | CURRENT_USER | SESSION_USER | SYSTEM_USER | USER | VALUE
general_value_specification = {host_parameter_specification} host_parameter_specification | {sql_parameter_reference} sql_parameter_reference | {dynamic_parameter_specification} dynamic_parameter_specification
   | {embedded_variable_specification} embedded_variable_specification | {current_collation_specification} current_collation_specification | {current_catalog} t_current_catalog | {current_default_transform_group} t_current_default_transform_group | {current_path} t_current_path
   | {current_role} t_current_role | {current_schema} t_current_schema | {current_transform_group_for_type} t_current_transform_group_for_type path_resolved_user_defined_type_name | {current_user} t_current_user | {session_user} t_session_user | {system_user} t_system_user | {user} t_user | {value} t_value;

// <simple value specification> ::= <literal> | <host parameter name> | <SQL parameter reference> | <embedded variable name>
simple_value_specification = {literal} literal | {host} host_parameter_name | {sql} sql_parameter_reference | {embedded} embedded_variable_name; 

// <target specification> ::= <host parameter specification> | <SQL parameter reference> | <column reference> | <target array element specification>
//   | <dynamic parameter specification> | <embedded variable specification>
target_specification = {host} host_parameter_specification | {sql} sql_parameter_reference | {column} column_reference  | {target} target_array_element_specification
   | {dynamic} dynamic_parameter_specification | {embedded}  embedded_variable_specification;
// <simple target specification> ::= <host parameter name> | <SQL parameter reference> | <column reference> | <embedded variable name>
simple_target_specification = {host} host_parameter_name | {sql} sql_parameter_reference | {column} column_reference | {embedded} embedded_variable_name;

// <host parameter specification> ::= <host parameter name> [ <indicator parameter> ]
host_parameter_specification = host_parameter_name indicator_parameter?;

// <dynamic parameter specification> ::= <question mark>
dynamic_parameter_specification = question_mark;

// <embedded variable specification> ::= <embedded variable name> [ <indicator variable> ]
embedded_variable_specification = embedded_variable_name indicator_variable?;

// <indicator variable> ::= [ INDICATOR ] <embedded variable name>
indicator_variable = t_indicator? embedded_variable_name;

// <indicator parameter> ::= [ INDICATOR ] <host parameter name>
indicator_parameter = t_indicator? host_parameter_name;

// <target array element specification> ::= <target array reference> <left bracket or trigraph> <simple value specification> <right bracket or trigraph>
target_array_element_specification = target_array_reference left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph;
// <target array reference> ::= <SQL parameter reference> | <column reference>
target_array_reference = {sql} sql_parameter_reference | {column} column_reference;
// <current collation specification> ::= COLLATION FOR <left paren> <string value expression> <right paren>
 current_collation_specification = t_collation t_for left_paren string_value_expression right_paren;

// <identifier> ::= <actual identifier>
identifier = actual_identifier;

// <actual identifier> ::= <regular identifier> | <delimited identifier> | <Unicode delimited identifier>
actual_identifier = {regular_identifier} regular_identifier | {delimited_identifier} delimited_identifier | {unicode_delimited_identifier} unicode_delimited_identifier;

// <SQL language identifier> ::= <SQL language identifier start> [ <SQL language identifier part>... ]
sql_language_identifier = sql_language_identifier_start sql_language_identifier_part*;

// <SQL language identifier start> ::= <simple Latin letter>
sql_language_identifier_start = simple_latin_letter;

// <SQL language identifier part> ::= <simple Latin letter> | <digit> | <underscore>
sql_language_identifier_part = {letter} simple_latin_letter | {digit} digit | {underscore} underscore;

// <authorization identifier> ::= <role name> | <user identifier>
authorization_identifier = {role_name} role_name | {user_identifier} user_identifier;

// <table name> ::= <local or schema qualified name>
table_name = local_or_schema_qualified_name;

// <domain name> ::= <schema qualified name>
domain_name = schema_qualified_name;

// <schema name> ::= [ <catalog name> <period> ] <unqualified schema name>
catalog_prefix = catalog_name period;
schema_name = catalog_prefix? unqualified_schema_name;

// <unqualified schema name> ::= <identifier>
//LALR unqualified_schema_name = identifier;
unqualified_schema_name = {regular_identifier} regular_identifier | {delimited_identifier} delimited_identifier | {unicode_delimited_identifier} unicode_delimited_identifier;

// <catalog name> ::= <identifier>
//LALR catalog_name = identifier;
catalog_name = {regular_identifier} regular_identifier | {delimited_identifier} delimited_identifier | {unicode_delimited_identifier} unicode_delimited_identifier;

// <schema qualified name> ::= [ <schema name> <period> ] <qualified identifier>
schema_name_prefix = schema_name period;
schema_qualified_name = schema_name_prefix? qualified_identifier;

// <local or schema qualified name> ::= [ <local or schema qualifier> <period> ] <qualified identifier>
local_or_schema_qualifier_prefix = local_or_schema_qualifier period;
local_or_schema_qualified_name = local_or_schema_qualifier_prefix? qualified_identifier;

// <local or schema qualifier> ::= <schema name> | <local qualifier>
local_or_schema_qualifier = {schema_name} schema_name | {local_qualifier} local_qualifier;

// <qualified identifier> ::= <identifier>
qualified_identifier = identifier;

// <column name> ::= <identifier>
column_name = identifier;

// <correlation name> ::= <identifier>
correlation_name = identifier;

// <query name> ::= <identifier>
query_name = identifier;

// SQL-client module name> ::= <identifier>
sql_client_module_name = identifier;

// <procedure name> ::= <identifier>
procedure_name = identifier;

// <schema qualified routine name> ::= <schema qualified name>
schema_qualified_routine_name = schema_qualified_name;

// <method name> ::= <identifier>
method_name = identifier;

// <specific name> ::= <schema qualified name>
specific_name = schema_qualified_name;

// <cursor name> ::= <local qualified name>
cursor_name = local_qualified_name;

// <local qualified name> ::= [ <local qualifier> <period> ] <qualified identifier>
local_qualifier_prefix = local_qualifier period;
local_qualified_name = local_qualifier_prefix? qualified_identifier;

// <local qualifier> ::= MODULE
local_qualifier = t_module;

// <host parameter name> ::= <colon> <identifier>
host_parameter_name = colon identifier;

// <SQL parameter name> ::= <identifier>
sql_parameter_name = identifier;

// <constraint name> ::= <schema qualified name>
constraint_name = schema_qualified_name;

// <external routine name> ::= <identifier> | <character string literal> 
external_routine_name = {identifier} identifier | {character_string_literal} character_string_literal;

// <trigger name> ::= <schema qualified name>
trigger_name = schema_qualified_name;

// <collation name> ::= <schema qualified name>
collation_name = schema_qualified_name;

// <character set name> ::=[ <schema name> <period> ] <SQL language identifier>
character_set_name = schema_name_prefix? sql_language_identifier;

// <transliteration name> ::= <schema qualified name>
transliteration_name = schema_qualified_name;

// <transcoding name> ::= <schema qualified name>
transcoding_name = schema_qualified_name;

// <schema-resolved user-defined type name> ::= <user-defined type name>
schema_resolved_user_defined_type_name = user_defined_type_name;

// <user-defined type name> ::= [ <schema name> <period> ] <qualified identifier>
user_defined_type_name = schema_name_prefix? qualified_identifier;

// <attribute name> ::= <identifier>
attribute_name = identifier;

// <field name> ::= <identifier>
field_name = identifier;

// <savepoint name> ::= <identifier>
savepoint_name = identifier;

// <sequence generator name> ::= <schema qualified name>
sequence_generator_name = schema_qualified_name;

// <role name> ::= <identifier>
role_name = identifier;

// <user identifier> ::= <identifier>
user_identifier = identifier;

// <connection name> ::= <simple value specification>
connection_name = simple_value_specification;

// <SQL-server name> ::= <simple value specification>
sql_server_name = simple_value_specification;

// <connection user name> ::= <simple value specification>
connection_user_name = simple_value_specification;

// <SQL statement name> ::= <statement name> | <extended statement name>
sql_statement_name = {statement_name} statement_name | {extended_statement_name} extended_statement_name;

// <statement name> ::= <identifier>
statement_name = identifier;

// <extended statement name> ::= [ <scope option> ] <simple value specification>
extended_statement_name = scope_option? simple_value_specification;

// <dynamic cursor name> ::= <cursor name> | <extended cursor name>
dynamic_cursor_name = {cursor_name} cursor_name | {extended_cursor_name} extended_cursor_name;

// <extended cursor name> ::= [ <scope option> ] <simple value specification>
extended_cursor_name = scope_option? simple_value_specification;

// <descriptor name> ::= <non-extended descriptor name> | <extended descriptor name>
descriptor_name = {non_extended_descriptor_name} non_extended_descriptor_name | {extended_descriptor_name} extended_descriptor_name;

// <non-extended descriptor name> ::= <identifier>
non_extended_descriptor_name = identifier;

// <extended descriptor name> ::= [ <scope option> ] <simple value specification>
extended_descriptor_name = scope_option? simple_value_specification;

// <scope option> ::= GLOBAL | LOCAL
scope_option = {global} t_global | {local} t_local;

// <window name> ::= <identifier>
window_name = identifier;

// <table definition> ::= CREATE [ <table scope> ] TABLE <table name> <table contents source> [ WITH <system versioning clause> ] [ ON COMMIT <table commit action> ROWS ]
// <table contents source> ::= <table element list> | <typed table clause> | <as subquery clause>
// <table scope> ::= <global or local> TEMPORARY
// <global or local> ::= GLOBAL | LOCAL
// <system versioning clause> ::= SYSTEM VERSIONING
// <table commit action> ::= PRESERVE | DELETE
table_commit_action = {preserve} t_preserve | {delete} t_delete;

// <table element list> ::= <left paren> <table element> [ { <comma> <table element> }... ] <right paren>
addl_table_element = comma table_element;
table_element_list = left_paren table_element addl_table_element* right_paren;

// <table element> ::= <column definition> | <table period definition> | <table constraint definition> | <like clause>
table_element = {column} column_definition | {period} table_period_definition | {constraint} table_constraint_definition | {like} like_clause;

// <typed table clause> ::= OF <path-resolved user-defined type name> [ <subtable clause> ] [ <typed table element list> ]
// <typed table element list> ::= <left paren> <typed table element> [ { <comma> <typed table element> }... ] <right paren>
// <typed table element> ::= <column options> | <table constraint definition> | <self-referencing column specification>
typed_table_element = {column} column_options | {table} table_constraint_definition | {self} self_referencing_column_specification;

// <self-referencing column specification> ::= REF IS <self-referencing column name> [ <reference generation> ]
self_referencing_column_specification = t_ref t_is self_referencing_column_name reference_generation?;

// <reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED
reference_generation = {system} t_system t_generated | {user} t_user t_generated | {derived} t_derived;

// <self-referencing column name> ::= <column name>
self_referencing_column_name = column_name;

// <column options> ::= <column name> WITH OPTIONS <column option list>
column_options = column_name t_with t_options column_option_list;

// <column option list> ::= [ <scope clause> ] [ <default clause> ] [ <column constraint definition>... ]
column_option_list = scope_clause? default_clause? column_constraint_definition*;

// <subtable clause> ::= UNDER <supertable clause>
// <supertable clause> ::= <supertable name>
// <supertable name> ::= <table name>
// <like clause> ::= LIKE <table name> [ <like options> ]
like_clause = t_like table_name like_options?;

// <like options> ::= <like option>...
like_options = like_option+;

// <like option> ::= <identity option> | <column default option> | <generation option>
like_option = {identity} identity_option | {column} column_default_option | {generated} generation_option;

// <identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY
identity_option = {including} t_including t_identity | {excluding} t_excluding t_identity;

// <column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS
column_default_option = {including} t_including t_defaults | {excluding} t_excluding t_defaults;

// <generation option> ::= INCLUDING GENERATED | EXCLUDING GENERATED
generation_option = {including} t_including t_generated | {excluding} t_excluding t_generated;

// <as subquery clause> ::= [ <left paren> <column name list> <right paren> ] AS <table subquery> <with or without data>
// <with or without data> ::= WITH NO DATA | WITH DATA
// <table period definition> ::= <system or application time period specification> <left paren> <period begin column name> <comma> <period end column name> <right paren>
// <system or application time period specification> ::= <system time period specification> | <application time period specification>
system_or_application_time_period_specification = {system} system_time_period_specification | {application} application_time_period_specification;
// <system time period specification> ::= PERIOD FOR SYSTEM_TIME
system_time_period_specification = t_period t_for t_system_time;
// <application time period specification> ::= PERIOD FOR <application time period name>
application_time_period_specification = t_period t_for application_time_period_name;
// <application time period name> ::= <identifier>
application_time_period_name = identifier;
// <period begin column name> ::= <column name>
// <period end column name> ::= <column name>

// <value expression primary> ::= <parenthesized value expression> | <nonparenthesized value expression primary>
//LALR value_expression_primary = {paren} parenthesized_value_expression | {nonparen} nonparenthesized_value_expression_primary;
value_expression_primary = {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <parenthesized value expression> ::= <left paren> <value expression> <right paren>
parenthesized_value_expression = left_paren value_expression right_paren;

// <nonparenthesized value expression primary> ::= <unsigned value specification> | <column reference> | <set function specification>
//    | <window function> | <nested window function> | <scalar subquery> | <case expression> | <cast specification> | <field reference>
//    | <subtype treatment> | <method invocation> | <static method invocation> | <new specification> | <attribute or method reference>
//    | <reference resolution> | <collection value constructor> | <array element reference> | <multiset element reference>
//    | <next value expression> | <routine invocation>
nonparenthesized_value_expression_primary = {unsigned} unsigned_value_specification | {column} column_reference | {set} set_function_specification
  | {window} window_function | {nested} nested_window_function | {scalar} scalar_subquery | {case} case_expression | {cast} cast_specification | {field} field_reference
  | {subtype} subtype_treatment | {method} method_invocation | {static} static_method_invocation | {new} new_specification | {attribute} attribute_or_method_reference
  | {reference} reference_resolution | {collection} collection_value_constructor | {array} array_element_reference | {multiset} multiset_element_reference
  | {next} next_value_expression | {routine} routine_invocation;
// <collection value constructor> ::= <array value constructor> | <multiset value constructor>
collection_value_constructor = {array} array_value_constructor | {multiset} multiset_value_constructor;

// <interval value expression> ::= <interval term> | <interval value expression 1> <plus sign> <interval term 1>
//   | <interval value expression 1> <minus sign> <interval term 1>
//   | <left paren> <datetime value expression> <minus sign> <datetime term> <right paren> <interval qualifier>
interval_value_expression = {term} interval_term | {plus} interval_value_expression1 plus_sign interval_term1
   | {minus} interval_value_expression1 minus_sign interval_term1
   | {paren} left_paren datetime_value_expression minus_sign datetime_term right_paren interval_qualifier;

// <interval term> ::= <interval factor> | <interval term 2> <asterisk> <factor> | <interval term 2> <solidus> <factor> | <term> <asterisk> <interval factor>
interval_term = {factor} interval_factor | {asterisk} interval_term2 asterisk factor | {solidus} interval_term2 solidus factor | {term} term asterisk interval_factor ;

// <interval factor> ::= [ <sign> ] <interval primary>
interval_factor = sign? interval_primary;

// <interval primary> ::= <value expression primary> [ <interval qualifier> ] | <interval value function>
//LALR interval_primary = {expression} value_expression_primary interval_qualifier? | {function} interval_value_function;
interval_primary = {paren} left_paren value_expression right_paren interval_qualifier? | {nonparen} nonparenthesized_value_expression_primary interval_qualifier? | {function} interval_value_function;

// <interval value expression 1> ::= <interval value expression>
interval_value_expression1 = interval_value_expression;

// <interval term 1> ::= <interval term>
interval_term1 = interval_term;

// <interval term 2> ::= <interval term>
interval_term2 = interval_term;

// <datetime value function> ::= <current date value function> | <current time value function> | <current timestamp value function> | <current local time value function> | <current local timestamp value function>
datetime_value_function = {date} current_date_value_function | {time} current_time_value_function | {timestamp} current_timestamp_value_function
   | {local_time} current_local_time_value_function | {local_timestamp} current_local_timestamp_value_function;

// <current date value function> ::= CURRENT_DATE
current_date_value_function = t_current_date;

// <current time value function> ::= CURRENT_TIME [ <left paren> <time precision> <right paren> ]
paren_time_precision = left_paren time_precision right_paren;
current_time_value_function = t_current_time paren_time_precision?;

// <current local time value function> ::= LOCALTIME [ <left paren> <time precision> <right paren> ]
current_local_time_value_function = t_localtime paren_time_precision?;

// <current timestamp value function> ::= CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
paren_timestamp_precision = left_paren timestamp_precision right_paren;
current_timestamp_value_function = t_current_timestamp paren_timestamp_precision?;

// <current local timestamp value function> ::= LOCALTIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
current_local_timestamp_value_function = t_localtimestamp paren_timestamp_precision?;

// <scalar subquery> ::= <subquery>
scalar_subquery = subquery;

// <row subquery> ::= <subquery>
row_subquery = subquery;

// <table subquery> ::= <subquery>
table_subquery = subquery;

// <subquery> ::= <left paren> <query expression> <right paren>
subquery = left_paren query_expression right_paren;

// <search or cycle clause> ::= <search clause> | <cycle clause> | <search clause> <cycle clause>
search_or_cycle_clause = {search} search_clause | {cycle} cycle_clause | {both} search_clause cycle_clause;
 
// <search clause> ::= SEARCH <recursive search order> SET <sequence column>
search_clause = t_search recursive_search_order t_set sequence_column;

// <recursive search order> ::= DEPTH FIRST BY <column name list> | BREADTH FIRST BY <column name list>
recursive_search_order = {depth_first} t_depth t_first t_by column_name_list | {breadth_first} t_breadth t_first t_by column_name_list;

// <sequence column> ::= <column name>
sequence_column = column_name;

// <cycle clause> ::= CYCLE <cycle column list> SET <cycle mark column> TO <cycle mark value> DEFAULT <non-cycle mark value> USING <path column>
cycle_clause = t_cycle cycle_column_list t_set cycle_mark_column t_to cycle_mark_value t_default non_cycle_mark_value t_using path_column;

// <cycle column list> ::= <cycle column> [ { <comma> <cycle column> }... ]
addl_cycle_column = comma cycle_column;
cycle_column_list = cycle_column addl_cycle_column*;

// <cycle column> ::= <column name>
cycle_column = column_name;

// <cycle mark column> ::= <column name>
cycle_mark_column = column_name;

// <path column> ::= <column name>
path_column = column_name;

// <cycle mark value> ::= <value expression>
cycle_mark_value = value_expression;

// <non-cycle mark value> ::= <value expression>
non_cycle_mark_value = value_expression;

// <query specification> ::= SELECT [ <set quantifier> ] <select list> <table expression>
query_specification = t_select set_quantifier? select_list table_expression;

// <select list> ::= <asterisk> | <select sublist> [ { <comma> <select sublist> }... ]
addl_sublist = comma select_sublist;
select_list = {asterisk} asterisk | {sublist} select_sublist addl_sublist*;

// <select sublist> ::= <derived column> | <qualified asterisk>
select_sublist = {derived} derived_column | {qualified} qualified_asterisk;

// <qualified asterisk> ::= <asterisked identifier chain> <period> <asterisk> | <all fields reference>
qualified_asterisk = {asterisk} asterisked_identifier_chain period asterisk | {all} all_fields_reference;

// <asterisked identifier chain> ::= <asterisked identifier> [ { <period> <asterisked identifier> }... ]
asterisked_identifier_chain = asterisked_identifier addl_asterisked_identifier*;
addl_asterisked_identifier = period addl_asterisked_identifier;
 
// <asterisked identifier> ::= <identifier>
//LALR asterisked_identifier = identifier;
asterisked_identifier = {regular_identifier} regular_identifier | {delimited_identifier} delimited_identifier | {unicode_delimited_identifier} unicode_delimited_identifier;

// <derived column> ::= <value expression> [ <as clause> ]
derived_column = value_expression as_clause?;

// <as clause> ::= [ AS ] <column name>
as_clause = t_as? column_name;

// <all fields reference> ::= <value expression primary> <period> <asterisk> [ AS <left paren> <all fields column name list> <right paren> ]
all_fields_reference = value_expression_primary period asterisk as_all_fields_list?;
as_all_fields_list = t_as left_paren all_fields_column_name_list right_paren;

// <all fields column name list> ::= <column name list>
all_fields_column_name_list = column_name_list;

// <table value constructor> ::= VALUES <row value expression list>
table_value_constructor = t_values row_value_expression_list;

// <row value expression list> ::= <table row value expression> [ { <comma> <table row value expression> }... ]
row_value_expression_list = table_row_value_expression addl_table_row_value_expression*;
addl_table_row_value_expression = comma table_row_value_expression;

// <contextually typed table value constructor> ::= VALUES <contextually typed row value expression list>
contextually_typed_table_value_constructor = t_values contextually_typed_row_value_expression_list;

// <contextually typed row value expression list> ::= <contextually typed row value expression> [ { <comma> <contextually typed row value expression> }... ]
addl_contextually_typed_row_value_expression = comma contextually_typed_row_value_expression;
contextually_typed_row_value_expression_list = contextually_typed_row_value_expression addl_contextually_typed_row_value_expression*;

// <sort specification list> ::= <sort specification> [ { <comma> <sort specification> }... ]
addl_sort_specification = comma sort_specification;
sort_specification_list = sort_specification addl_sort_specification*;

// <sort specification> ::= <sort key> [ <ordering specification> ] [ <null ordering> ]
sort_specification = sort_key ordering_specification? null_ordering?;

// <sort key> ::= <value expression>
sort_key = value_expression;

// <ordering specification> ::= ASC | DESC
ordering_specification = {asc} t_asc | {desc} t_desc;

// <null ordering> ::= NULLS FIRST | NULLS LAST
null_ordering = {first} t_nulls t_first | {last} t_nulls t_last;

// <joined table> ::= <cross join> | <qualified join> | <natural join>
joined_table = {cross} cross_join | {qualified} qualified_join | {natural} natural_join;

// <cross join> ::= <table reference> CROSS JOIN <table factor>
cross_join = table_reference t_cross t_join table_factor;
// <qualified join> ::= { <table reference> | <partitioned join table> } [ <join type> ] JOIN { <table reference> | <partitioned join table> } <join specification>
qualified_join = [left]:table_reference_or_partitioned join_type? t_join [right]:table_reference_or_partitioned join_specification;
table_reference_or_partitioned = {reference} table_reference | {partitioned} partitioned_join_table;
// <partitioned join table> ::= <table factor> PARTITION BY <partitioned join column reference list>
partitioned_join_table = table_factor t_partition t_by partitioned_join_column_reference_list;
// <partitioned join column reference list> ::= <left paren> <partitioned join column reference> [ { <comma> <partitioned join column reference> }... ] <right paren>
partitioned_join_column_reference_list = left_paren partitioned_join_column_reference addl_partitioned_join_column_reference* right_paren;
addl_partitioned_join_column_reference = comma partitioned_join_column_reference;

// <partitioned join column reference> ::= <column reference>
partitioned_join_column_reference = column_reference;

// <natural join> ::= { <table reference> | <partitioned join table> } NATURAL [ <join type> ] JOIN { <table factor> | <partitioned join table> }
natural_join = [left]:table_reference_or_partitioned t_natural join_type? t_join [right]:table_reference_or_partitioned;

// <join specification> ::= <join condition> | <named columns join>
join_specification = {condition} join_condition | {named} named_columns_join; 
// <join condition> ::= ON <search condition>
join_condition = t_on search_condition;
// <named columns join> ::= USING <left paren> <join column list> <right paren>
named_columns_join = t_using left_paren join_column_list right_paren;
// <join type> ::= INNER | <outer join type> [ OUTER ]
join_type = {inner} t_inner | {outer} outer_join_type t_outer?;
// <outer join type> ::= LEFT | RIGHT | FULL
outer_join_type = {left} t_left | {right} t_right | {full} t_full;

// <join column list> ::= <column name list>
join_column_list = column_name_list;

// <numeric value expression> ::= <term> | <numeric value expression> <plus sign> <term> | <numeric value expression> <minus sign> <term>
numeric_value_expression = {term} term | {plus}  numeric_value_expression plus_sign term | {minus} numeric_value_expression minus_sign term;

// <term> ::= <factor> | <term> <asterisk> <factor> | <term> <solidus> <factor>
term = {factor} factor | {mult} term asterisk factor | {div} term solidus factor;
 
// <factor> ::= [ <sign> ] <numeric primary>
factor = sign? numeric_primary;

// <numeric primary> ::= <value expression primary> | <numeric value function>
//LALR numeric_primary = {expression} value_expression_primary | {function} numeric_value_function;
numeric_primary = {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary | {function} numeric_value_function;

// <trigger definition> ::= CREATE TRIGGER <trigger name> <trigger action time> <trigger event> ON <table name> [ REFERENCING <transition table or variable list> ] <triggered action>
// <trigger action time> ::= BEFORE | AFTER | INSTEAD OF
// <trigger event> ::= INSERT | DELETE | UPDATE [ OF <trigger column list> ]
// <trigger column list> ::= <column name list>
// <triggered action> ::= [ FOR EACH { ROW | STATEMENT } ] [ <triggered when clause> ] <triggered SQL statement>
// <triggered when clause> ::= WHEN <left paren> <search condition> <right paren>
// <triggered SQL statement> ::= <SQL procedure statement> | BEGIN ATOMIC { <SQL procedure statement> <semicolon> }... END
// <transition table or variable list> ::= <transition table or variable>...
// <transition table or variable> ::= OLD [ ROW ] [ AS ] <old transition variable name> | NEW [ ROW ] [ AS ] <new transition variable name> | OLD TABLE [ AS ] <old transition table name> | NEW TABLE [ AS ] <new transition table name>
// <old transition table name> ::= <transition table name>
// <new transition table name> ::= <transition table name>
// <transition table name> ::= <identifier>
transition_table_name = identifier;

// <old transition variable name> ::= <correlation name>
// <new transition variable name> ::= <correlation name>
new_transition_variable_name = correlation_name;

// <string value expression> ::= <character value expression> | <binary value expression>
string_value_expression = {character} character_value_expression | {binary} binary_value_expression;

// <character value expression> ::= <concatenation> | <character factor>
character_value_expression = {concat} concatenation | {factor} character_factor;

// <concatenation> ::= <character value expression> <concatenation operator> <character factor>
concatenation = character_value_expression concatenation_operator character_factor;

// <character factor> ::= <character primary> [ <collate clause> ]
character_factor = character_primary collate_clause?;

// <character primary> ::= <value expression primary> | <string value function>
//LALR character_primary = {expression} value_expression_primary | {function} string_value_function;
character_primary = {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary | {function} string_value_function;

// <binary value expression> ::= <binary concatenation> | <binary factor>
binary_value_expression = {concat} binary_concatenation | {factor} binary_factor; 
// <binary factor> ::= <binary primary>
binary_factor = binary_primary;

// <binary primary> ::= <value expression primary> | <string value function>
//LALR binary_primary = {expression} value_expression_primary | {function} string_value_function;
binary_primary = {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary | {function} string_value_function;

// <binary concatenation> ::= <binary value expression> <concatenation operator> <binary factor>
binary_concatenation = binary_value_expression concatenation_operator binary_factor;

// <array value expression> ::= <array concatenation> | <array primary>
array_value_expression = {concat} array_concatenation | {primary} array_primary;

// <array concatenation> ::= <array value expression 1> <concatenation operator> <array primary>
array_concatenation = array_value_expression1 concatenation_operator array_primary;

// <array value expression 1> ::= <array value expression>
array_value_expression1 = array_value_expression;

// <array primary> ::= <array value function> | <value expression primary>
//LALR array_primary = {function} array_value_function | {expression} value_expression_primary;
array_primary = {function} array_value_function | {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <multiset value expression> ::= <multiset term> | <multiset value expression> MULTISET UNION [ ALL | DISTINCT ] <multiset term> | <multiset value expression> MULTISET EXCEPT [ ALL | DISTINCT ] <multiset term>
multiset_value_expression = {term} multiset_term
    | {union} multiset_value_expression t_multiset t_union all_or_distinct? multiset_term
    | {except} multiset_value_expression t_multiset t_except all_or_distinct? multiset_term;

// <multiset term> ::= <multiset primary> | <multiset term> MULTISET INTERSECT [ ALL | DISTINCT ] <multiset primary>
//LALR multiset_term = {primary} multiset_primary | {intersect} multiset_term t_multiset t_intersect all_or_distinct? multiset_primary;
multiset_term = {function} multiset_value_function |  {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary
 | {function} multiset_term t_multiset t_intersect all_or_distinct? multiset_value_function |  {paren} multiset_term t_multiset t_intersect all_or_distinct? left_paren value_expression right_paren | {nonparen} multiset_term t_multiset t_intersect all_or_distinct? nonparenthesized_value_expression_primary;

// <multiset primary> ::= <multiset value function> | <value expression primary>
//LALR multiset_primary = {function} multiset_value_function |  {expression} value_expression_primary;
multiset_primary = {function} multiset_value_function |  {paren} left_paren value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// <row value constructor> ::= <common value expression> | <boolean value expression> | <explicit row value constructor>
row_value_constructor = {common} common_value_expression | {boolean} boolean_value_expression | {explicit} explicit_row_value_constructor;

// <explicit row value constructor> ::= <left paren> <row value constructor element> <comma> <row value constructor element list> <right paren>
//   | ROW <left paren> <row value constructor element list> <right paren> | <row subquery>
explicit_row_value_constructor = {list2} left_paren row_value_constructor_element comma row_value_constructor_element_list right_paren
    | {list1} t_row left_paren row_value_constructor_element_list right_paren
    | {subquery} row_subquery;

// <row value constructor element list> ::= <row value constructor element> [ { <comma> <row value constructor element> }... ]
row_value_constructor_element_list = row_value_constructor_element addl_row_value_constructor_element*;
addl_row_value_constructor_element = comma row_value_constructor_element;

// <row value constructor element> ::= <value expression>
row_value_constructor_element = value_expression;

// <contextually typed row value constructor> ::= <common value expression> | <boolean value expression> | <contextually typed value specification> | <left paren> <contextually typed value specification> <right paren> | <left paren> <contextually typed row value constructor element> <comma> <contextually typed row value constructor element list> <right paren> | ROW <left paren> <contextually typed row value constructor element list> <right paren>
contextually_typed_row_value_constructor = {common} common_value_expression | {boolean} boolean_value_expression | {specification} contextually_typed_value_specification
    | {paren_spec} left_paren contextually_typed_value_specification right_paren
    | {list} left_paren contextually_typed_row_value_constructor_element comma contextually_typed_row_value_constructor_element_list right_paren
    | {row} t_row left_paren contextually_typed_row_value_constructor_element_list right_paren;

// <contextually typed row value constructor element list> ::= <contextually typed row value constructor element> [ { <comma> <contextually typed row value constructor element> }... ]
contextually_typed_row_value_constructor_element_list = contextually_typed_row_value_constructor_element addl_contextually_typed_row_value_constructor_element*;
addl_contextually_typed_row_value_constructor_element = comma contextually_typed_row_value_constructor_element;

// <contextually typed row value constructor element> ::= <value expression> | <contextually typed value specification>
contextually_typed_row_value_constructor_element = {value} value_expression | contextually_typed_value_specification;

// <row value constructor predicand> ::= <common value expression> | <boolean predicand> | <explicit row value constructor>
//LALR row_value_constructor_predicand = {common} common_value_expression | {explicit} explicit_row_value_constructor | {boolean} boolean_predicand;
row_value_constructor_predicand = {common} common_value_expression | {explicit} explicit_row_value_constructor | {paren} left_paren boolean_value_expression right_paren | {nonparen} nonparenthesized_value_expression_primary;

// literals

// <literal> ::= <signed numeric literal> | <general literal>
literal = {signed_numeric_literal} signed_numeric_literal | {general_literal} general_literal;

// <unsigned literal> ::= <unsigned numeric literal> | <general literal>
unsigned_literal = {unsigned_numeric_literal} unsigned_numeric_literal | {general_literal} general_literal;

// <general literal> ::= <character string literal> | <national character string literal> | <Unicode character string literal> | <binary string literal>
// | <datetime literal> | <interval literal> | <boolean literal>
general_literal = {character_string_literal} character_string_literal | {national_character_string_literal}  national_character_string_literal
  | {unicode_character_string_literal} unicode_character_string_literal | {binary_string_literal} binary_string_literal
  | {datetime_literal} datetime_literal | {interval_literal} interval_literal | {boolean_literal} boolean_literal;

// <character string literal> ::= [ <introducer><character set specification> ] <quote> [ <character representation>... ] <quote> [ { <separator> <quote> [ <character representation>... ] <quote> }... ]
character_string_literal_introducer= introducer character_set_specification;
character_string_literal = character_string_literal_introducer? quoted_character_representation additional_character_string_literals*;

additional_character_string_literals = separator quoted_character_representation;

character_set_specification = {utf8} t_utf8 | {utf16} t_utf16;

// <introducer> ::= <underscore> 
introducer = underscore;

//<character representation> ::= <nonquote character> | <quote symbol>
character_representation = {nonquote_character} nonquote_character | {quote_symbol} quote_symbol;

quoted_character_representation = quote_open character_representation* quote_close;


// <quote symbol> ::= <quote><quote>
quote_symbol = quote_open quote_close;

// <national character string literal> ::= N <quote> [ <character representation>... ] <quote> [ { <separator> <quote> [ <character representation>... ] <quote> }... ]
sep_quoted_character_representation = separator quoted_character_representation;
national_character_string_literal = n quoted_character_representation sep_quoted_character_representation*;

// <Unicode character string literal> ::= [ <introducer><character set specification> ] U<ampersand><quote> [ <Unicode representation>... ] <quote> [ { <separator> <quote> [ <Unicode representation>... ] <quote> }... ] <Unicode escape specifier>
quoted_unicode_representation = quote_open unicode_representation* quote_close;
sep_quoted_unicode_representation = separator quoted_unicode_representation;
unicode_character_string_literal = character_string_literal_introducer? u ampersand quoted_unicode_representation sep_quoted_unicode_representation* unicode_escape_specifier;

// <Unicode representation> ::= <character representation> | <Unicode escape value>
unicode_representation = {character_representation} character_representation | {unicode_escape_value} unicode_escape_value;

// <binary string literal> ::= X <quote> [ <space>... ] [ { <hexit> [ <space>... ] <hexit> [ <space>... ] }... ] <quote> [ { <separator> <quote> [ <space>... ] [ { <hexit> [ <space>... ] <hexit> [ <space>... ] }... ] <quote> }... ]

hexit_space = hexit space* hexit1 space1*;
quoted_hexit_space = quote_open space* hexit_space* quote_close;
sep_quoted_hexit_space = separator quoted_hexit_space;
binary_string_literal = x quoted_hexit_space sep_quoted_hexit_space*;

// <hexit> ::= <digit> | A | B | C | D | E | F | a | b | c | d | e | f
hexit = {digit} digit | {a} a | {b} b | {c} c | {d} d | {e} e | {f} f;

// <signed numeric literal> ::= [ <sign> ] <unsigned numeric literal>
signed_numeric_literal = sign? unsigned_numeric_literal;

// <unsigned numeric literal> ::= <exact numeric literal> | <approximate numeric literal>
unsigned_numeric_literal = {exact_numeric_literal} exact_numeric_literal | {approximate_numeric_literal} approximate_numeric_literal;

//<exact numeric literal> ::= <unsigned integer> [ <period> [ <unsigned integer> ] ] | <period> <unsigned integer>
exact_numeric_literal =  {unsigned_integer_optional_decimal} unsigned_integer_optional_decimal | {decimal} decimal;

unsigned_integer_optional_decimal = unsigned_integer optional_decimal?;
decimal = period unsigned_integer;

optional_decimal = period unsigned_integer?;

// <sign> ::= <plus sign> | <minus sign>
 sign = {plus_sign} plus_sign | {minus_sign} minus_sign;

// <approximate numeric literal> ::= <mantissa> E <exponent>
approximate_numeric_literal = mantissa e exponent;

// <mantissa> ::= <exact numeric literal>
mantissa = exact_numeric_literal;

// <exponent> ::= <signed integer>
exponent = signed_integer;

// <signed integer> ::= [ <sign> ] <unsigned integer>
signed_integer = sign? unsigned_integer;

// <unsigned integer> ::= <digit>...
unsigned_integer = digit+;

// <datetime literal> ::= <date literal> | <time literal> | <timestamp literal>
datetime_literal = {date_literal} date_literal | {time_literal} time_literal | {timestamp_literal} timestamp_literal;

// <date literal> ::= DATE <date string>
date_literal = t_date date_string;

// <time literal> ::= TIME <time string>
time_literal = t_time time_string;

// <timestamp literal> ::= TIMESTAMP <timestamp string>
timestamp_literal = t_timestamp timestamp_string;

// <date string> ::= <quote> <unquoted date string> <quote>
date_string = quote_open unquoted_date_string quote_close;

// <time string> ::= <quote> <unquoted time string> <quote>
time_string = quote_open unquoted_time_string quote_close;

// <timestamp string> ::= <quote> <unquoted timestamp string> <quote>
timestamp_string = quote_open unquoted_timestamp_string quote_close;

// <time zone interval> ::= <sign> <hours value> <colon> <minutes value>
time_zone_interval = sign hours_value colon minutes_value;
// <date value> ::= <years value> <minus sign> <months value> <minus sign> <days value>
date_value = hours_value colon minutes_value colon1 seconds_value;

// <time value> ::= <hours value> <colon> <minutes value> <colon> <seconds value>
time_value = hours_value colon minutes_value colon1 seconds_value;

// <interval literal> ::= INTERVAL [ <sign> ] <interval string> <interval qualifier>
interval_literal = t_interval sign? interval_qualifier;

// <interval string> ::= <quote> <unquoted interval string> <quote>
interval_string = quote_open unquoted_interval_string quote_close;

// <unquoted date string> ::= <date value>
unquoted_date_string = date_value;

// <unquoted time string> ::= <time value> [ <time zone interval> ]
unquoted_time_string = time_value time_zone_interval?;

// <unquoted timestamp string> ::= <unquoted date string> <space> <unquoted time string>
unquoted_timestamp_string = unquoted_date_string space unquoted_time_string;

// <unquoted interval string> ::= [ <sign> ] { <year-month literal> | <day-time literal> }
yearmonth_or_daytime_literal = {year_month_literal} year_month_literal | {day_time_literal} day_time_literal;
unquoted_interval_string = sign? yearmonth_or_daytime_literal;

// <year-month literal> ::= <years value> [ <minus sign> <months value> ] | <months value>
minus_month = minus_sign months_value;
year_month_literal = {years_month} years_value minus_month? | {month} months_value;

// <day-time literal> ::= <day-time interval> | <time interval>
day_time_literal = {day_time_interval} day_time_interval | {time_interval} time_interval;

// <day-time interval> ::= <days value> [ <space> <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ] ]
space_hours_value = space hours_value minutes_interval?;
day_time_interval = days_value space_hours_value?;

// <time interval> ::= <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ] | <minutes value> [ <colon> <seconds value> ] | <seconds value>
time_interval = {hours_minutes} hours_value minutes_interval? | {minutes_seconds} minutes_value seconds_interval? | {seconds_value} seconds_value;

minutes_interval = colon minutes_value seconds_interval?;

seconds_interval = colon seconds_value;

// <years value> ::= <datetime value>
years_value = datetime_value;

// <months value> ::= <datetime value>
months_value = datetime_value;

// <days value> ::= <datetime value>
days_value = datetime_value;

// <hours value> ::= <datetime value>
hours_value = datetime_value;

// <minutes value> ::= <datetime value>
minutes_value = datetime_value;

// <seconds value> ::= <seconds integer value> [ <period> [ <seconds fraction> ] ]
seconds_value = seconds_integer_value milliseconds_value?;

milliseconds_value = period seconds_fraction?;

// <seconds integer value> ::= <unsigned integer>
seconds_integer_value = unsigned_integer;

// <seconds fraction> ::= <unsigned integer>
seconds_fraction = unsigned_integer;

// <datetime value> ::= <unsigned integer>
datetime_value = unsigned_integer;

// <boolean literal> ::= TRUE | FALSE | UNKNOWN
boolean_literal = {true} t_true | {false} t_false | {unknown} t_unknown;

// <SQL parameter reference> ::= <basic identifier chain>
sql_parameter_reference = basic_identifier_chain;

// <column reference> ::= <basic identifier chain> | MODULE <period> <qualified identifier> <period> <column name>
column_reference = {basic} basic_identifier_chain | {module} t_module period qualified_identifier period1 column_name;

// <SQL terminal character> ::= <SQL language character>
sql_terminal_character = sql_language_character;
 
// <SQL language character> ::= <simple Latin letter> | <digit> | <SQL special character>
sql_language_character = {simple_latin_letter} simple_latin_letter | {digit} digit | {sql_special_character} sql_special_character;

// <simple Latin letter> ::= <simple Latin upper case letter> | <simple Latin lower case letter>
simple_latin_letter = {simple_latin_upper_case_letter} simple_latin_upper_case_letter | {simple_latin_lower_case_letter} simple_latin_lower_case_letter;

// <SQL special character> ::= <sp> | <double quote> | <percent> | <ampersand> | <quote> | <left paren>c| <right paren>c| <asterisk> | <plus sign> | <comma> | <minus sign> | <period>
// | <solidus> | <colon> | <semicolon> | <less than operator> | <equals operator> | <greater than operator> | <question mark> | <left bracket> | <right bracket> | <circumflex> | <underscore> | <vertical bar> | <left brace> | <right brace>
sql_special_character = 
    {space} space | {double_quote_open} double_quote_open | {double_quote_close} double_quote_close | {percent} percent | {ampersand} ampersand
  | {quote_open} quote_open | {quote_close} quote_close | {left_paren} left_paren | {right_paren} right_paren | {asterisk} asterisk | {plus_sign} plus_sign
  | {comma} comma | {minus_sign} minus_sign | {period} period | {solidus} solidus | {colon} colon | {colon1} colon1 | {semicolon} semicolon
  | {less_than_operator} less_than_operator | {equals_operator} equals_operator | {greater_than_operator} greater_than_operator
  | {question_mark} question_mark | {left_bracket} left_bracket | {right_bracket} right_bracket | {circumflex} circumflex
  | {underscore} underscore | {vertical_bar} vertical_bar | {left_brace} left_brace | {right_brace} right_brace;

// <left bracket or trigraph> ::= <left bracket> | <left bracket trigraph>
left_bracket_or_trigraph = {left_bracket} left_bracket | {left_bracket_trigraph} left_bracket_trigraph;

// <right bracket or trigraph> ::= <right bracket> | <right bracket trigraph>
right_bracket_or_trigraph = {right_bracket} right_bracket | {right_bracket_trigraph} right_bracket_trigraph;

// <token> ::= <nondelimiter token> | <delimiter token>
token = {nondelimiter_token} nondelimiter_token | {delimiter_token} delimiter_token;

// <nondelimiter token> ::= <regular identifier> | <key word> | <unsigned numeric literal> | <national character string literal> | 
//    <binary string literal> | <large object length token> | <Unicode delimited identifier> | <Unicode character string literal> | <SQL language identifier>
nondelimiter_token = {regular_identifier} regular_identifier | {key_word} key_word | {unsigned_numeric_literal} unsigned_numeric_literal 
  | {national_character_string_literal} national_character_string_literal | {binary_string_literal} binary_string_literal 
  | {large_object_length_token} large_object_length_token | {unicode_delimited_identifier} unicode_delimited_identifier 
  | {unicode_character_string_literal} unicode_character_string_literal | {sql_language_identifier} sql_language_identifier;

// <regular identifier> ::= <identifier body>
regular_identifier = identifier_body;

// <identifier body> ::= <identifier start> [ <identifier part>... ]
identifier_body = identifier_start identifier_extend*;

// <identifier part> ::= <identifier start> | <identifier extend>
//identifier_part = {identifier_start} identifier_start | {identifier_extend} identifier_extend;

// <large object length token> ::= <digit>... <multiplier>
large_object_length_token = digit+ multiplier;

// <multiplier> ::= K | M | G | T | P
multiplier = {kilo} kilo | {mega} mega | {giga} giga | {tera} tera | {peta} peta;

//  <delimited identifier> ::= <double quote> <delimited identifier body> <double quote>
delimited_identifier = double_quote_open delimited_identifier_body double_quote_close;

//  <delimited identifier body> ::= <delimited identifier part>...
delimited_identifier_body = delimited_identifier_part+;

//  <delimited identifier part> ::= <nondoublequote character> | <doublequote symbol>
delimited_identifier_part = {nondoublequote_character} nondoublequote_character | {doublequote_symbol} doublequote_symbol;

//  <Unicode delimited identifier> ::= U<ampersand><double quote> <Unicode delimiter body> <double quote> <Unicode escape specifier>
unicode_delimited_identifier = u ampersand double_quote_open unicode_delimiter_body double_quote_close unicode_escape_specifier;

//  <Unicode escape specifier> ::= [ UESCAPE <quote><Unicode escape character><quote> ]
unicode_escape_specifier_body = t_uescape quote_open unicode_escape_character quote_close;
unicode_escape_specifier = unicode_escape_specifier_body?;

//  <Unicode delimiter body> ::= <Unicode identifier part>...
unicode_delimiter_body = unicode_idenfitifer_part+ ;

//  <Unicode identifier part> ::= <delimited identifier part> | <Unicode escape value>
unicode_idenfitifer_part = {delimited_identifier_part} delimited_identifier_part | {unicode_escape_value} unicode_escape_value;

//  <Unicode escape value> ::= <Unicode 4 digit escape value> | <Unicode 6 digit escape value> | <Unicode character escape value>
unicode_escape_value = {unicode_four_digit_escape_value} unicode_four_digit_escape_value | {unicode_six_digit_escape_value} unicode_six_digit_escape_value 
  | {unicode_character_escape_value} unicode_character_escape_value;

hexit1 = hexit;
hexit2 = hexit1 hexit;
hexit4 = hexit2 hexit1 hexit;

//  <Unicode 4 digit escape value> ::= <Unicode escape character><hexit><hexit><hexit><hexit>
unicode_four_digit_escape_value = unicode_escape_character hexit4;


//  <Unicode 6 digit escape value> ::= <Unicode escape character><plus sign><hexit><hexit><hexit><hexit><hexit><hexit>
unicode_six_digit_escape_value = unicode_escape_character plus_sign hexit4 hexit2;

//  <Unicode character escape value> ::= <Unicode escape character><Unicode escape character>
unicode_character_escape_value = unicode_escape_character unicode_escape_character1;

unicode_escape_character1 = unicode_escape_character;

//  <delimiter token> ::= <character string literal> | <date string> | <time string> | <timestamp string> | <interval string> | <delimited identifier>
//  | <SQL special character> | <not equals operator> | <greater than or equals operator> | <less than or equals operator> | 
//  <concatenation operator | <right arrow> | <left bracket trigraph> | <right bracket trigraph> | <double colon> | <double period> | <named argument assignment token>
delimiter_token = {character_string_literal} character_string_literal | {date_string} date_string | {time_string} time_string 
  | {timestamp_string} timestamp_string | {interval_string} interval_string | {delimited_identifier} delimited_identifier
  | {sql_special_character} sql_special_character | {not_equals_operator} not_equals_operator | {greater_than_or_equals_operator} greater_than_or_equals_operator
  | {less_than_or_equals_operator} less_than_or_equals_operator | {concatenation_operator} concatenation_operator | {right_arrow} right_arrow
  | {left_bracket_trigraph} left_bracket_trigraph | {right_bracket_trigraph} right_bracket_trigraph | {double_colon} double_colon 
  | {double_period} double_period | {named_argument_assignment_token} named_argument_assignment_token;

//  <separator> ::= { <comment> | <white space> }...
separator_body = {comment} comment | {white_space} white_space;
separator = separator_body+;

//  <comment> ::= <simple comment> | <bracketed comment>
comment = {simple_comment} simple_comment | {bracketed_comment} bracketed_comment;

//  <simple comment> ::= <simple comment introducer> [ <comment character>... ] <newline>
simple_comment = simple_comment_introducer comment_character* newline;

//  <bracketed comment> ::= <bracketed comment introducer> <bracketed comment contents> <bracketed comment terminator>
bracketed_comment = bracketed_comment_introducer bracketed_comment_contents bracketed_comment_terminator;

//  <bracketed comment contents> ::= [ { <comment character> | <separator> }... ] !! See the Syntax Rules.
//bracketed_comment_content = {comment_character} comment_character | {separator} separator;
bracketed_comment_content = {comment_character} comment_character | {white_space} white_space;
bracketed_comment_contents = bracketed_comment_content*;

comment_character = {nonquote_character} nonquote_character | {quote} quote_open;

key_word = {reserved_word} reserved_word | {non_reserved_word} non_reserved_word;

non_reserved_word =
    {t_a} t_a | {t_absolute} t_absolute | {t_action} t_action | {t_ada} t_ada | {t_add} t_add | {t_admin} t_admin | {t_after} t_after | {t_always} t_always
  | {t_asc} t_asc | {t_assertion} t_assertion | {t_assignment} t_assignment | {t_attribute} t_attribute | {t_attributes} t_attributes | {t_before} t_before
  | {t_bernoulli} t_bernoulli | {t_breadth} t_breadth | {t_c} t_c | {t_cascade} t_cascade | {t_catalog} t_catalog | {t_catalog_name} t_catalog_name
  | {t_chain} t_chain | {t_character_set_catalog} t_character_set_catalog | {t_character_set_name} t_character_set_name | {t_character_set_schema} t_character_set_schema
  | {t_characteristics} t_characteristics | {t_characters} t_characters | {t_class_origin} t_class_origin | {t_cobol} t_cobol | {t_collation} t_collation
  | {t_collation_catalog} t_collation_catalog | {t_collation_name} t_collation_name | {t_collation_schema} t_collation_schema | {t_column_name} t_column_name
  | {t_command_function} t_command_function | {t_command_function_code} t_command_function_code | {t_committed} t_committed | {t_condition_number} t_condition_number
  | {t_connection} t_connection | {t_connection_name} t_connection_name | {t_constraint_catalog} t_constraint_catalog | {t_constraint_name} t_constraint_name
  | {t_constraint_schema} t_constraint_schema | {t_constraints} t_constraints | {t_constructor} t_constructor | {t_continue} t_continue | {t_cursor_name} t_cursor_name
  | {t_data} t_data | {t_datetime_interval_code} t_datetime_interval_code | {t_datetime_interval_precision} t_datetime_interval_precision
  | {t_defaults} t_defaults | {t_deferrable} t_deferrable | {t_deferred} t_deferred | {t_defined} t_defined | {t_definer} t_definer | {t_degree} t_degree
  | {t_depth} t_depth | {t_derived} t_derived | {t_desc} t_desc | {t_descriptor} t_descriptor | {t_diagnostics} t_diagnostics | {t_dispatch} t_dispatch
  | {t_domain} t_domain | {t_dynamic_function} t_dynamic_function | {t_dynamic_function_code} t_dynamic_function_code | {t_enforced} t_enforced
  | {t_exclude} t_exclude | {t_excluding} t_excluding | {t_expression} t_expression | {t_final} t_final | {t_first} t_first | {t_flag} t_flag | {t_following} t_following
  | {t_fortran} t_fortran | {t_found} t_found | {t_g} t_g | {t_general} t_general | {t_generated} t_generated | {t_go} t_go | {t_goto} t_goto | {t_granted} t_granted
  | {t_hierarchy} t_hierarchy | {t_ignore} t_ignore | {t_immediate} t_immediate | {t_immediately} t_immediately | {t_implementation} t_implementation
  | {t_including} t_including | {t_increment} t_increment | {t_initially} t_initially | {t_input} t_input | {t_instance} t_instance | {t_instantiable} t_instantiable
  | {t_instead} t_instead | {t_invoker} t_invoker | {t_isolation} t_isolation | {t_k} t_k | {t_key} t_key | {t_key_member} t_key_member | {t_key_type} t_key_type
  | {t_last} t_last | {t_length} t_length | {t_level} t_level | {t_locator} t_locator | {t_m} t_m | {t_map} t_map | {t_matched} t_matched | {t_maxvalue} t_maxvalue
  | {t_message_length} t_message_length | {t_message_octet_length} t_message_octet_length | {t_message_text} t_message_text | {t_minvalue} t_minvalue
  | {t_more} t_more | {t_mumps} t_mumps | {t_name} t_name | {t_names} t_names | {t_nesting} t_nesting | {t_next} t_next | {t_nfc} t_nfc | {t_nfd} t_nfd | {t_nfkc} t_nfkc
  | {t_nfkd} t_nfkd | {t_normalized} t_normalized | {t_nullable} t_nullable | {t_nulls} t_nulls | {t_number} t_number | {t_object} t_object | {t_octets} t_octets
  | {t_option} t_option | {t_options} t_options | {t_ordering} t_ordering | {t_ordinality} t_ordinality | {t_others} t_others | {t_output} t_output | {t_overriding} t_overriding
  | {t_p} t_p | {t_pad} t_pad | {t_parameter_mode} t_parameter_mode | {t_parameter_name} t_parameter_name | {t_parameter_ordinal_position} t_parameter_ordinal_position
  | {t_parameter_specific_catalog} t_parameter_specific_catalog | {t_parameter_specific_name} t_parameter_specific_name | {t_parameter_specific_schema} t_parameter_specific_schema
  | {t_partial} t_partial | {t_pascal} t_pascal | {t_path} t_path | {t_placing} t_placing | {t_pli} t_pli | {t_preceding} t_preceding | {t_preserve} t_preserve
  | {t_prior} t_prior | {t_privileges} t_privileges | {t_public} t_public | {t_read} t_read | {t_relative} t_relative | {t_repeatable} t_repeatable | {t_respect} t_respect
  | {t_restart} t_restart | {t_restrict} t_restrict | {t_returned_cardinality} t_returned_cardinality | {t_returned_length} t_returned_length
  | {t_returned_octet_length} t_returned_octet_length | {t_returned_sqlstate} t_returned_sqlstate | {t_role} t_role | {t_routine} t_routine
  | {t_routine_catalog} t_routine_catalog | {t_routine_name} t_routine_name | {t_routine_schema} t_routine_schema | {t_row_count} t_row_count
  | {t_scale} t_scale | {t_schema} t_schema | {t_schema_name} t_schema_name | {t_scope_catalog} t_scope_catalog | {t_scope_name} t_scope_name
  | {t_scope_schema} t_scope_schema | {t_section} t_section | {t_security} t_security | {t_self} t_self | {t_sequence} t_sequence | {t_serializable} t_serializable
  | {t_server_name} t_server_name | {t_session} t_session | {t_sets} t_sets | {t_simple} t_simple | {t_size} t_size | {t_source} t_source | {t_space} t_space
  | {t_specific_name} t_specific_name | {t_state} t_state | {t_statement} t_statement | {t_structure} t_structure | {t_style} t_style | {t_subclass_origin} t_subclass_origin
  | {t_t} t_t | {t_table_name} t_table_name | {t_temporary} t_temporary | {t_ties} t_ties | {t_top_level_count} t_top_level_count | {t_transaction} t_transaction
  | {t_transaction_active} t_transaction_active | {t_transactions_committed} t_transactions_committed | {t_transactions_rolled_back} t_transactions_rolled_back
  | {t_transform} t_transform | {t_transforms} t_transforms | {t_trigger_catalog} t_trigger_catalog | {t_trigger_name} t_trigger_name | {t_trigger_schema} t_trigger_schema
  | {t_type} t_type | {t_unbounded} t_unbounded | {t_uncommitted} t_uncommitted | {t_under} t_under | {t_unnamed} t_unnamed | {t_usage} t_usage | {t_user_defined_type_catalog} t_user_defined_type_catalog
  | {t_user_defined_type_code} t_user_defined_type_code | {t_user_defined_type_name} t_user_defined_type_name | {t_user_defined_type_schema} t_user_defined_type_schema
  | {t_view} t_view | {t_work} t_work | {t_write} t_write | {t_zone} t_zone;

reserved_word =
    {t_abs} t_abs | {t_all} t_all | {t_allocate} t_allocate | {t_alter} t_alter | {t_and} t_and | {t_any} t_any | {t_are} t_are | {t_array} t_array | {t_array_agg} t_array_agg
  | {t_array_max_cardinality} t_array_max_cardinality | {t_as} t_as | {t_asensitive} t_asensitive | {t_asymmetric} t_asymmetric | {t_at} t_at | {t_atomic} t_atomic
  | {t_authorization} t_authorization | {t_avg} t_avg | {t_begin} t_begin | {t_begin_frame} t_begin_frame | {t_begin_partition} t_begin_partition
  | {t_between} t_between | {t_bigint} t_bigint | {t_binary} t_binary | {t_blob} t_blob | {t_boolean} t_boolean | {t_both} t_both | {t_by} t_by | {t_call} t_call
  | {t_called} t_called | {t_cardinality} t_cardinality | {t_cascaded} t_cascaded | {t_case} t_case | {t_cast} t_cast | {t_ceil} t_ceil | {t_ceiling} t_ceiling
  | {t_char} t_char | {t_char_length} t_char_length | {t_character} t_character | {t_character_length} t_character_length | {t_check} t_check | {t_clob} t_clob
  | {t_close} t_close | {t_coalesce} t_coalesce | {t_collate} t_collate | {t_collect} t_collect | {t_column} t_column | {t_commit} t_commit | {t_condition} t_condition
  | {t_connect} t_connect | {t_constraint} t_constraint | {t_contains} t_contains | {t_convert} t_convert | {t_corr} t_corr | {t_corresponding} t_corresponding
  | {t_count} t_count | {t_covar_pop} t_covar_pop | {t_covar_samp} t_covar_samp | {t_create} t_create | {t_cross} t_cross | {t_cube} t_cube | {t_cume_dist} t_cume_dist
  | {t_current} t_current | {t_current_catalog} t_current_catalog | {t_current_date} t_current_date | {t_current_default_transform_group} t_current_default_transform_group
  | {t_current_path} t_current_path | {t_current_role} t_current_role | {t_current_row} t_current_row | {t_current_schema} t_current_schema
  | {t_current_time} t_current_time | {t_current_timestamp} t_current_timestamp | {t_current_transform_group_for_type} t_current_transform_group_for_type
  | {t_current_user} t_current_user | {t_cursor} t_cursor | {t_cycle} t_cycle | {t_date} t_date | {t_day} t_day | {t_deallocate} t_deallocate | {t_dec} t_dec
  | {t_decimal} t_decimal | {t_declare} t_declare | {t_default} t_default | {t_delete} t_delete | {t_dense_rank} t_dense_rank | {t_deref} t_deref | {t_describe} t_describe
  | {t_deterministic} t_deterministic | {t_disconnect} t_disconnect | {t_distinct} t_distinct | {t_double} t_double | {t_drop} t_drop | {t_dynamic} t_dynamic
  | {t_each} t_each | {t_element} t_element | {t_else} t_else | {t_end} t_end | {t_end_frame} t_end_frame | {t_end_partition} t_end_partition | {t_end_exec} t_end_exec
  | {t_equals} t_equals | {t_escape} t_escape | {t_every} t_every | {t_except} t_except | {t_exec} t_exec | {t_execute} t_execute | {t_exists} t_exists | {t_exp} t_exp
  | {t_external} t_external | {t_extract} t_extract | {t_false} t_false | {t_fetch} t_fetch | {t_filter} t_filter | {t_first_value} t_first_value | {t_float} t_float
  | {t_floor} t_floor | {t_for} t_for | {t_foreign} t_foreign | {t_frame_row} t_frame_row | {t_free} t_free | {t_from} t_from | {t_full} t_full | {t_function} t_function
  | {t_fusion} t_fusion | {t_get} t_get | {t_global} t_global | {t_grant} t_grant | {t_group} t_group | {t_grouping} t_grouping | {t_groups} t_groups | {t_having} t_having
  | {t_hold} t_hold | {t_hour} t_hour | {t_identity} t_identity | {t_in} t_in | {t_indicator} t_indicator | {t_inner} t_inner | {t_inout} t_inout | {t_insensitive} t_insensitive
  | {t_insert} t_insert | {t_int} t_int | {t_integer} t_integer | {t_intersect} t_intersect | {t_intersection} t_intersection | {t_interval} t_interval
  | {t_into} t_into | {t_is} t_is | {t_join} t_join | {t_lag} t_lag | {t_language} t_language | {t_large} t_large | {t_last_value} t_last_value | {t_lateral} t_lateral
  | {t_lead} t_lead | {t_leading} t_leading | {t_left} t_left | {t_like} t_like | {t_like_regex} t_like_regex | {t_ln} t_ln | {t_local} t_local | {t_localtime} t_localtime
  | {t_localtimestamp} t_localtimestamp | {t_lower} t_lower | {t_match} t_match | {t_max} t_max | {t_member} t_member | {t_merge} t_merge | {t_method} t_method
  | {t_min} t_min | {t_minute} t_minute | {t_mod} t_mod | {t_modifies} t_modifies | {t_module} t_module | {t_month} t_month | {t_multiset} t_multiset | {t_national} t_national
  | {t_natural} t_natural | {t_nchar} t_nchar | {t_nclob} t_nclob | {t_new} t_new | {t_no} t_no | {t_none} t_none | {t_normalize} t_normalize | {t_not} t_not | {t_nth_value} t_nth_value
  | {t_ntile} t_ntile | {t_null} t_null | {t_nullif} t_nullif | {t_numeric} t_numeric | {t_octet_length} t_octet_length | {t_occurrence } t_occurrence | {t_occurrences_regex} t_occurrences_regex
  | {t_of} t_of | {t_offset} t_offset | {t_old} t_old | {t_on} t_on | {t_only} t_only | {t_open} t_open | {t_or} t_or | {t_order} t_order | {t_out} t_out | {t_outer} t_outer
  | {t_over} t_over | {t_overlaps} t_overlaps | {t_overlay} t_overlay | {t_parameter} t_parameter | {t_partition} t_partition | {t_percent} t_percent
  | {t_percent_rank} t_percent_rank | {t_percentile_cont} t_percentile_cont | {t_percentile_disc} t_percentile_disc | {t_period} t_period
  | {t_portion} t_portion | {t_position} t_position | {t_position_regex} t_position_regex | {t_power} t_power | {t_precedes} t_precedes | {t_precision} t_precision
  | {t_prepare} t_prepare | {t_primary} t_primary | {t_procedure} t_procedure | {t_range} t_range | {t_rank} t_rank | {t_reads} t_reads | {t_real} t_real | {t_recursive} t_recursive
  | {t_ref} t_ref | {t_references} t_references | {t_referencing} t_referencing | {t_regr_avgx} t_regr_avgx | {t_regr_avgy} t_regr_avgy | {t_regr_count} t_regr_count
  | {t_regr_intercept} t_regr_intercept | {t_regr_r2} t_regr_r2 | {t_regr_slope} t_regr_slope | {t_regr_sxx} t_regr_sxx | {t_regr_sxy} t_regr_sxy
  | {t_regr_syy} t_regr_syy | {t_release} t_release | {t_result} t_result | {t_return} t_return | {t_returns} t_returns | {t_revoke} t_revoke | {t_right} t_right
  | {t_rollback} t_rollback | {t_rollup} t_rollup | {t_row} t_row | {t_row_number} t_row_number | {t_rows} t_rows | {t_savepoint} t_savepoint | {t_scope} t_scope
  | {t_scroll} t_scroll | {t_search} t_search | {t_second} t_second | {t_select} t_select | {t_sensitive} t_sensitive | {t_session_user} t_session_user | {t_set} t_set
  | {t_similar} t_similar | {t_smallint} t_smallint | {t_some} t_some | {t_specific} t_specific | {t_specifictype} t_specifictype | {t_sql} t_sql | {t_sqlexception} t_sqlexception
  | {t_sqlstate} t_sqlstate | {t_sqlwarning} t_sqlwarning | {t_sqrt} t_sqrt | {t_start} t_start | {t_static} t_static | {t_stddev_pop} t_stddev_pop | {t_stddev_samp} t_stddev_samp
  | {t_submultiset} t_submultiset | {t_substring} t_substring | {t_substring_regex} t_substring_regex | {t_succeeds} t_succeeds | {t_sum} t_sum | {t_symmetric} t_symmetric
  | {t_system} t_system | {t_system_time} t_system_time | {t_system_user} t_system_user | {t_table} t_table | {t_tablesample} t_tablesample | {t_then} t_then
  | {t_time} t_time | {t_timestamp} t_timestamp | {t_timezone_hour} t_timezone_hour | {t_timezone_minute} t_timezone_minute | {t_to} t_to | {t_trailing} t_trailing
  | {t_translate} t_translate | {t_translate_regex} t_translate_regex | {t_translation} t_translation | {t_treat} t_treat | {t_trigger} t_trigger
  | {t_truncate} t_truncate | {t_trim} t_trim | {t_trim_array} t_trim_array | {t_true} t_true | {t_uescape} t_uescape | {t_union} t_union | {t_unique} t_unique
  | {t_unknown} t_unknown | {t_unnest} t_unnest | {t_update} t_update | {t_upper} t_upper | {t_user} t_user | {t_using} t_using | {t_value} t_value | {t_values} t_values
  | {t_value_of} t_value_of | {t_var_pop} t_var_pop | {t_var_samp} t_var_samp | {t_varbinary} t_varbinary | {t_varchar} t_varchar | {t_varying} t_varying
  | {t_versioning} t_versioning | {t_when} t_when | {t_whenever} t_whenever | {t_where} t_where | {t_width_bucket} t_width_bucket | {t_window} t_window
  | {t_with} t_with | {t_within} t_within | {t_without} t_without | {t_year} t_year;

// <column definition> ::= <column name> [ <data type or domain name> ] 
//  [ <default clause> | <identity column specification> | <generation clause> | <system time period start column specification> | <system time period end column specification> ] 
//  [ <column constraint definition>... ] [ <collate clause> ]
opt_clause_or_spec = {default} default_clause | {identity} identity_column_specification | {generation} generation_clause | {start} system_time_period_start_column_specification
    |  {end} system_time_period_end_column_specification;  
column_definition = column_name data_type_or_domaian_name? opt_clause_or_spec? column_constraint_definition* collate_clause?;

// <data type or domain name> ::= <data type> | <domain name>
data_type_or_domaian_name = {type} data_type | {name} domain_name;

// <system time period start column specification> ::= <timestamp generation rule> AS ROW START
system_time_period_start_column_specification = timestamp_generation_rule t_as t_row t_start;

// <system time period end column specification> ::= <timestamp generation rule> AS ROW END
system_time_period_end_column_specification = timestamp_generation_rule t_as t_row t_end;

// <timestamp generation rule> ::= GENERATED ALWAYS
timestamp_generation_rule = t_generated t_always;

// <column constraint definition> ::= [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]
column_constraint_definition = constraint_name_definition? column_constraint constraint_characteristics?;

// <column constraint> ::= NOT NULL | <unique specification> | <references specification> | <check constraint definition>
column_constraint = {not_null} t_not t_null | {unique} unique_specification | {references} references_specification | {check} check_constraint_definition;

// <identity column specification> ::= GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ <left paren> <common sequence generator options> <right paren> ]
identity_column_specification = t_generated always_or_by_default t_as t_identity paren_common_sequence_generator_options?;
always_or_by_default = {always} t_always | {default} t_by t_default;
paren_common_sequence_generator_options = left_paren common_sequence_generator_options right_paren;

// <generation clause> ::= <generation rule> AS <generation expression>
generation_clause = generation_rule t_as generation_expression;

// <generation rule> ::= GENERATED ALWAYS
generation_rule = t_generated t_always;

// <generation expression> ::= <left paren> <value expression> <right paren>
generation_expression = left_paren value_expression right_paren;

// <table period definition> ::= <system or application time period specification> <left paren> <period begin column name> <comma> <period end column name> <right paren>
table_period_definition = system_or_application_time_period_specification left_paren period_begin_column_name comma period_end_column_name right_paren;

// <system or application time period specification> ::= <system time period specification> | <application time period specification>
// <system time period specification> ::= PERIOD FOR SYSTEM_TIME
// <application time period specification> ::= PERIOD FOR <application time period name>
// <application time period name> ::= <identifier>
// <period begin column name> ::= <column name>
period_begin_column_name = column_name;

// <period end column name> ::= <column name>
period_end_column_name = column_name;

// <table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]
table_constraint_definition = constraint_name_definition? table_constraint constraint_characteristics?;

// <table constraint> ::= <unique constraint definition> | <referential constraint definition> | <check constraint definition>
table_constraint = {unique} unique_constraint_definition | {ref} referential_constraint_definition | {check} check_constraint_definition;

// <data type> ::= <predefined type> | <row type> | <path-resolved user-defined type name> | <reference type> | <collection type>
data_type = {predefined} predefined_type | {row} row_type | {path} path_resolved_user_defined_type_name | {reference} reference_type | {collection} collection_type;

// <predefined type> ::= <character string type> [ CHARACTER SET <character set specification> ] [ <collate clause> ] | <national character string type> [ <collate clause> ] | <binary string type> | <numeric type> | <boolean type> | <datetime type> | <interval type>
predefined_type = {character} character_string_type character_set_spec_def? collate_clause? | {national} national_character_string_type collate_clause?
     | {binary} binary_string_type | {numeric} numeric_type | {boolean} boolean_type | {datetime} datetime_type | {interval} interval_type;
character_set_spec_def = t_character t_set character_set_specification;

// <character string type> ::= CHARACTER [ <left paren> <character length> <right paren> ] | CHAR [ <left paren> <character length> <right paren> ] | CHARACTER VARYING <left paren> <character length> <right paren> | CHAR VARYING <left paren> <character length> <right paren> | VARCHAR <left paren> <character length> <right paren> | <character large object type>
paren_character_length = left_paren character_length right_paren;
character_string_type = {character} t_character paren_character_length? | {char} t_char paren_character_length? | {character_varying} t_character t_varying paren_character_length | {char_varying} t_char t_varying paren_character_length | {varchar} t_varchar paren_character_length | {clot} character_large_object_type;
// <character large object type> ::= CHARACTER LARGE OBJECT [ <left paren> <character large object length> <right paren> ] | CHAR LARGE OBJECT [ <left paren> <character large object length> <right paren> ]
//   | CLOB [ <left paren> <character large object length> <right paren> ]
paren_character_large_object_length = left_paren character_large_object_length right_paren;
character_large_object_type = {character_large_object} t_character t_large t_object paren_character_large_object_length? | {char_large_object} t_char t_large t_object paren_character_large_object_length? 
   | {clob} t_clob paren_character_large_object_length?; 
// <national character string type> ::= NATIONAL CHARACTER [ <left paren> <character length> <right paren> ] | NATIONAL CHAR [ <left paren> <character length> <right paren> ]
//  | NCHAR [ <left paren> <character length> <right paren> ] | NATIONAL CHARACTER VARYING <left paren> <character length> <right paren> | NATIONAL CHAR VARYING <left paren> <character length> <right paren>
//  | NCHAR VARYING <left paren> <character length> <right paren> | <national character large object type>
national_character_string_type = {national_character} t_national t_character paren_character_length? | {national_char} t_national t_char paren_character_length?
   | {nchar} t_nchar paren_character_length? | {national_character_varying} t_national t_character t_varying paren_character_length | {national_char_varying} t_national t_char t_varying paren_character_length
   | {nchar_varying} t_nchar t_varying paren_character_length | {national_character_large_object_type} national_character_large_object_type;
// <national character large object type> ::= NATIONAL CHARACTER LARGE OBJECT [ <left paren> <character large object length> <right paren> ]
//   | NCHAR LARGE OBJECT [ <left paren> <character large object length> <right paren> ] | NCLOB [ <left paren> <character large object length> <right paren> ]
national_character_large_object_type = {national_character_large_object} t_national t_character t_large t_object paren_character_large_object_length? 
   | {nchar_large_object} t_nchar t_large t_object paren_character_large_object_length? | {nclob} t_nclob paren_character_large_object_length?;
// <binary string type> ::= BINARY [ <left paren> <length> <right paren> ] | BINARY VARYING <left paren> <length> <right paren> | VARBINARY <left paren> <length> <right paren> | <binary large object string type>
paren_length = left_paren length right_paren;
binary_string_type = {binary} t_binary paren_length? | {bvarying} t_binary t_varying paren_length | {varbinary} t_varbinary paren_length | {blost} binary_large_object_string_type;
// <binary large object string type> ::= BINARY LARGE OBJECT [ <left paren> <large object length> <right paren> ] | BLOB [ <left paren> <large object length> <right paren> ]
paren_large_object_length = left_paren large_object_length right_paren;
binary_large_object_string_type = {blobject} t_binary t_large t_object paren_large_object_length? | {blob} t_blob paren_large_object_length;
// <numeric type> ::= <exact numeric type> | <approximate numeric type>
numeric_type = {exact} exact_numeric_type | {approx} approximate_numeric_type;
// <exact numeric type> ::= NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ] | DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
//  | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ] | SMALLINT | INTEGER | INT | BIGINT
comma_scale = comma scale;
paren_precision = left_paren precision comma_scale? right_paren;
exact_numeric_type = {numeric} t_numeric paren_precision? | {decimal} t_decimal paren_precision? | {dec} t_dec paren_precision? | {smallint} t_smallint | {integer} t_integer | {int} t_int | {bigint} t_bigint;
// <approximate numeric type> ::= FLOAT [ <left paren> <precision> <right paren> ] | REAL | DOUBLE PRECISION
approximate_numeric_type = {float} t_float paren_precision? | {real} t_real | {double} t_double t_precision;
// <length> ::= <unsigned integer>
length = unsigned_integer;
// <character length> ::= <length> [ <char length units> ]
character_length = length char_length_units?;
// <large object length> ::= <length> [ <multiplier> ] | <large object length token>
large_object_length = {length} length multiplier? | {token} large_object_length_token;
// <character large object length> ::= <large object length> [ <char length units> ]
character_large_object_length = large_object_length char_length_units?;
// <char length units> ::= CHARACTERS | OCTETS
char_length_units = {characters} t_characters | {octets} t_octets;
// <precision> ::= <unsigned integer>
precision = unsigned_integer;
// <scale> ::= <unsigned integer>
scale = unsigned_integer;
// <boolean type> ::= BOOLEAN
boolean_type = t_boolean;
// <datetime type> ::= DATE | TIME [ <left paren> <time precision> <right paren> ] [ <with or without time zone> ] | TIMESTAMP [ <left paren> <timestamp precision> <right paren> ] [ <with or without time zone> ]
datetime_type = {date} t_date | {time} t_time paren_time_precision? with_or_without_time_zone?  | {timestamp} t_timestamp paren_time_precision? with_or_without_time_zone?;
// <with or without time zone> ::= WITH TIME ZONE | WITHOUT TIME ZONE
with_or_without_time_zone = {with} t_with t_time t_zone | {without} t_without t_time t_zone;
// <time precision> ::= <time fractional seconds precision>
time_precision = time_fractional_seconds_precision;
// <timestamp precision> ::= <time fractional seconds precision>
timestamp_precision = time_fractional_seconds_precision;
// <time fractional seconds precision> ::= <unsigned integer>
time_fractional_seconds_precision = unsigned_integer;
// <interval type> ::= INTERVAL <interval qualifier>
interval_type = t_interval interval_qualifier;
// <row type> ::= ROW <row type body>
row_type = t_row row_type_body;
// <row type body> ::= <left paren> <field definition> [ { <comma> <field definition> }... ] <right paren>
addl_field_definition = comma field_definition;
row_type_body = left_paren field_definition addl_field_definition* right_paren;

// <reference type> ::= REF <left paren> <referenced type> <right paren> [ <scope clause> ]
reference_type = t_ref left_paren referenced_type right_paren scope_clause?;
// <scope clause> ::= SCOPE <table name>
scope_clause = t_scope table_name;

// <referenced type> ::= <path-resolved user-defined type name>
referenced_type = path_resolved_user_defined_type_name;
// <path-resolved user-defined type name> ::= <user-defined type name>
path_resolved_user_defined_type_name = user_defined_type_name;

// <collection type> ::= <array type> | <multiset type>
collection_type = {array} array_type | {multiset} multiset_type;
// <array type> ::= <data type> ARRAY [ <left bracket or trigraph> <maximum cardinality> <right bracket or trigraph> ]
array_type = data_type t_array bracket_max_cardinality?;
bracket_max_cardinality = left_bracket_or_trigraph maximum_cardinality right_bracket_or_trigraph;
// <maximum cardinality> ::= <unsigned integer>
maximum_cardinality = unsigned_integer;
// <multiset type> ::= <data type> MULTISET
multiset_type = data_type t_multiset;

// <default clause> ::= DEFAULT <default option>
default_clause = t_default default_option;

// <default option> ::= <literal> | <datetime value function> | USER | CURRENT_USER | CURRENT_ROLE | SESSION_USER | SYSTEM_USER
//  | CURRENT_CATALOG | CURRENT_SCHEMA | CURRENT_PATH | <implicitly typed value specification>
default_option = {literal} literal | {datetime} datetime_value_function | {user} t_user | {current_user} t_current_user | {current_role} t_current_role | {session_user} t_session_user | {system_user} t_system_user
   | {current_catalog} t_current_catalog | {current_schema} t_current_schema | {current_path} t_current_path | {implicit} implicitly_typed_value_specification;

// <predicate> ::= <comparison predicate> | <between predicate> | <in predicate> | <like predicate> | <similar predicate>
//    | <regex like predicate> | <null predicate> | <quantified comparison predicate> | <exists predicate> | <unique predicate>
//    | <normalized predicate> | <match predicate> | <overlaps predicate> | <distinct predicate> | <member predicate> | <submultiset predicate>
//    | <set predicate> | <type predicate> | <period predicate>
predicate = {comparison_predicate} comparison_predicate | {between_predicate} between_predicate | {in_predicate} in_predicate | {like_predicate} like_predicate | {similar_predicate} similar_predicate 
    | {regex_like_predicate} regex_like_predicate | {null_predicate} null_predicate | {quantified_comparison_predicate} quantified_comparison_predicate | {exists_predicate} exists_predicate | {unique_predicate} unique_predicate
    | {normalized_predicate} normalized_predicate | {match_predicate} match_predicate |  {overlaps_predicate} overlaps_predicate | {distinct_predicate} distinct_predicate | {member_predicate} member_predicate | {submultiset_predicate} submultiset_predicate
    | {set_predicate} set_predicate | {type_predicate} type_predicate | {period_predicate} period_predicate;

// <comparison predicate> ::= <row value predicand> <comparison predicate part 2>
comparison_predicate = row_value_predicand comparison_predicate_part2;

// <comparison predicate part 2> ::= <comp op> <row value predicand>
comparison_predicate_part2 = comp_op row_value_predicand;

// <comp op> ::= <equals operator> | <not equals operator> | <less than operator> | <greater than operator>
//   | <less than or equals operator> | <greater than or equals operator>
comp_op = {equals} equals_operator | {not_equals} not_equals_operator | {less_than} less_than_operator | {greater_than} greater_than_operator
  | {less_than_eq} less_than_or_equals_operator | {greater_than_eq} greater_than_or_equals_operator;
// <between predicate> ::= <row value predicand> <between predicate part 2>
between_predicate = row_value_predicand between_predicate_part2;

// <between predicate part 2> ::= [ NOT ] BETWEEN [ ASYMMETRIC | SYMMETRIC ] <row value predicand> AND <row value predicand>
between_predicate_part2 = t_not? t_between asymmetric_or_symmetric? [left]:row_value_predicand t_and [right]:row_value_predicand;
// <in predicate> ::= <row value predicand> <in predicate part 2>
in_predicate = row_value_predicand in_predicate_part2;
// <in predicate part 2> ::= [ NOT ] IN <in predicate value>
in_predicate_part2 = t_not? t_in in_predicate_value;
// <in predicate value> ::= <table subquery> | <left paren> <in value list> <right paren>
in_predicate_value = {query} table_subquery | {list} left_paren in_value_list right_paren;
// <in value list> ::= <row value expression> [ { <comma> <row value expression> }... ]
in_value_list = row_value_expression addl_row_value_expression*;
addl_row_value_expression = comma row_value_expression;
// <like predicate> ::= <character like predicate> | <octet like predicate>
like_predicate = {character_like_predicate} character_like_predicate | {octect_like_predicate} octect_like_predicate;
// <character like predicate> ::= <row value predicand> <character like predicate part 2>
character_like_predicate = row_value_predicand character_like_predicate_part2;
// <character like predicate part 2> ::= [ NOT ] LIKE <character pattern> [ ESCAPE <escape character> ]
character_like_predicate_part2 = t_not? t_like character_pattern esc_character_def?;
esc_character_def = t_escape escape_character;
// <character pattern> ::= <character value expression>
character_pattern = character_value_expression;
// <escape character> ::= <character value expression>
escape_character = character_value_expression;
// <octet like predicate> ::= <row value predicand> <octet like predicate part 2>
octect_like_predicate = row_value_predicand octet_like_predicate_part2;
// <octet like predicate part 2> ::= [ NOT ] LIKE <octet pattern> [ ESCAPE <escape octet> ]
octet_like_predicate_part2 = t_not? t_like octet_pattern escape_octet_def?;
escape_octet_def = t_escape escape_octet;
// <octet pattern> ::= <binary value expression>
octet_pattern = binary_value_expression;
// <escape octet> ::= <binary value expression>
escape_octet = binary_value_expression;

// <similar predicate> ::= <row value predicand> <similar predicate part 2>
similar_predicate = row_value_predicand similar_predicate_part2;
// <similar predicate part 2> ::= [ NOT ] SIMILAR TO <similar pattern> [ ESCAPE <escape character> ]
similar_predicate_part2 =  t_not? t_similar t_to similar_pattern esc_character_def?;
// <similar pattern> ::= <character value expression>
similar_pattern = character_value_expression;

// <regular expression> ::= <regular term> | <regular expression> <vertical bar> <regular term>
// <regular term> ::= <regular factor> | <regular term> <regular factor>
// <regular factor> ::= <regular primary> | <regular primary> <asterisk> | <regular primary> <plus sign> | <regular primary> <question mark> | <regular primary> <repeat factor>
// <repeat factor> ::= <left brace> <low value> [ <upper limit> ] <right brace>
// <upper limit> ::= <comma> [ <high value> ]
// <low value> ::= <unsigned integer>
// <high value> ::= <unsigned integer>
// <regular primary> ::= <character specifier> | <percent> | <regular character set> | <left paren> <regular expression> <right paren>
// <character specifier> ::= <non-escaped character> | <escaped character>
// <non-escaped character> ::= !! See the Syntax Rules.
// <escaped character> ::= !! See the Syntax Rules.
// <regular character set> ::= <underscore> | <left bracket> <character enumeration>... <right bracket> | <left bracket> <circumflex> <character enumeration>... <right bracket> | <left bracket> <character enumeration include>... <circumflex> <character enumeration exclude>... <right bracket>
// <character enumeration include> ::= <character enumeration>
// <character enumeration exclude> ::= <character enumeration>
// <character enumeration> ::= <character specifier> | <character specifier> <minus sign> <character specifier> | <left bracket> <colon> <regular character set identifier> <colon> <right bracket>
// <regular character set identifier> ::= <identifier>

// <regex like predicate> ::= <row value predicand> <regex like predicate part 2>
regex_like_predicate = row_value_predicand regex_like_predicate_part2;
// <regex like predicate part 2> ::=[ NOT ] LIKE_REGEX <XQuery pattern> [ FLAG <XQuery option flag> ]
regex_like_predicate_part2 = t_not? t_like_regex xquery_pattern xquery_option_flag_def?;
xquery_option_flag_def = t_flag xquery_option_flag;
// <null predicate> ::= <row value predicand> <null predicate part 2>
//LALR null_predicate = row_value_predicand null_predicate_part2;
null_predicate = {row_value_special_case} row_value_special_case null_predicate_part2 | {row_value_constructor_predicand} row_value_constructor_predicand null_predicate_part2;

// <null predicate part 2> ::= IS [ NOT ] NULL
null_predicate_part2 = t_is t_not? t_null;
// <quantified comparison predicate> ::= <row value predicand> <quantified comparison predicate part 2>
quantified_comparison_predicate = row_value_predicand quantified_comparison_predicate_part2;
// <quantified comparison predicate part 2> ::= <comp op> <quantifier> <table subquery>
quantified_comparison_predicate_part2 = comp_op quantifier table_subquery;
// <quantifier> ::= <all> | <some>
// <all> ::= ALL
quantifier = {all} t_all | {some_or_any} some_or_any;
// <some> ::= SOME | ANY
some_or_any = {some} t_some | {any} t_any;

// <exists predicate> ::= EXISTS <table subquery>
exists_predicate = t_exists table_subquery;

// <unique predicate> ::= UNIQUE <table subquery>
unique_predicate = t_unique table_subquery;

// <normalized predicate> ::= <row value predicand> <normalized predicate part 2>
//LALR normalized_predicate = row_value_predicand normalized_predicate_part2;
normalized_predicate = {row_value_special_case} row_value_special_case normalized_predicate_part2 | {row_value_constructor_predicand} row_value_constructor_predicand normalized_predicate_part2;
// <normalized predicate part 2> ::= IS [ NOT ] [ <normal form> ] NORMALIZED
normalized_predicate_part2 = t_is t_not? normal_form? t_normalized;
// <match predicate> ::= <row value predicand> <match predicate part 2>
match_predicate = row_value_predicand match_predicate_part2;
//match predicate part 2> ::= MATCH [ UNIQUE ] [ SIMPLE | PARTIAL | FULL ] <table subquery>
match_predicate_part2 = t_match t_unique? simple_partial_full? table_subquery;
simple_partial_full = {simple} t_simple | {partial} t_partial | {full} t_full;
// <overlaps predicate> ::= <overlaps predicate part 1> <overlaps predicate part 2>
overlaps_predicate = overlaps_predicate_part1 overlaps_predicate_part2;
// <overlaps predicate part 1> ::= <row value predicand 1>
overlaps_predicate_part1 = row_value_predicand1;
// <overlaps predicate part 2> ::= OVERLAPS <row value predicand 2>
overlaps_predicate_part2 = t_overlaps row_value_predicand2;
// <row value predicand 1> ::= <row value predicand>
row_value_predicand1 = row_value_predicand;
// <row value predicand 2> ::= <row value predicand>
row_value_predicand2 = row_value_predicand;

// <distinct predicate> ::= <row value predicand 3> <distinct predicate part 2>
//LALR distinct_predicate = row_value_predicand3 distinct_predicate_part2;
distinct_predicate = {row_value_special_case} row_value_special_case distinct_predicate_part2 | {row_value_constructor_predicand} row_value_constructor_predicand distinct_predicate_part2;
// <distinct predicate part 2> ::= IS [ NOT ] DISTINCT FROM <row value predicand 4>
distinct_predicate_part2 = t_is t_not? t_distinct t_from row_value_predicand4;
// <row value predicand 3> ::= <row value predicand>
row_value_predicand3 = row_value_predicand;
// <row value predicand 4> ::= <row value predicand>
row_value_predicand4 = row_value_predicand;

// <member predicate> ::= <row value predicand> <member predicate part 2>
member_predicate = row_value_predicand member_predicate_part2;
// <member predicate part 2> ::= [ NOT ] MEMBER [ OF ] <multiset value expression>
member_predicate_part2 = t_not? t_member t_of? multiset_value_expression;

// <submultiset predicate> ::= <row value predicand> <submultiset predicate part 2>
submultiset_predicate = row_value_predicand submultiset_predicate_part2;
// <submultiset predicate part 2> ::= [ NOT ] SUBMULTISET [ OF ] <multiset value expression>
submultiset_predicate_part2 = t_not? t_submultiset t_of? multiset_value_expression;
// <set predicate> ::= <row value predicand> <set predicate part 2>
//LALR set_predicate = row_value_predicand set_predicate_part2;
set_predicate = {row_value_special_case} row_value_special_case set_predicate_part2 | {row_value_constructor_predicand} row_value_constructor_predicand set_predicate_part2;
// <set predicate part 2> ::= IS [ NOT ] A SET
set_predicate_part2 = t_is t_not? t_a t_set;
// <type predicate> ::= <row value predicand> <type predicate part 2>
//LALR type_predicate = row_value_predicand type_predicate_part2;
type_predicate = {row_value_special_case} row_value_special_case type_predicate_part2 | {row_value_constructor_predicand} row_value_constructor_predicand type_predicate_part2;
// <type predicate part 2> ::= IS [ NOT ] OF <left paren> <type list> <right paren>
type_predicate_part2 = t_is t_not? t_of left_paren type_list right_paren;
// <type list> ::= <user-defined type specification> [ { <comma> <user-defined type specification> }... ]
type_list = user_defined_type_specification addl_user_defined_type_specification*;
addl_user_defined_type_specification = comma user_defined_type_specification;
// <user-defined type specification> ::= <inclusive user-defined type specification> | <exclusive user-defined type specification>
user_defined_type_specification = {inclusive_udt} inclusive_user_defined_type_specification | {exclusive_udt} exclusive_user_defined_type_specification;
// <inclusive user-defined type specification> ::= <path-resolved user-defined type name>
inclusive_user_defined_type_specification = path_resolved_user_defined_type_name;
// <exclusive user-defined type specification> ::= ONLY <path-resolved user-defined type name>
exclusive_user_defined_type_specification = path_resolved_user_defined_type_name;
// <period predicate> ::= <period overlaps predicate> | <period equals predicate> | <period contains predicate> | <period precedes predicate>
//  | <period succeeds predicate> | <period immediately precedes predicate> | <period immediately succeeds predicate>
period_predicate = {overlap} period_overlap_predicate | {equals} period_equals_predicate | {contains} period_contains_predicate | {precedes} period_precedes_predicate
    | {succeeds} period_succeeds_predicate | {immed_preceeds} period_immediately_precedes_predicate | {immed_succeeds} period_immediately_succeeds_predicate;
// <period overlaps predicate> ::= <period predicand 1> <period overlaps predicate part 2>
period_overlap_predicate = period_predicand1 period_overlap_predicate_part2;
// <period overlaps predicate part 2> ::= OVERLAPS <period predicand 2>
period_overlap_predicate_part2 = t_overlaps period_predicand2;
// <period predicand 1> ::= <period predicand>
period_predicand1 = period_predicand;
// <period predicand 2> ::= <period predicand>
period_predicand2 = period_predicand;
// <period predicand> ::= <period reference> | PERIOD <left paren> <period start value> <comma> <period end value> <right paren>
period_predicand = {period_reference} period_reference | {period_def} t_period left_paren period_start_value comma period_end_value right_paren;
// <period reference> ::= <basic identifier chain>
period_reference = basic_identifier_chain;
// <period start value> ::= <datetime value expression>
period_start_value = datetime_value_expression;
// <period end value> ::= <datetime value expression>
period_end_value = datetime_value_expression;
// <period equals predicate> ::= <period predicand 1> <period equals predicate part 2>
period_equals_predicate = period_predicand1 period_equals_predicate_part2;
// <period equals predicate part 2> ::= EQUALS <period predicand 2>
period_equals_predicate_part2 = t_equals period_predicand2;
// <period contains predicate> ::= <period predicand 1> <period contains predicate part 2>
period_contains_predicate = period_predicand1 period_contains_predicate_part2;
// <period contains predicate part 2> ::= CONTAINS <period or point-in-time predicand>
period_contains_predicate_part2 = t_contains period_or_point_in_time_predicand;
// <period or point-in-time predicand> ::= <period predicand> | <datetime value expression>
period_or_point_in_time_predicand = {period} period_predicand | {datetime} datetime_value_expression;
// <period precedes predicate> ::= <period predicand 1> <period precedes predicate part 2>
period_precedes_predicate = period_predicand1 period_precedes_predicate_part2;
// <period precedes predicate part 2> ::= PRECEDES <period predicand 2>
period_precedes_predicate_part2 = t_precedes period_predicand2;
// <period succeeds predicate> ::= <period predicand 1> <period succeeds predicate part 2>
period_succeeds_predicate = period_predicand1 period_succeeds_predicate_part2;
// <period succeeds predicate part 2> ::= SUCCEEDS <period predicand 2>
period_succeeds_predicate_part2 = t_succeeds period_predicand2;
// <period immediately precedes predicate> ::= <period predicand 1> <period immediately precedes predicate part 2>
period_immediately_precedes_predicate = period_predicand1 period_immediately_precedes_predicate_part2;
// <period immediately precedes predicate part 2> ::= IMMEDIATELY PRECEDES <period predicand 2>
period_immediately_precedes_predicate_part2 = t_immediately t_precedes period_predicand2;
// <period immediately succeeds predicate> ::= <period predicand 1> <period immediately succeeds predicate part 2>
period_immediately_succeeds_predicate = period_predicand1 period_immediately_succeeds_predicate_part2;
// <period immediately succeeds predicate part 2> ::= IMMEDIATELY SUCCEEDS <period predicand 2>
period_immediately_succeeds_predicate_part2 = t_immediately t_succeeds period_predicand2;

// <set function specification> ::= <aggregate function> | <grouping operation>
set_function_specification = {aggregate} aggregate_function | {grouping} grouping_operation;

// <grouping operation> ::= GROUPING <left paren> <column reference> [ { <comma> <column reference> }... ] <right paren>
grouping_operation = t_grouping left_paren column_reference addl_column_reference* right_paren;
addl_column_reference = comma column_reference;
// <window function> ::= <window function type> OVER <window name or specification>
window_function = window_function_type t_over window_name_or_specification;

// <window function type> ::= <rank function type> <left paren> <right paren> | ROW_NUMBER <left paren> <right paren> | <aggregate function>
//   | <ntile function> | <lead or lag function> | <first or last value function> | <nth value function>
window_function_type = {rank_function} rank_function_type left_paren right_paren | {row_number} t_row_number left_paren right_paren | {aggregate} aggregate_function 
    | {ntile} ntile_function | {lead_or_lag} lead_or_lag_function | {first_or_last} first_or_last_value_function | {nth_value} nth_value_function;
// <rank function type> ::= RANK | DENSE_RANK | PERCENT_RANK | CUME_DIST
rank_function_type = {rank} t_rank | {dense_rank} t_dense_rank | {percent_rank} t_percent_rank | {cume_dist} t_cume_dist;
// <ntile function> ::= NTILE <left paren> <number of tiles> <right paren>
ntile_function = t_ntile left_paren number_of_tiles right_paren;
// <number of tiles> ::= <simple value specification> | <dynamic parameter specification>
number_of_tiles = {simple} simple_value_specification | {dynamic} dynamic_parameter_specification;
// <lead or lag function> ::= <lead or lag> <left paren> <lead or lag extent> [ <comma> <offset> [ <comma> <default expression> ] ] <right paren> [ <null treatment> ]
lead_or_lag_function = lead_or_lag left_paren lead_or_lag_extent offset_default_expression? right_paren null_treatment?;
offset_default_expression = comma offset comma_default_expression?;
comma_default_expression = comma default_expression;
// <lead or lag> ::= LEAD | LAG
lead_or_lag = {lead} t_lead | {lag} t_lag;
// <lead or lag extent> ::= <value expression>
lead_or_lag_extent = value_expression;
// <offset> ::= <exact numeric literal>
offset = exact_numeric_literal;
// <default expression> ::= <value expression>
default_expression = value_expression;
// <null treatment> ::= RESPECT NULLS | IGNORE NULLS
null_treatment = {respect} t_respect t_nulls | {ignore} t_ignore t_nulls;
// <first or last value function> ::= <first or last value> <left paren> <value expression> <right paren> [ <null treatment> ]
first_or_last_value_function = first_or_last_value left_paren value_expression right_paren null_treatment?;
// <first or last value> ::= FIRST_VALUE | LAST_VALUE
first_or_last_value = {first} t_first_value | {last} t_last_value;
// <nth value function> ::= NTH_VALUE <left paren> <value expression> <comma> <nth row> <right paren> [ <from first or last> ] [ <null treatment> ]
nth_value_function = t_nth_value left_paren value_expression comma nth_row right_paren from_first_or_last? null_treatment?;
// <nth row> ::= <simple value specification> | <dynamic parameter specification>
nth_row = {simple_value} simple_value_specification | {dynamic_parameter} dynamic_parameter_specification;
// <from first or last> ::= FROM FIRST | FROM LAST
from_first_or_last = {first} t_from t_first | {last} t_from t_last;
// <window name or specification> ::= <window name> | <in-line window specification>
window_name_or_specification = {window_name} window_name | {inline} in_line_window_specification;
// <in-line window specification> ::= <window specification>
in_line_window_specification = window_specification;
// <nested window function> ::= <nested row number function> | <value_of expression at row>
nested_window_function = {function} nested_row_number_function | {value} value_of_expression_at_row;
// <nested row number function> ::= ROW_NUMBER <left paren> <row marker> <right paren>
nested_row_number_function = t_row_number left_paren row_marker right_paren;
// <value_of expression at row> ::= VALUE_OF <left paren> <value expression> AT <row marker expression> [ <comma> <value_of default value> ] <right paren>
value_of_expression_at_row = t_value_of left_paren value_expression t_at row_marker_expression comma_value_default_value? right_paren;
comma_value_default_value = comma value_of_default_value;
// <row marker> ::= BEGIN_PARTITION | BEGIN_FRAME | CURRENT_ROW | FRAME_ROW | END_FRAME | END_PARTITION
row_marker = {begin_partition} t_begin_partition | {begin_frame} t_begin_frame | {current_row} t_current_row | {frame_row} t_frame_row | {end_frame} t_end_frame | {end_partition} t_end_partition;
// <row marker expression> ::= <row marker> [ <row marker delta> ]
row_marker_expression = row_marker row_marker_delta?;
// <row marker delta> ::= <plus sign> <row marker offset> | <minus sign> <row marker offset>
row_marker_delta = {plus} plus_sign row_marker_offset | {minus} minus_sign row_marker_offset;
// <row marker offset> ::= <simple value specification> | <dynamic parameter specification>
row_marker_offset = {simple_value} simple_value_specification | {dynamic_parameter} dynamic_parameter_specification;
// <value_of default value> ::= <value expression>
value_of_default_value = value_expression;

// <case expression> ::= <case abbreviation> | <case specification>
case_expression = {abbreviation} case_abbreviation | {specification} case_specification;

// <case abbreviation> ::= NULLIF <left paren> <value expression> <comma> <value expression> <right paren>
// | COALESCE <left paren> <value expression> { <comma> <value expression> }... <right paren>
addl_value_expression = comma value_expression;
case_abbreviation = {null_if} t_nullif left_paren value_expression addl_value_expression right_paren
   | t_coalesce left_paren value_expression addl_value_expression+ right_paren;
// <case specification> ::= <simple case> | <searched case>
case_specification = {simple} simple_case | {searched} searched_case; 
// <simple case> ::= CASE <case operand> <simple when clause>... [ <else clause> ] END
simple_case = t_case case_operand simple_when_clause+ else_clause? t_end;
// <searched case> ::= CASE <searched when clause>... [ <else clause> ] END
searched_case = t_case searched_when_clause+ else_clause? t_end;
// <simple when clause> ::= WHEN <when operand list> THEN <result>
simple_when_clause = t_when when_operand_list t_then result;
// <searched when clause> ::= WHEN <search condition> THEN <result>
searched_when_clause = t_when search_condition t_then result; 
// <else clause> ::= ELSE <result>
else_clause = t_else result;
// <case operand> ::= <row value predicand> | <overlaps predicate part 1>
case_operand = {row_value} row_value_predicand | {overlaps} overlaps_predicate_part1;
// <when operand list> ::= <when operand> [ { <comma> <when operand> }... ]
when_operand_list = when_operand addl_when_operand*;
addl_when_operand = comma when_operand;
// <when operand> ::= <row value predicand> | <comparison predicate part 2> | <between predicate part 2> | <in predicate part 2> | <character like predicate part 2>
//   | <octet like predicate part 2> | <similar predicate part 2> | <regex like predicate part 2> | <null predicate part 2> | <quantified comparison predicate part 2>
//   | <normalized predicate part 2> | <match predicate part 2> | <overlaps predicate part 2> | <distinct predicate part 2> | <member predicate part 2> | <submultiset predicate part 2>
//   | <set predicate part 2> | <type predicate part 2>
when_operand = {row_value} row_value_predicand | {comparison} comparison_predicate_part2 | {between} between_predicate_part2 | {in} in_predicate_part2 | {character} character_like_predicate_part2 |
  | {octet} octet_like_predicate_part2 | {similar} similar_predicate_part2 | {regex} regex_like_predicate_part2 | {null} null_predicate_part2 | {quantified} quantified_comparison_predicate_part2 
  | {normalized} normalized_predicate_part2 | {match} match_predicate_part2 | {overlaps} overlaps_predicate_part2 | {distinct} distinct_predicate_part2 | {member} member_predicate_part2 | {submultiset} submultiset_predicate_part2
  | {set} set_predicate_part2 | {type} type_predicate_part2;
// <result> ::= <result expression> | NULL
result = {result} result_expression | {null} t_null;
// <result expression> ::= <value expression>
result_expression = value_expression;

// <cast specification> ::= CAST <left paren> <cast operand> AS <cast target> <right paren>
cast_specification = t_cast left_paren cast_operand t_as cast_target right_paren;

// <cast operand> ::= <value expression> | <implicitly typed value specification>
cast_operand = {value} value_expression | {implicit} implicitly_typed_value_specification;

// <cast target> ::= <domain name> | <data type>
cast_target = {domain_name} domain_name | {data_type} data_type;

// <next value expression> ::= NEXT VALUE FOR <sequence generator name>
next_value_expression = t_next t_value t_for sequence_generator_name;

// <field reference> ::= <value expression primary> <period> <field name>
field_reference = value_expression_primary period field_name;

// <subtype treatment> ::= TREAT <left paren> <subtype operand> AS <target subtype> <right paren>
subtype_treatment = t_treat left_paren subtype_operand t_as target_subtype right_paren;

// <subtype operand> ::= <value expression>
subtype_operand = value_expression;
// <target subtype> ::= <path-resolved user-defined type name> | <reference type>
target_subtype = {user_defined} path_resolved_user_defined_type_name | {reference_type} reference_type;

// <method invocation> ::= <direct invocation> | <generalized invocation>
method_invocation = {direct} direct_invocation | {general} generalized_invocation;

// <direct invocation> ::= <value expression primary> <period> <method name> [ <SQL argument list> ]
direct_invocation = value_expression_primary period method_name sql_argument_list?;
// <generalized invocation> ::= <left paren> <value expression primary> AS <data type> <right paren> <period> <method name> [ <SQL argument list> ]
generalized_invocation = left_paren value_expression_primary t_as data_type right_paren period method_name sql_argument_list?;
// <method selection> ::= <routine invocation>
// <constructor method selection> ::= <routine invocation>

// <static method invocation> ::= <path-resolved user-defined type name> <double colon> <method name> [ <SQL argument list> ]
static_method_invocation = path_resolved_user_defined_type_name double_colon method_name sql_argument_list?;

// <static method selection> ::= <routine invocation>

// <new specification> ::= NEW <path-resolved user-defined type name> <SQL argument list>
new_specification = t_new path_resolved_user_defined_type_name method_name sql_argument_list;

// <new invocation> ::= <method invocation> | <routine invocation>

// <attribute or method reference> ::= <value expression primary> <dereference operator> <qualified identifier> [ <SQL argument list> ]
attribute_or_method_reference = value_expression_primary dereference_operator qualified_identifier sql_argument_list;
// <dereference operator> ::= <right arrow>
dereference_operator = right_arrow;
// <dereference operation> ::= <reference value expression> <dereference operator> <attribute name>

// <method reference> ::= <value expression primary> <dereference operator> <method name> <SQL argument list>

// <reference resolution> ::= DEREF <left paren> <reference value expression> <right paren>
reference_resolution = t_deref left_paren reference_value_expression right_paren;

// <array element reference> ::= <array value expression> <left bracket or trigraph> <numeric value expression> <right bracket or trigraph>
array_element_reference = array_value_expression left_bracket_or_trigraph numeric_value_expression right_bracket_or_trigraph;

// <multiset element reference> ::= ELEMENT <left paren> <multiset value expression> <right paren>
multiset_element_reference = t_element left_paren multiset_value_expression right_paren;

// <routine invocation> ::= <routine name> <SQL argument list>
routine_invocation = routine_name sql_argument_list;

// <routine name> ::= [ <schema name> <period> ] <qualified identifier>
routine_name = schema_name_period? qualified_identifier;
schema_name_period = schema_name period;
// <SQL argument list> ::= <left paren> [ <SQL argument> [ { <comma> <SQL argument> }... ] ] <right paren>
sql_argument_list = left_paren sql_arguments? right_paren;
sql_arguments = sql_argument addl_sql_argument*;
addl_sql_argument = comma sql_argument;
// <SQL argument> ::= <value expression> | <generalized expression> | <target specification> | <contextually typed value specification> | <named argument specification>
sql_argument = {value} value_expression | {general} generalized_expression | {target} target_specification | {context} contextually_typed_value_specification | {named} named_argument_specification;
// <generalized expression> ::= <value expression> AS <path-resolved user-defined type name>
generalized_expression = value_expression t_as path_resolved_user_defined_type_name;
// <named argument specification> ::= <SQL parameter name> <named argument assignment token> <named argument SQL argument>
named_argument_specification = sql_parameter_name named_argument_assignment_token named_argument_sql_argument;
// <named argument SQL argument> ::= <value expression> | <target specification> | <contextually typed value specification>
named_argument_sql_argument = {value} value_expression | {target} target_specification | {context} contextually_typed_value_specification;
// <array value constructor> ::= <array value constructor by enumeration> | <array value constructor by query>
array_value_constructor = {enum} array_value_constructor_by_enumeration | {query} array_value_constructor_by_query;

// <array value constructor by enumeration> ::= ARRAY <left bracket or trigraph> <array element list> <right bracket or trigraph>
array_value_constructor_by_enumeration = t_array left_bracket_or_trigraph array_element_list right_bracket_or_trigraph;
// <array element list> ::= <array element> [ { <comma> <array element> }... ]
array_element_list = array_element addl_array_element*;
addl_array_element = comma array_element;
// <array element> ::= <value expression>
array_element = value_expression;
// <array value constructor by query> ::= ARRAY <table subquery>
array_value_constructor_by_query = t_array table_subquery;
// <multiset value constructor> ::= <multiset value constructor by enumeration> | <multiset value constructor by query> | <table value constructor by query>
multiset_value_constructor = {enum} multiset_value_constructor_by_enumeration | {query} multiset_value_constructor_by_query | {table} table_value_constructor_by_query;

// <multiset value constructor by enumeration> ::= MULTISET <left bracket or trigraph> <multiset element list> <right bracket or trigraph>
multiset_value_constructor_by_enumeration = t_multiset left_bracket_or_trigraph multiset_element_list right_bracket_or_trigraph;
// <multiset element list> ::= <multiset element> [ { <comma> <multiset element> }... ]
multiset_element_list = multiset_element addl_multiset_element*;
addl_multiset_element = comma multiset_element;
// <multiset element> ::= <value expression>
multiset_element = value_expression;
// <multiset value constructor by query> ::= MULTISET <table subquery>
multiset_value_constructor_by_query = t_multiset table_subquery;
// <table value constructor by query> ::= TABLE <table subquery>
table_value_constructor_by_query = t_table table_subquery;

// <interval qualifier> ::= <start field> TO <end field> | <single datetime field>
interval_qualifier = {range} start_field t_to end_field | {single} single_datetime_field;

// <start field> ::= <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
start_field = non_second_primary_datetime_field paren_interval_leading_field_precision?;
// <end field> ::= <non-second primary datetime field> | SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]
end_field = {primary} non_second_primary_datetime_field | {second} t_second  interval_fractional_seconds_precision?;
// <single datetime field> ::= <non-second primary datetime field> [ <left paren> <interval leading field precision> <right paren> ]
//   | SECOND [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]
single_datetime_field = {primary} non_second_primary_datetime_field paren_interval_leading_field_precision?
   | {second} t_second opt_precision?;
opt_precision  = left_paren paren_interval_leading_field_precision opt_fractional? right_paren;
opt_fractional = comma interval_fractional_seconds_precision;
// <primary datetime field> ::= <non-second primary datetime field> | SECOND
primary_datetime_field = {primary} non_second_primary_datetime_field | {second} t_second;
// <non-second primary datetime field> ::= YEAR | MONTH | DAY | HOUR | MINUTE
non_second_primary_datetime_field = {year} t_year | {month} t_month | {day} t_day | {hour} t_hour | {minute} t_minute;
// <interval fractional seconds precision> ::= <unsigned integer>
interval_fractional_seconds_precision = unsigned_integer;
paren_interval_fraction_seconds_precision = left_paren interval_fractional_seconds_precision right_paren;
// <interval leading field precision> ::= <unsigned integer>
interval_leading_field_precision = unsigned_integer;
paren_interval_leading_field_precision = left_paren interval_leading_field_precision right_paren;
// <interval value function> ::= <interval absolute value function>
interval_value_function = interval_absolute_value_function;
// <interval absolute value function> ::= ABS <left paren> <interval value expression> <right paren> 
interval_absolute_value_function = t_abs left_paren interval_value_expression right_paren;
// <table expression> ::= <from clause> [ <where clause> ] [ <group by clause> ] [ <having clause> ] [ <window clause> ]
table_expression = from_clause where_clause? group_by_clause? having_clause? window_clause?;

// <numeric value function> ::= <position expression> | <regex occurrences function> | <regex position expression> | <extract expression> | <length expression>
//   | <cardinality expression> | <max cardinality expression> | <absolute value expression> | <modulus expression> | <natural logarithm> | <exponential function>
//   | <power function> | <square root> | <floor function> | <ceiling function> | <width bucket function>
numeric_value_function = {pos} position_expression | {regex_occ} regex_occurrences_function | {regex_pos} regex_position_expression | {extract} extract_expression | {len} length_expression
   | {card} cardinality_expression | {max_card} max_cardinality_expression | {abs} absolute_value_expression | {mod} modulus_expression | {logn} natural_logarithm | {exp} exponential_function
   | {pow} power_function | {sqr} square_root | {floor} floor_function | {ceil} ceiling_function | {width} width_bucket_function;

// <position expression> ::= <character position expression> | <binary position expression>
position_expression = {character_position} character_position_expression | {binary_position} binary_position_expression;
// <regex occurrences function> ::= OCCURRENCES_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ FROM <start position> ] [ USING <char length units> ] <right paren>
regex_occurrences_function = t_occurrences_regex left_paren xquery_pattern xquery_option_flag_def? t_in regex_subject_string from_start_position? using_char_length? right_paren;
from_start_position = t_from start_position;
// <XQuery pattern> ::= <character value expression>
xquery_pattern = character_value_expression;
// <XQuery option flag> ::= <character value expression>
xquery_option_flag = character_value_expression;
// <regex subject string> ::= <character value expression>
regex_subject_string = character_value_expression;
// <regex position expression> ::= POSITION_REGEX <left paren> [ <regex position start or after> ] <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ FROM <start position> ] [ USING <char length units> ] [ OCCURRENCE <regex occurrence> ] [ GROUP <regex capture group> ] <right paren>
regex_position_expression = t_position_regex left_paren regex_position_start_or_after? xquery_pattern xquery_option_flag_def? t_in regex_subject_string from_start_position? using_char_length? occurrence_regex? group_regex_capture? right_paren;
occurrence_regex = t_occurrence regex_occurrence;
group_regex_capture = t_group regex_capture_group;
// <regex position start or after> ::= START | AFTER
regex_position_start_or_after = {start} t_start | {after} t_after;
// <regex occurrence> ::= <numeric value expression>
regex_occurrence = numeric_value_expression;
// <regex capture group> ::= <numeric value expression>
regex_capture_group = numeric_value_expression;
// <character position expression> ::= POSITION <left paren> <character value expression 1> IN <character value expression 2> [ USING <char length units> ] <right paren>
character_position_expression = t_position left_paren character_value_expression1 t_in character_value_expression2 using_char_length? right_paren;
using_char_length = t_using char_length_units;
// <character value expression 1> ::= <character value expression>
character_value_expression1 = character_value_expression;
//<character value expression 2> ::= <character value expression>
character_value_expression2 = character_value_expression;
// <binary position expression> ::= POSITION <left paren> <binary value expression> IN <binary value expression> <right paren>
binary_position_expression = t_position left_paren [first]:binary_value_expression t_in [second]:binary_value_expression right_paren;
// <length expression> ::= <char length expression> | <octet length expression>
length_expression = {char_length} char_length_expression | {octet_length} octet_length_expression;
// <char length expression> ::= { CHAR_LENGTH | CHARACTER_LENGTH } <left paren> <character value expression> [ USING <char length units> ] <right paren>
char_length_expression = char_or_character_length left_paren character_value_expression using_char_length? right_paren;
char_or_character_length = {char} t_char_length | {character} t_character_length;
// <octet length expression> ::= OCTET_LENGTH <left paren> <string value expression> <right paren>
octet_length_expression = t_octet_length left_paren string_value_expression right_paren;
// <extract expression> ::= EXTRACT <left paren> <extract field> FROM <extract source> <right paren>
extract_expression = t_extract left_paren extract_field t_from extract_source right_paren;
// <extract field> ::= <primary datetime field> | <time zone field>
extract_field = {primary} primary_datetime_field | {time_zone} time_zone_field;
// <time zone field> ::= TIMEZONE_HOUR | TIMEZONE_MINUTE
time_zone_field = {hour} t_timezone_hour | {minute} t_timezone_minute;
// <extract source> ::= <datetime value expression> | <interval value expression>
extract_source = {datetime} datetime_value_expression | {interval} interval_value_expression;
// <cardinality expression> ::= CARDINALITY <left paren> <collection value expression> <right paren>
cardinality_expression = t_cardinality left_paren collection_value_expression right_paren;
// <max cardinality expression> ::= ARRAY_MAX_CARDINALITY <left paren> <array value expression> <right paren> 
max_cardinality_expression = t_array_max_cardinality left_paren array_value_expression right_paren;
// <absolute value expression> ::= ABS <left paren> <numeric value expression> <right paren>
absolute_value_expression = t_abs left_paren numeric_value_expression right_paren;
// <modulus expression> ::= MOD <left paren> <numeric value expression dividend> <comma> <numeric value expression divisor><right paren> 
modulus_expression = t_mod left_paren numeric_value_expression_dividend comma numeric_value_expression_divisor right_paren;
// <numeric value expression dividend> ::= <numeric value expression>
numeric_value_expression_dividend = numeric_value_expression;
// <numeric value expression divisor> ::= <numeric value expression>
numeric_value_expression_divisor = numeric_value_expression;
// <natural logarithm> ::= LN <left paren> <numeric value expression> <right paren>
natural_logarithm = t_ln left_paren numeric_value_expression right_paren;
// <exponential function> ::= EXP <left paren> <numeric value expression> <right paren>
exponential_function = t_exp left_paren numeric_value_expression right_paren;
// <power function> ::= POWER <left paren> <numeric value expression base> <comma> <numeric value expression exponent> <right paren>
power_function = t_power left_paren numeric_value_expression_base comma numeric_value_expression_exponent right_paren;
// <numeric value expression base> ::= <numeric value expression>
numeric_value_expression_base = numeric_value_expression;
// <numeric value expression exponent> ::= <numeric value expression>
numeric_value_expression_exponent = numeric_value_expression;
// <square root> ::= SQRT <left paren> <numeric value expression> <right paren>
square_root = t_sqrt left_paren numeric_value_expression right_paren;
// <floor function> ::= FLOOR <left paren> <numeric value expression> <right paren>
floor_function = t_floor left_paren numeric_value_expression right_paren;
// <ceiling function> ::= { CEIL | CEILING } <left paren> <numeric value expression> <right paren>
ceiling_function = ceil_or_ceiling left_paren numeric_value_expression right_paren;
ceil_or_ceiling = {ceil} t_ceil | {ceiling} t_ceiling;
// <width bucket function> ::= WIDTH_BUCKET <left paren> <width bucket operand> <comma> <width bucket bound 1> <comma> <width bucket bound 2> <comma> <width bucket count> <right paren> 
width_bucket_function = t_width_bucket left_paren width_bucket_operand [comma1]:comma width_bucket_bound1 comma width_bucket_bound2 [comma2]:comma width_bucket_count right_paren;
// <width bucket operand> ::= <numeric value expression>
width_bucket_operand = numeric_value_expression;
// <width bucket bound 1> ::= <numeric value expression>
width_bucket_bound1 = numeric_value_expression;
// <width bucket bound 2> ::= <numeric value expression>
width_bucket_bound2 = numeric_value_expression;
// <width bucket count> ::= <numeric value expression>
width_bucket_count = numeric_value_expression;
// <collate clause> ::= COLLATE <collation name>
collate_clause = t_collate collation_name;

// <string value function> ::= <character value function> | <binary value function>
string_value_function = {character} character_value_function | {binary} binary_value_function;

// <character value function> ::= <character substring function> | <regular expression substring function> | <regex substring function>
//   | <fold> | <transcoding> | <character transliteration> | <regex transliteration> | <trim function> | <character overlay function>
//   | <normalize function> | <specific type method>
character_value_function = {character_substring} character_substring_function | {regular_substring} regular_expession_substring_function | {regex_substring} regex_substring_function
  | {fold} fold | {transcoding} transcoding | {char_trans} character_transliteration | {regex_trans} regex_transliteration | {trim} trim_function | {overlay} character_overlay_function
  | {normalize} normalize_function | {specific} specific_type_method;
// <character substring function> ::= SUBSTRING <left paren> <character value expression> FROM <start position> [ FOR <string length> ] [ USING <char length units> ] <right paren>
character_substring_function = t_substring left_paren character_value_expression t_from start_position for_string_len? using_char_length? right_paren;
for_string_len = t_for string_length;
// <regular expression substring function> ::= SUBSTRING <left paren> <character value expression> SIMILAR <character value expression> ESCAPE <escape character> <right paren>
regular_expession_substring_function = t_substring left_paren [first]:character_value_expression t_similar [second]:character_value_expression t_escape escape_character right_paren;
// <regex substring function> ::= SUBSTRING_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ FROM <start position> ] [ USING <char length units> ] [ OCCURRENCE <regex occurrence> ] [ GROUP <regex capture group> ] <right paren>
regex_substring_function = t_substring_regex left_paren xquery_pattern xquery_option_flag_def? t_in regex_subject_string from_start_position? using_char_length? occurrence_regex? group_regex_capture? right_paren;
// <fold> ::= { UPPER | LOWER } <left paren> <character value expression> <right paren>
fold = upper_or_lower left_paren character_value_expression right_paren;
upper_or_lower = {upper} t_upper | {lower} t_lower;
// <transcoding> ::= CONVERT <left paren> <character value expression> USING <transcoding name> <right paren>
transcoding = t_convert left_paren character_value_expression t_using transcoding_name right_paren;
// <character transliteration> ::= TRANSLATE <left paren> <character value expression> USING <transliteration name> <right paren>
character_transliteration = t_translate left_paren character_value_expression t_using transliteration_name right_paren;
// <regex transliteration> ::= TRANSLATE_REGEX <left paren> <XQuery pattern> [ FLAG <XQuery option flag> ] IN <regex subject string> [ WITH <XQuery replacement string> ] [ FROM <start position> ] [ USING <char length units> ] [ OCCURRENCE <regex transliteration occurrence> ] <right paren>
regex_transliteration = t_translate_regex left_paren xquery_pattern xquery_option_flag_def? t_in regex_subject_string with_xquery_replacement? from_start_position? using_char_length? occurrence_regex_translit? group_regex_capture? right_paren;
with_xquery_replacement = t_with xquery_replacement_string;
occurrence_regex_translit = t_occurrence regex_transliteration_occurrence;
// <XQuery replacement string> ::= <character value expression>
xquery_replacement_string = character_value_expression;
// <regex transliteration occurrence> ::= <regex occurrence> | ALL
regex_transliteration_occurrence = {regex} regex_occurrence | {all} t_all;
// <trim function> ::= TRIM <left paren> <trim operands> <right paren>
trim_function = t_trim left_paren trim_operands right_paren;
// <trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>
trim_operands = opt_trim_char_spec? trim_source;
opt_trim_char_spec = trim_specification? trim_character? t_from;
// <trim source> ::= <character value expression>
trim_source = character_value_expression;
// <trim specification> ::= LEADING | TRAILING | BOTH
trim_specification = {leading} t_leading | {trailing} t_trailing | {both} t_both;
// <trim character> ::= <character value expression>
trim_character = character_value_expression;
// <character overlay function> ::= OVERLAY <left paren> <character value expression> PLACING <character value expression> FROM <start position> [ FOR <string length> ] [ USING <char length units> ] <right paren>
character_overlay_function = t_overlay left_paren [first]:character_value_expression t_placing [second]:character_value_expression t_from start_position for_string_len? using_char_length? right_paren;
// <normalize function> ::= NORMALIZE <left paren> <character value expression> [ <comma> <normal form> [ <comma> <normalize function result length> ] ] <right paren>
normalize_function = t_normalize left_paren character_value_expression opt_normalize? right_paren;
opt_normalize = comma normal_form comma_normalize_function?;
comma_normalize_function = comma normalize_function_result_length;
// <normal form> ::= NFC | NFD | NFKC | NFKD
normal_form = {nfc} t_nfc | {nfd} t_nfd | {nfkc} t_nfkc | {nfkd} t_nfkd;
// <normalize function result length> ::= <character length> | <character large object length>
normalize_function_result_length = {character} character_length | {clob} character_large_object_length;
// <specific type method> ::= <user-defined type value expression> <period> SPECIFICTYPE [ <left paren> <right paren> ]
specific_type_method = user_defined_type_value_expression period t_specifictype opt_parens?;
opt_parens = left_paren right_paren;
// <binary value function> ::= <binary substring function> | <binary trim function> | <binary overlay function>
binary_value_function = {substring} binary_substring_function | {trim} binary_trim_function | {overlay} binary_overlay_function;
// <binary substring function> ::= SUBSTRING <left paren> <binary value expression> FROM <start position> [ FOR <string length> ] <right paren>
binary_substring_function = t_substring left_paren binary_value_expression t_from start_position for_string_len? right_paren;
// <binary trim function> ::= TRIM <left paren> <binary trim operands> <right paren>
binary_trim_function = t_trim left_paren binary_trim_operands right_paren;
// <binary trim operands> ::= [ [ <trim specification> ] [ <trim octet> ] FROM ] <binary trim source>
binary_trim_operands = opt_trim_binary_spec? binary_trim_source;
opt_trim_binary_spec = trim_specification? trim_octet? t_from;
// <binary trim source> ::= <binary value expression>
binary_trim_source = binary_value_expression;
// <trim octet> ::= <binary value expression>
trim_octet = binary_value_expression;
// <binary overlay function> ::= OVERLAY <left paren> <binary value expression> PLACING <binary value expression> FROM <start position> [ FOR <string length> ] <right paren>
binary_overlay_function = t_overlay left_paren [first]:binary_value_expression t_placing [second]:binary_value_expression t_from start_position for_string_len? right_paren;
// <start position> ::= <numeric value expression>
start_position = numeric_value_expression;
// <string length> ::= <numeric value expression>
string_length = numeric_value_expression;
// <array value function> ::= <trim array function>
array_value_function = trim_array_function;
// <trim array function> ::= TRIM_ARRAY <left paren> <array value expression> <comma> <numeric value expression> <right paren>iden
trim_array_function = t_trim_array left_paren array_value_expression comma numeric_value_expression right_paren;
// <multiset value function> ::= <multiset set function>
multiset_value_function = multiset_set_function;
// <multiset set function> ::= SET <left paren> <multiset value expression> <right paren>
multiset_set_function = t_set left_paren multiset_value_expression right_paren;
// <identifier chain> ::= <identifier> [ { <period> <identifier> }... ]
//LALR addl_identifier = period identifier;
addl_identifier = {regular_identifier} period regular_identifier | {delimited_identifier} period delimited_identifier | {unicode_delimited_identifier} period  unicode_delimited_identifier;
//LALR identifier_chain = identifier addl_identifier*;
identifier_chain = {regular_identifier} regular_identifier addl_identifier* | {delimited_identifier} delimited_identifier addl_identifier* | {unicode_delimited_identifier} unicode_delimited_identifier addl_identifier*;

// <basic identifier chain> ::= <identifier chain>
basic_identifier_chain = identifier_chain;

// <embedded variable name> ::= <colon><host identifier>
embedded_variable_name = colon host_identifier;

// <host identifier> ::= <Ada host identifier> | <C host identifier> | <COBOL host identifier> | <Fortran host identifier> | <MUMPS host identifier> | <Pascal host identifier> | <PL/I host identifier>
host_identifier = {ada} t_ada | {c} t_c | {cobol} t_cobol | {fortran} t_fortran
   | {mumps} t_mumps | {pascal} t_pascal | {pli} t_pli;

// <constraint name definition> ::= CONSTRAINT <constraint name>
constraint_name_definition = t_constraint constraint_name;
// <constraint characteristics> ::= <constraint check time> [ [ NOT ] DEFERRABLE ] [ <constraint enforcement> ] | [ NOT ] DEFERRABLE [ <constraint check time> ] [ <constraint enforcement> ] | <constraint enforcement>
not_deferrable = t_not? t_deferrable;
constraint_characteristics = {check} constraint_check_time not_deferrable? constraint_enforcement? 
   | {not} not_deferrable constraint_check_time? constraint_enforcement?  | {enforce} constraint_enforcement;

// <constraint check time> ::= INITIALLY DEFERRED | INITIALLY IMMEDIATE
constraint_check_time = {deferred} t_initially t_deferred | {immediate} t_initially t_immediate;

// <constraint enforcement> ::= [ NOT ] ENFORCED
constraint_enforcement = t_not? t_enforced;

// <unique constraint definition> ::= <unique specification> <left paren> <unique column list> [ <comma> <without overlap specification> ] <right paren> | UNIQUE ( VALUE )
unique_constraint_definition = {spec} unique_specification left_paren unique_column_list comma_overlap? right_paren | {unique} t_unique t_value?;
comma_overlap = comma without_overlap_specification;

// <unique specification> ::= UNIQUE | PRIMARY KEY
unique_specification = {unique} t_unique | {pk} t_primary t_key;
// <unique column list> ::= <column name list>
unique_column_list = column_name_list;

// <without overlap specification> ::= <application time period name> WITHOUT OVERLAPS
without_overlap_specification = application_time_period_name t_without t_overlaps;

// <referential constraint definition> ::= FOREIGN KEY <left paren> <referencing column list> [ <comma> <referencing period specification> ] <right paren> <references specification>
referential_constraint_definition = t_foreign t_key left_paren referencing_column_list comma_ref_period_spec? right_paren references_specification;
comma_ref_period_spec = comma referencing_period_specification;

// <references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]
references_specification = t_references referenced_table_and_columns match_match_type? referential_triggered_action?;
match_match_type = t_match match_type;

// <match type> ::= FULL | PARTIAL | SIMPLE
match_type = {full} t_full | {partial} t_partial | {simple} t_simple;
// <referencing column list> ::= <column name list>
referencing_column_list = column_name_list;
// <referencing period specification> ::= PERIOD <application time period name>
referencing_period_specification = t_period application_time_period_name;
// <referenced table and columns> ::= <table name> [ <left paren> <referenced column list> [ <comma> <referenced period specification> ] <right paren> ]
referenced_table_and_columns = table_name opt_ref_column_list?;
opt_ref_column_list = left_paren referenced_column_list comma_ref_period_spec? right_paren;
// <referenced column list> ::= <column name list>
referenced_column_list = column_name_list;
// <referenced period specification> ::= PERIOD <application time period name>
referenced_period_specification = t_period application_time_period_name;
// <referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]
referential_triggered_action = {update} update_rule delete_rule? | {delete} delete_rule update_rule?;
// <update rule> ::= ON UPDATE <referential action>
update_rule = t_on t_update referential_action;
// <delete rule> ::= ON DELETE <referential action>
delete_rule = t_on t_delete referential_action;
// <referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION
referential_action = {cascade} t_cascade | {set_null} t_set t_null | {set_default} t_set t_default | {restrict} t_restrict | {no_action} t_no t_action; 

// <check constraint definition> ::= CHECK <left paren> <search condition> <right paren>
check_constraint_definition = t_check left_paren search_condition right_paren;

// <sequence generator definition> ::= CREATE SEQUENCE <sequence generator name> [ <sequence generator options> ]
// <sequence generator options> ::= <sequence generator option> ...
// <sequence generator option> ::= <sequence generator data type option> | <common sequence generator options>
// <common sequence generator options> ::= <common sequence generator option> ...
common_sequence_generator_options = common_sequence_generator_option+;
// <common sequence generator option> ::= <sequence generator start with option> | <basic sequence generator option>
common_sequence_generator_option = {start_with} sequence_generator_start_with_option | {basic} basic_sequence_generator_option;
// <basic sequence generator option> ::= <sequence generator increment by option> | <sequence generator maxvalue option> | <sequence generator minvalue option>
//  | <sequence generator cycle option>
basic_sequence_generator_option = {increment} sequence_generator_increment_by_option | {max_value} sequence_generator_maxvalue_option | {min_value} sequence_generator_minvalue_option
   | {cycle} sequence_generator_cycle_option;
// <sequence generator data type option> ::= AS <data type>
sequence_generator_data_type_option = t_as data_type;
// <sequence generator start with option> ::= START WITH <sequence generator start value>
sequence_generator_start_with_option = t_start t_with sequence_generator_start_value;
// <sequence generator start value> ::= <signed numeric literal>
sequence_generator_start_value = signed_numeric_literal;
// <sequence generator increment by option> ::= INCREMENT BY <sequence generator increment>
sequence_generator_increment_by_option = t_increment t_by sequence_generator_increment;
// <sequence generator increment> ::= <signed numeric literal>
sequence_generator_increment = signed_numeric_literal;
// <sequence generator maxvalue option> ::= MAXVALUE <sequence generator max value> | NO MAXVALUE
sequence_generator_maxvalue_option = {maxvalue} t_maxvalue sequence_generator_max_value | {no_maxvalue} t_no t_maxvalue; 
// sequence generator max value> ::= <signed numeric literal>
sequence_generator_max_value = signed_numeric_literal;
// <sequence generator minvalue option> ::= MINVALUE <sequence generator min value> | NO MINVALUE
sequence_generator_minvalue_option = {minvalue} t_minvalue sequence_generator_min_value | {no_minvalue} t_no t_minvalue; 
// <sequence generator min value> ::= <signed numeric literal>
sequence_generator_min_value = signed_numeric_literal;
// <sequence generator cycle option> ::= CYCLE | NO CYCLE
sequence_generator_cycle_option = {cycle} t_cycle | {no_cycle} t_no t_cycle;

// <field definition> ::= <field name> <data type>
field_definition = field_name data_type;

// <aggregate function> ::= COUNT <left paren> <asterisk> <right paren> [ <filter clause> ] | <general set function> [ <filter clause> ]
//    | <binary set function> [ <filter clause> ] | <ordered set function> [ <filter clause> ] | <array aggregate function> [ <filter clause> ]
aggregate_function = {count} t_count left_paren asterisk right_paren filter_clause? | {general_set_function}  general_set_function filter_clause?
   | {binary_set_function} binary_set_function filter_clause? | {ordered_set_function} ordered_set_function filter_clause? | {array_aggregate_function} array_aggregate_function filter_clause?;
// LALR
count_star = t_count left_paren asterisk right_paren;
// <general set function> ::=<set function type> <left paren> [ <set quantifier> ] <value expression> <right paren>
general_set_function = {non_count} set_function_type left_paren set_quantifier? value_expression right_paren | {count} count_function;
count_function = {count_star} t_count left_paren asterisk right_paren | {count_value} t_count left_paren set_quantifier? value_expression right_paren;
// <set function type> ::=<computational operation>
set_function_type = computational_operation;
// <computational operation> ::= AVG | MAX | MIN | SUM | EVERY | ANY | SOME | COUNT | STDDEV_POP | STDDEV_SAMP | VAR_SAMP | VAR_POP | COLLECT | FUSION | INTERSECTION
computational_operation = {avg} t_avg | {max} t_max | {min} t_min | {sum} t_sum | {every} t_every | {any} t_any | {some} t_some | {stddev_pop} t_stddev_pop
 | {stddev_samp} t_stddev_samp | {var_samp} t_var_samp | {var_pop} t_var_pop | {collect} t_collect | {fusion} t_fusion | {intersection} t_intersection;
// <set quantifier> ::= DISTINCT | ALL
set_quantifier = {distinct} t_distinct | {all} t_all;
// <filter clause> ::= FILTER <left paren> WHERE <search condition> <right paren>
filter_clause = t_filter left_paren t_where search_condition right_paren;
// <binary set function> ::= <binary set function type> <left paren> <dependent variable expression> <comma> <independent variable expression> <right paren>
binary_set_function = binary_set_function_type left_paren dependent_variable_expression comma independent_variable_expression right_paren;
// <binary set function type> ::= COVAR_POP | COVAR_SAMP | CORR | REGR_SLOPE | REGR_INTERCEPT | REGR_COUNT | REGR_R2 | REGR_AVGX | REGR_AVGY | REGR_SXX | REGR_SYY | REGR_SXY
binary_set_function_type = {covar_pop} t_covar_pop | {covar_samp} t_covar_samp | {corr} t_corr | {regr_slope} t_regr_slope | {regr_intercept} t_regr_intercept
 | {regr_count} t_regr_count | {regr_r2} t_regr_r2 | {regr_avgx} t_regr_avgx | {regr_avgy} t_regr_avgy | {regr_sxx} t_regr_sxx | {regr_syy} t_regr_syy | {regr_sxy} t_regr_sxy  ;
// <dependent variable expression> ::= <numeric value expression>
dependent_variable_expression = numeric_value_expression;
// <independent variable expression> ::= <numeric value expression>
independent_variable_expression = numeric_value_expression;
// <ordered set function> ::= <hypothetical set function> | <inverse distribution function>
ordered_set_function = {hypothetical} hypothetical_set_function | {inverse} inverse_distribution_function;
// <hypothetical set function> ::= <rank function type> <left paren> <hypothetical set function value expression list> <right paren> <within group specification>
hypothetical_set_function = rank_function_type left_paren hypothetical_set_function_value_expression_list right_paren within_group_specificaton;
// <within group specification> ::= WITHIN GROUP <left paren> ORDER BY <sort specification list> <right paren>
within_group_specificaton = t_within t_group left_paren t_order t_by sort_specification_list right_paren;
// <hypothetical set function value expression list> ::= <value expression> [ { <comma> <value expression> }... ]
hypothetical_set_function_value_expression_list = value_expression addl_value_expression*;
// <inverse distribution function> ::= <inverse distribution function type> <left paren> <inverse distribution function argument> <right paren> <within group specification>
inverse_distribution_function = inverse_distribution_function_type left_paren inverse_distribution_function_argument right_paren within_group_specificaton;
// <inverse distribution function argument> ::= <numeric value expression>
inverse_distribution_function_argument = numeric_value_expression;
// <inverse distribution function type> ::= PERCENTILE_CONT | PERCENTILE_DISC
inverse_distribution_function_type = {cont} t_percentile_cont | {disc} t_percentile_disc;
// <array aggregate function> ::= ARRAY_AGG <left paren> <value expression> [ ORDER BY <sort specification list> ] <right paren>
order_clause = t_order t_by sort_specification_list;
array_aggregate_function = t_array_agg left_paren value_expression order_clause right_paren;

// <window clause> ::= WINDOW <window definition list>
window_clause = t_window window_definition_list;
// <window definition list> ::= <window definition> [ { <comma> <window definition> }... ]
window_definition_list = window_definition addl_window_definition*;
addl_window_definition = comma window_definition;
// <window definition> ::= <new window name> AS <window specification>
window_definition = new_window_name t_as window_specification;
// <new window name> ::= <window name>
new_window_name = window_name;
// <window specification> ::= <left paren> <window specification details> <right paren>
window_specification = left_paren window_specification_details right_paren;
// <window specification details> ::= [ <existing window name> ] [ <window partition clause> ] [ <window order clause> ] [ <window frame clause> ]
window_specification_details = existing_window_name? window_partition_clause? window_order_clause? window_frame_clause?;
// <existing window name> ::= <window name>
existing_window_name = window_name;
// <window partition clause> ::= PARTITION BY <window partition column reference list>
window_partition_clause = t_partition t_by window_partition_column_reference_list;
// <window partition column reference list> ::= <window partition column reference> [ { <comma> <window partition column reference> }... ]
window_partition_column_reference_list = window_partition_column_reference addl_window_partition_column_reference*;
addl_window_partition_column_reference = comma window_partition_column_reference;
// <window partition column reference> ::= <column reference> [ <collate clause> ]
window_partition_column_reference = column_reference collate_clause?;
// <window order clause> ::= ORDER BY <sort specification list>
window_order_clause = order_clause;
// <window frame clause> ::= <window frame units> <window frame extent> [ <window frame exclusion> ]
window_frame_clause = window_frame_units window_frame_extent window_frame_exclusion?;
// <window frame units> ::= ROWS | RANGE | GROUPS
window_frame_units = {rows} t_rows | {range} t_range | {groups} t_groups;
// <window frame extent> ::= <window frame start> | <window frame between>
window_frame_extent = {start} window_frame_start | {between} window_frame_between;
// <window frame start> ::= UNBOUNDED PRECEDING | <window frame preceding> | CURRENT ROW
window_frame_start = {unbounded} t_unbounded t_preceding | {window} window_frame_preceding | {current_row} t_current t_row;
// <window frame preceding> ::= <unsigned value specification> PRECEDING
window_frame_preceding = unsigned_value_specification t_preceding;
// <window frame between> ::= BETWEEN <window frame bound 1> AND <window frame bound 2>
window_frame_between = t_between window_frame_bound1 t_and window_frame_bound2;
// <window frame bound 1> ::= <window frame bound>
window_frame_bound1 = window_frame_bound;
// <window frame bound 2> ::= <window frame bound>
window_frame_bound2 = window_frame_bound;
// <window frame bound> ::= <window frame start> | UNBOUNDED FOLLOWING | <window frame following> 
window_frame_bound = {window_start} window_frame_start | {unbounded} t_unbounded t_following | {window_following} window_frame_following;
// <window frame following> ::= <unsigned value specification> FOLLOWING
window_frame_following = unsigned_value_specification t_following;
// <window frame exclusion> ::= EXCLUDE CURRENT ROW | EXCLUDE GROUP | EXCLUDE TIES | EXCLUDE NO OTHERS
window_frame_exclusion = {current_row} t_exclude t_current t_row | {group} t_exclude t_group | {ties} t_exclude t_ties | {no_others} t_exclude t_no t_others; 

// <from clause> ::= FROM <table reference list>
from_clause = t_from table_reference_list;
// <table reference list> ::= <table reference> [ { <comma> <table reference> }... ]
table_reference_list = table_reference addl_table_reference*;
addl_table_reference = comma table_reference;

// <group by clause> ::= GROUP BY [ <set quantifier> ] <grouping element list>
group_by_clause = t_group t_by set_quantifier? grouping_element_list;
// <grouping element list> ::= <grouping element> [ { <comma> <grouping element> }... ]
grouping_element_list = grouping_element addl_grouping_element*;
addl_grouping_element = comma grouping_element;
// <grouping element> ::= <ordinary grouping set> | <rollup list> | <cube list> | <grouping sets specification> | <empty grouping set>
grouping_element = {ordinary} ordinary_grouping_set | {rollup} rollup_list | {cube} cube_list | {spec} grouping_sets_specification | {empty} empty_grouping_set; 
// <ordinary grouping set> ::= <grouping column reference> | <left paren> <grouping column reference list> <right paren>
ordinary_grouping_set = {single} grouping_column_reference | {list} left_paren grouping_column_reference_list right_paren;
// <grouping column reference> ::= <column reference> [ <collate clause> ]
grouping_column_reference = column_reference collate_clause;
// <grouping column reference list> ::= <grouping column reference> [ { <comma> <grouping column reference> }... ]
grouping_column_reference_list = grouping_column_reference addl_grouping_column_reference*;
addl_grouping_column_reference = comma grouping_column_reference;
// <rollup list> ::= ROLLUP <left paren> <ordinary grouping set list> <right paren>
rollup_list = t_rollup left_paren ordinary_grouping_set_list right_paren;
// <ordinary grouping set list> ::= <ordinary grouping set> [ { <comma> <ordinary grouping set> }... ]
ordinary_grouping_set_list = ordinary_grouping_set addl_ordinary_grouping_set*;
addl_ordinary_grouping_set = comma ordinary_grouping_set;
// <cube list> ::= CUBE <left paren> <ordinary grouping set list> <right paren>
cube_list = t_cube left_paren ordinary_grouping_set_list right_paren;
// <grouping sets specification> ::= GROUPING SETS <left paren> <grouping set list> <right paren>
grouping_sets_specification = t_grouping t_sets left_paren grouping_set_list right_paren;
// <grouping set list> ::= <grouping set> [ { <comma> <grouping set> }... ]
grouping_set_list = grouping_set addl_grouping_set*;
addl_grouping_set = comma grouping_set;
// <grouping set> ::= <ordinary grouping set> | <rollup list> | <cube list> | <grouping sets specification> | <empty grouping set>
grouping_set = {ordinary} ordinary_grouping_set | {rollup} rollup_list | {cube} cube_list | {spec} grouping_sets_specification | {empty_grouping_set} empty_grouping_set; 
// <empty grouping set> ::= <left paren> <right paren>
empty_grouping_set = left_paren right_paren;
// <having clause> ::= HAVING <search condition>
having_clause = t_having search_condition;
